<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Airplane Modal Test &mdash; SDynPy 0.5.1 documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../_static/copybutton.css" type="text/css" />
      <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script src="../_static/clipboard.min.js"></script>
        <script src="../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Rattlesnake Demonstration" href="rattlesnake_demonstration.html" />
    <link rel="prev" title="SDynpy Examples" href="../examples.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../index.html" class="icon icon-home"> SDynPy
          </a>
              <div class="version">
                0.5.1
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../examples.html">SDynpy Examples</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">Airplane Modal Test</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#imports">Imports</a></li>
<li class="toctree-l3"><a class="reference internal" href="#default-plotting-options">Default Plotting Options</a></li>
<li class="toctree-l3"><a class="reference internal" href="#load-the-finite-element-model">Load the Finite Element Model</a></li>
<li class="toctree-l3"><a class="reference internal" href="#convert-finite-element-model-to-sdynpy-objects">Convert Finite Element Model to SDynPy Objects</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-geometry-from-an-exodus-file">Creating a Geometry from an Exodus file</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exploring-the-geometry-object">Exploring the Geometry object</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#nodes">Nodes</a></li>
<li class="toctree-l5"><a class="reference internal" href="#coordinate-systems">Coordinate Systems</a></li>
<li class="toctree-l5"><a class="reference internal" href="#elements">Elements</a></li>
<li class="toctree-l5"><a class="reference internal" href="#tracelines">Tracelines</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#visualizing-degrees-of-freedom-on-a-geometry">Visualizing Degrees of Freedom on a Geometry</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#coordinates">Coordinates</a></li>
<li class="toctree-l5"><a class="reference internal" href="#plotting-coordinates">Plotting Coordinates</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#creating-shapes-from-an-exodus-file">Creating Shapes from an Exodus File</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#shapes">Shapes</a></li>
<li class="toctree-l5"><a class="reference internal" href="#correcting-negative-frequencies-and-array-views-versus-copies">Correcting Negative Frequencies and Array Views versus Copies</a></li>
<li class="toctree-l5"><a class="reference internal" href="#transforming-shape-coordinate-systems">Transforming Shape Coordinate Systems</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#optimizing-instrumentation-for-test">Optimizing Instrumentation for Test</a></li>
<li class="toctree-l3"><a class="reference internal" href="#creating-a-test-geometry">Creating a Test Geometry</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#oops-an-instrumentation-error">OOPS! An Instrumentation Error!</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#running-a-virtual-experiment-rigid-body-checkouts">Running a Virtual Experiment: Rigid Body Checkouts</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#creating-a-system-object-to-integrate">Creating a System Object to Integrate</a><ul>
<li class="toctree-l5"><a class="reference internal" href="#exploring-the-system-object">Exploring the System Object</a></li>
</ul>
</li>
<li class="toctree-l4"><a class="reference internal" href="#setting-up-the-integration-and-forcing-function">Setting up the Integration and Forcing Function</a></li>
<li class="toctree-l4"><a class="reference internal" href="#running-the-integration-to-generate-synthetic-test-data">Running the Integration to Generate Synthetic Test Data</a></li>
<li class="toctree-l4"><a class="reference internal" href="#exploring-time-data-objects">Exploring Time Data Objects</a></li>
<li class="toctree-l4"><a class="reference internal" href="#identifying-bad-geometry-with-rigid-body-checkouts-in-sdynpy">Identifying Bad Geometry with Rigid Body Checkouts in SDynPy</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#running-a-virtual-experiment-modal-testing">Running a Virtual Experiment: Modal Testing</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fitting-modes-using-polymax">Fitting Modes using PolyMax</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#running-polymax">Running PolyMax</a></li>
<li class="toctree-l4"><a class="reference internal" href="#comparing-test-and-finite-element-modes">Comparing Test and Finite Element Modes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#serep-expansion">SEREP Expansion</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="rattlesnake_demonstration.html">Rattlesnake Demonstration</a></li>
<li class="toctree-l2"><a class="reference internal" href="transient_fem_analysis.html">Analysis of Transient Finite Element Results</a></li>
<li class="toctree-l2"><a class="reference internal" href="model_reduction/model_reduction.html">Model Reduction</a></li>
<li class="toctree-l2"><a class="reference internal" href="craig_bampton_substructuring.html">Substructuring using Craig-Bampton Superelements from Sierra/SD</a></li>
<li class="toctree-l2"><a class="reference internal" href="transmission_simulator.html">Substructuring using the Transmission Simulator Method</a></li>
<li class="toctree-l2"><a class="reference internal" href="mimo_random_vibration_control.html">MIMO Random Vibration</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../modal_tutorials.html">Modal Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../modules.html">SDynPy Programming Interface</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">SDynPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../examples.html">SDynpy Examples</a></li>
      <li class="breadcrumb-item active">Airplane Modal Test</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/example_problems/airplane_modal_test.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="airplane-modal-test">
<h1><a class="toc-backref" href="#id1">Airplane Modal Test</a><a class="headerlink" href="#airplane-modal-test" title="Permalink to this heading"></a></h1>
<p>This page contains an example demonstrating some usages of SDynPy.  In this
analysis, we will walk through the entirety of the typical analysis/test/analysis
workflow.  We will:</p>
<ol class="arabic simple">
<li><p>Load in the finite element model and use it to select instrumentation
locations.</p></li>
<li><p>Simulate a modal test on the test article to collect time data</p></li>
<li><p>Compute FRFs from the excitation response</p></li>
<li><p>Fit modes to the frf data</p></li>
<li><p>Compare modal fits to finite element model</p></li>
<li><p>Perform finite element expansion using SEREP</p></li>
<li><p>Create quicklook reports for the test</p></li>
</ol>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#airplane-modal-test" id="id1">Airplane Modal Test</a></p>
<ul>
<li><p><a class="reference internal" href="#imports" id="id2">Imports</a></p></li>
<li><p><a class="reference internal" href="#default-plotting-options" id="id3">Default Plotting Options</a></p></li>
<li><p><a class="reference internal" href="#load-the-finite-element-model" id="id4">Load the Finite Element Model</a></p></li>
<li><p><a class="reference internal" href="#convert-finite-element-model-to-sdynpy-objects" id="id5">Convert Finite Element Model to SDynPy Objects</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-a-geometry-from-an-exodus-file" id="id6">Creating a Geometry from an Exodus file</a></p></li>
<li><p><a class="reference internal" href="#exploring-the-geometry-object" id="id7">Exploring the Geometry object</a></p>
<ul>
<li><p><a class="reference internal" href="#nodes" id="id8">Nodes</a></p></li>
<li><p><a class="reference internal" href="#coordinate-systems" id="id9">Coordinate Systems</a></p></li>
<li><p><a class="reference internal" href="#elements" id="id10">Elements</a></p></li>
<li><p><a class="reference internal" href="#tracelines" id="id11">Tracelines</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#visualizing-degrees-of-freedom-on-a-geometry" id="id12">Visualizing Degrees of Freedom on a Geometry</a></p>
<ul>
<li><p><a class="reference internal" href="#coordinates" id="id13">Coordinates</a></p></li>
<li><p><a class="reference internal" href="#plotting-coordinates" id="id14">Plotting Coordinates</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#creating-shapes-from-an-exodus-file" id="id15">Creating Shapes from an Exodus File</a></p>
<ul>
<li><p><a class="reference internal" href="#shapes" id="id16">Shapes</a></p></li>
<li><p><a class="reference internal" href="#correcting-negative-frequencies-and-array-views-versus-copies" id="id17">Correcting Negative Frequencies and Array Views versus Copies</a></p></li>
<li><p><a class="reference internal" href="#transforming-shape-coordinate-systems" id="id18">Transforming Shape Coordinate Systems</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#optimizing-instrumentation-for-test" id="id19">Optimizing Instrumentation for Test</a></p></li>
<li><p><a class="reference internal" href="#creating-a-test-geometry" id="id20">Creating a Test Geometry</a></p>
<ul>
<li><p><a class="reference internal" href="#oops-an-instrumentation-error" id="id21">OOPS! An Instrumentation Error!</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#running-a-virtual-experiment-rigid-body-checkouts" id="id22">Running a Virtual Experiment: Rigid Body Checkouts</a></p>
<ul>
<li><p><a class="reference internal" href="#creating-a-system-object-to-integrate" id="id23">Creating a System Object to Integrate</a></p>
<ul>
<li><p><a class="reference internal" href="#exploring-the-system-object" id="id24">Exploring the System Object</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#setting-up-the-integration-and-forcing-function" id="id25">Setting up the Integration and Forcing Function</a></p></li>
<li><p><a class="reference internal" href="#running-the-integration-to-generate-synthetic-test-data" id="id26">Running the Integration to Generate Synthetic Test Data</a></p></li>
<li><p><a class="reference internal" href="#exploring-time-data-objects" id="id27">Exploring Time Data Objects</a></p></li>
<li><p><a class="reference internal" href="#identifying-bad-geometry-with-rigid-body-checkouts-in-sdynpy" id="id28">Identifying Bad Geometry with Rigid Body Checkouts in SDynPy</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#running-a-virtual-experiment-modal-testing" id="id29">Running a Virtual Experiment: Modal Testing</a></p></li>
<li><p><a class="reference internal" href="#fitting-modes-using-polymax" id="id30">Fitting Modes using PolyMax</a></p>
<ul>
<li><p><a class="reference internal" href="#running-polymax" id="id31">Running PolyMax</a></p></li>
<li><p><a class="reference internal" href="#comparing-test-and-finite-element-modes" id="id32">Comparing Test and Finite Element Modes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#serep-expansion" id="id33">SEREP Expansion</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="imports">
<h2><a class="toc-backref" href="#id2">Imports</a><a class="headerlink" href="#imports" title="Permalink to this heading"></a></h2>
<p>For this project, we will import the following modules, including the SDynPy
module.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span> <span class="c1"># Used for numeric calculations</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span> <span class="c1"># For 2d plotting</span>
<span class="kn">import</span> <span class="nn">sdynpy</span> <span class="k">as</span> <span class="nn">sdpy</span> <span class="c1"># Used for structural dynamics features</span>

<span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="s1">&#39;all&#39;</span><span class="p">)</span> <span class="c1"># close all plots</span>
</pre></div>
</div>
</section>
<section id="default-plotting-options">
<h2><a class="toc-backref" href="#id3">Default Plotting Options</a><a class="headerlink" href="#default-plotting-options" title="Permalink to this heading"></a></h2>
<p>Since we will be plotting a lot of shapes, we will set up some options to use
for all geometry plots.
See the documentation for
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot" title="sdynpy.core.sdynpy_geometry.Geometry.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Geometry.plot</span></code></a>
for these options.  We will create a dictionary of these options so they can
be passed into the various plotting functions using the <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> syntax,
or into the various plotting functions that accept a <code class="docutils literal notranslate"><span class="pre">plot_kwargs</span></code> argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plot_options</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;node_size&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">,</span><span class="s1">&#39;line_width&#39;</span><span class="p">:</span><span class="mi">1</span><span class="p">,</span><span class="s1">&#39;show_edges&#39;</span><span class="p">:</span><span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;view_up&#39;</span><span class="p">:[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">]}</span>
</pre></div>
</div>
</section>
<section id="load-the-finite-element-model">
<h2><a class="toc-backref" href="#id4">Load the Finite Element Model</a><a class="headerlink" href="#load-the-finite-element-model" title="Permalink to this heading"></a></h2>
<p>For complex modal tests, it can be non-trival to select a good set of sensors.
Additionally, for test articles with internal geometry, sensor locations may
not be accessible once the unit is built up.  Therefore, selecting a good
initial sensor set can be crucial to the success of a given test.  For this
reason, many tests begin by using a finite element model to select a set of
degrees of freedom.  We will follow this path in this example.</p>
<p>Many analyses performed at Sandia National Laboratories use the
<a class="reference external" href="https://www.osti.gov/servlets/purl/10102115">Exodus</a> file format to store
output data.  We can load in an Exodus file into SDynPy using the
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_exodus.Exodus.html#sdynpy.fem.sdynpy_exodus.Exodus" title="sdynpy.fem.sdynpy_exodus.Exodus"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.Exodus</span></code></a> class.  Additionally,
we can reduce the size of the finite element model by reducing it to just the
outer surfaces using
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_exodus.Exodus.html#sdynpy.fem.sdynpy_exodus.Exodus.reduce_to_surfaces" title="sdynpy.fem.sdynpy_exodus.Exodus.reduce_to_surfaces"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Exodus.reduce_to_surfaces</span></code></a>,
which returns a
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_exodus.ExodusInMemory.html#sdynpy.fem.sdynpy_exodus.ExodusInMemory" title="sdynpy.fem.sdynpy_exodus.ExodusInMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.ExodusInMemory</span></code></a>
object.  This is a resonable step to take, as we will not be able to put any
sensors on the interior of material volumes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the filename of our finite element model</span>
<span class="n">filename</span> <span class="o">=</span> <span class="s1">&#39;airplane-out.exo&#39;</span>

<span class="c1"># Load the finite element model and reduce it to just exterior surfaces</span>
<span class="n">exo</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">Exodus</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
<span class="n">fexo</span> <span class="o">=</span> <span class="n">exo</span><span class="o">.</span><span class="n">reduce_to_surfaces</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="convert-finite-element-model-to-sdynpy-objects">
<h2><a class="toc-backref" href="#id5">Convert Finite Element Model to SDynPy Objects</a><a class="headerlink" href="#convert-finite-element-model-to-sdynpy-objects" title="Permalink to this heading"></a></h2>
<p>At this point, we would like to convert our finite element model into SDynPy
objects to make it easier to work with.  We will create both a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> as well as
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">Shapes</span></code></a>.</p>
<section id="creating-a-geometry-from-an-exodus-file">
<h3><a class="toc-backref" href="#id6">Creating a Geometry from an Exodus file</a><a class="headerlink" href="#creating-a-geometry-from-an-exodus-file" title="Permalink to this heading"></a></h3>
<p>Our goal is to create a test geometry.  We will note that, while finite element
models are often defined exclusively in a single, global coordinate system,
we often cannot place sensors in the global coordinate system if, for example,
there are surfaces oblique to the principal directions of the part.  We often
place sensors directly on the surfaces, so the sensor coordinate system will
generally be oriented such that it is aligned with the local surface normal of
the location that the sensor is placed.</p>
<p>We will therefore create local coordinate systems to use for sensor selection.
To do this, we use the <code class="docutils literal notranslate"><span class="pre">local=True</span></code> argument in the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.from_exodus.html#sdynpy.core.sdynpy_geometry.from_exodus" title="sdynpy.core.sdynpy_geometry.from_exodus"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.geometry.from_exodus</span></code></a>
function.  We will specify a preferred direction in the nose-wise direction
<code class="docutils literal notranslate"><span class="pre">preferred_local_orientation=[0,0,1]</span></code>.
The secondary preferred direction will be “up”
<code class="docutils literal notranslate"><span class="pre">secondary_preferred_local_orientation=[0,1,0]</span></code>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">from_exodus</span><span class="p">(</span><span class="n">fexo</span><span class="p">,</span><span class="n">local</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                     <span class="n">preferred_local_orientation</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                     <span class="n">secondary_preferred_local_orientation</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="exploring-the-geometry-object">
<h3><a class="toc-backref" href="#id7">Exploring the Geometry object</a><a class="headerlink" href="#exploring-the-geometry-object" title="Permalink to this heading"></a></h3>
<p>Take a moment here to explore the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object.  If we
simply type <code class="docutils literal notranslate"><span class="pre">geometry</span></code> into the IPython console after running the previous
command, we get out the representation of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object (truncated
here to save space)</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [1]: geometry</span>
<span class="go">Out[1]:</span>
<span class="go">Node</span>
<span class="go">   Index,     ID,        X,        Y,        Z, DefCS, DisCS</span>
<span class="go">    (0,),      1,    0.496,   -0.062,   -7.000, 20497,     1</span>
<span class="go">    (1,),      2,    0.500,    0.000,   -7.000, 20497,     2</span>
<span class="go">    (2,),      3,   -0.496,   -0.062,   -7.000, 20497,     3</span>
<span class="go">    (3,),      4,    0.429,   -0.256,   -7.000, 20497,     4</span>
<span class="go">    (4,),      5,    0.290,   -0.407,   -7.000, 20497,     5</span>
<span class="go">    (5,),      6,    0.103,   -0.489,   -7.000, 20497,     6</span>
<span class="go">    (6,),      7,   -0.103,   -0.489,   -7.000, 20497,     7</span>
<span class="go">    (7,),      8,   -0.290,   -0.407,   -7.000, 20497,     8</span>
<span class="go">    (8,),      9,   -0.429,   -0.256,   -7.000, 20497,     9</span>
<span class="go">    (9,),     10,   -0.496,    0.063,   -7.000, 20497,    10</span>
<span class="go">  .</span>
<span class="go">  .</span>
<span class="go">  .</span>

<span class="go">Coordinate_system</span>
<span class="go">   Index,     ID,                 Name, Color,       Type</span>
<span class="go">    (0,),      1,          Node 1 Disp,     1,  Cartesian</span>
<span class="go">    (1,),      2,          Node 2 Disp,     1,  Cartesian</span>
<span class="go">    (2,),      3,          Node 3 Disp,     1,  Cartesian</span>
<span class="go">    (3,),      4,          Node 4 Disp,     1,  Cartesian</span>
<span class="go">    (4,),      5,          Node 5 Disp,     1,  Cartesian</span>
<span class="go">    (5,),      6,          Node 6 Disp,     1,  Cartesian</span>
<span class="go">    (6,),      7,          Node 7 Disp,     1,  Cartesian</span>
<span class="go">    (7,),      8,          Node 8 Disp,     1,  Cartesian</span>
<span class="go">    (8,),      9,          Node 9 Disp,     1,  Cartesian</span>
<span class="go">    (9,),     10,         Node 10 Disp,     1,  Cartesian</span>
<span class="go">  .</span>
<span class="go">  .</span>
<span class="go">  .</span>

<span class="go">Traceline</span>
<span class="go">   Index,     ID,          Description, Color, # Nodes</span>
<span class="go">----------- Empty -------------</span>

<span class="go">Element</span>
<span class="go">   Index,     ID, Type, Color, # Nodes</span>
<span class="go">    (0,),      1,   64,     1,       4</span>
<span class="go">    (1,),      2,   64,     1,       4</span>
<span class="go">    (2,),      3,   64,     1,       4</span>
<span class="go">    (3,),      4,   64,     1,       4</span>
<span class="go">    (4,),      5,   64,     1,       4</span>
<span class="go">    (5,),      6,   64,     1,       4</span>
<span class="go">    (6,),      7,   64,     1,       4</span>
<span class="go">    (7,),      8,   64,     1,       4</span>
<span class="go">    (8,),      9,   64,     1,       4</span>
<span class="go">    (9,),     10,   64,     1,       4</span>
<span class="go">  .</span>
<span class="go">  .</span>
<span class="go">  .</span>
</pre></div>
</div>
<p>We see there are a large number of
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">nodes</span></code></a>,
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">coordinate</span> <span class="pre">systems</span></code></a>,
and <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">elements</span></code></a>, but no
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracelines</span></code></a>.
We can access these data by accessing the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> attributes:
<code class="docutils literal notranslate"><span class="pre">geometry.node</span></code>, <code class="docutils literal notranslate"><span class="pre">geometry.coordinate_system</span></code>, <code class="docutils literal notranslate"><span class="pre">geometry.element</span></code>, and
<code class="docutils literal notranslate"><span class="pre">geometry.traceline</span></code>.</p>
<section id="nodes">
<h4><a class="toc-backref" href="#id8">Nodes</a><a class="headerlink" href="#nodes" title="Permalink to this heading"></a></h4>
<p>We will start with the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a>
object revealed by <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code>.  The
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> class is a subclass of
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>, which is
itself a subclass of NumPy’s
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html">ndarray</a>.
All subclasses of <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>
can therefore take advantage of NumPy functions such as <code class="docutils literal notranslate"><span class="pre">intersect1d</span></code>,
<code class="docutils literal notranslate"><span class="pre">unique</span></code>, or <code class="docutils literal notranslate"><span class="pre">concatenate</span></code> and also handle indexing and broadcasting
identically to the NumPy <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<p>Subclasses of <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>
store their data internally as a structured array variant of the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.
However, as an alternative to accessing the field data using the syntax
<code class="docutils literal notranslate"><span class="pre">array['fieldname']</span></code>,
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a> allows accessing
the fields as if they were attributes using the syntax <code class="docutils literal notranslate"><span class="pre">array.fieldname</span></code>.
Many integrated development environments will not recognize these attributes
so all <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a> subclasses
have a <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray.fields" title="sdynpy.core.sdynpy_array.SdynpyArray.fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">fields</span></code></a>
attribute that lists the fields stored in the array that can be accessed.</p>
<p>Returning to the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">geometry.node</span></code></a>, we can
identify the fields in the object using the command</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [2]: geometry.node.fields</span>
<span class="go">Out[2]: (&#39;id&#39;, &#39;coordinate&#39;, &#39;color&#39;, &#39;def_cs&#39;, &#39;disp_cs&#39;)</span>
</pre></div>
</div>
<p>Here we see the five fields of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> object.  We can
obtain even more information about the shape and type of each of these fields
using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> attribute, which is inherited from NumPy’s <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [3]: geometry.node.dtype</span>
<span class="go">Out[3]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;coordinate&#39;, &#39;&lt;f8&#39;, (3,)), (&#39;color&#39;, &#39;&lt;u2&#39;), (&#39;def_cs&#39;, &#39;&lt;u8&#39;), (&#39;disp_cs&#39;, &#39;&lt;u8&#39;)])</span>
</pre></div>
</div>
<p>Here we see that the <code class="docutils literal notranslate"><span class="pre">geometry.node.id</span></code> array, which contains the node ID
number, is a 8-byte (64-bit) unsigned integer.  The <code class="docutils literal notranslate"><span class="pre">geometry.node.disp_cs</span></code>
and <code class="docutils literal notranslate"><span class="pre">geometry.node.def_cs</span></code> arrays, which contain references to the
coordinate system in which the node is defined and in which the node
displaces, respectively, are also this data type.  The <code class="docutils literal notranslate"><span class="pre">geometry.node.color</span></code>
array, while still an unsigned integer, is only 2 bytes, or 16 bits.  Finally,
the <code class="docutils literal notranslate"><span class="pre">geometry.node.coordinate</span></code>, which contains the 3D position of the node
as defined in the <code class="docutils literal notranslate"><span class="pre">geometry.node.def_cs</span></code>, consists 8-byte (64-bit)
floating-point data, and also has a shape of <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>, which signifies there
are three values of the coordinate for each entry in the <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code>
array.  These extra dimensions of the field arrays are appended at the end of
dimension of the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>
subclass.  For example, if we compare the shape of the <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code> array
to the <code class="docutils literal notranslate"><span class="pre">geometry.node.coordinate</span></code> array, we will see that the shapes are
identical except for the appending of the length-3 extra dimension on the
latter array.  Here the <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute is also an attribute inherited
from NumPy’s <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [4]: geometry.node.shape</span>
<span class="go">Out[4]: (12686,)</span>

<span class="go">In [5]: geometry.node.coordinate.shape</span>
<span class="go">Out[5]: (12686, 3)</span>
</pre></div>
</div>
<p>We see that the shape of our <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code> array is 12686, meaning the
geometry we are examining has that many nodes.  We then see that the shape of
our <code class="docutils literal notranslate"><span class="pre">geometry.node.coordinate</span></code> array is 12686 x 3, showing that there are
three coordinate values for each node.</p>
</section>
<section id="coordinate-systems">
<h4><a class="toc-backref" href="#id9">Coordinate Systems</a><a class="headerlink" href="#coordinate-systems" title="Permalink to this heading"></a></h4>
<p>Coordinate systems in the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object are stored
in a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
object that can be accessed by <code class="docutils literal notranslate"><span class="pre">geometry.coordinate_system</span></code>.  We will again
explore the fields of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [6]: geometry.coordinate_system.dtype</span>
<span class="go">Out[6]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;name&#39;, &#39;&lt;U40&#39;), (&#39;color&#39;, &#39;&lt;u2&#39;), (&#39;cs_type&#39;, &#39;&lt;u2&#39;), (&#39;matrix&#39;, &#39;&lt;f8&#39;, (4, 3))])</span>
</pre></div>
</div>
<p>We now see some new types of fields.  We still have <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code>,
which are consistent with the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> object we
previously explored.  We now have another integer field <code class="docutils literal notranslate"><span class="pre">cs_type</span></code> which
stores the type of coordinate system (0 - cartesian, 1 - cylindrical,
2 - spherical) in a 16-bit unsigned integer field.  We also have a <code class="docutils literal notranslate"><span class="pre">name</span></code>
field, which stores a name of the coordinate system in a string of less than
40 characters.  Finally, there is the coordinate system’s transformation matrix,
stored in the <code class="docutils literal notranslate"><span class="pre">matrix</span></code> field, which is stored in a 4 x 3 array of 64-bit
floating point numbers.  Again, recall the shape of the fields are appended to
the shape of the base object, so comparing the shape of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
to the shape of its <code class="docutils literal notranslate"><span class="pre">matrix</span></code> field, we will see that the latter has 2 extra
dimensions of length 4 and 3.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [7]: geometry.coordinate_system.shape</span>
<span class="go">Out[7]: (12687,)</span>

<span class="go">In [8]: geometry.coordinate_system.matrix.shape</span>
<span class="go">Out[8]: (12687, 4, 3)</span>
</pre></div>
</div>
</section>
<section id="elements">
<h4><a class="toc-backref" href="#id10">Elements</a><a class="headerlink" href="#elements" title="Permalink to this heading"></a></h4>
<p>Elements in the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> are stored in an
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementArray</span></code></a> object, which
can be accessed using the <code class="docutils literal notranslate"><span class="pre">geometry.element</span></code> attribute.  The fields of this
object are</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [9]: geometry.element.dtype</span>
<span class="go">Out[9]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;type&#39;, &#39;u1&#39;), (&#39;color&#39;, &#39;&lt;u2&#39;), (&#39;connectivity&#39;, &#39;O&#39;)])</span>
</pre></div>
</div>
<p>Like <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> and
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
objects, the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementArray</span></code></a>
object also has <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code> fields.  Each element also has a <code class="docutils literal notranslate"><span class="pre">type</span></code>
field, which is an 8-bit unsigned integer representing the element type as
defined by the universal file format dataset 2412.  Finally, the element
<code class="docutils literal notranslate"><span class="pre">connectivity</span></code> field is stored as an object array, where each entry in the
element array is a NumPy <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> with length equal to the number of nodes
in the element.  This construction is necessary as each element might have a
different number of nodes, so a single array of fixed size is not possible.</p>
</section>
<section id="tracelines">
<h4><a class="toc-backref" href="#id11">Tracelines</a><a class="headerlink" href="#tracelines" title="Permalink to this heading"></a></h4>
<p>The final visualization tool in the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object is the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a>,
which represents a line connecting nodes in the geometry.  The fields of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a> object
are</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [10]: geometry.traceline.dtype</span>
<span class="go">Out[10]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;color&#39;, &#39;&lt;u2&#39;), (&#39;description&#39;, &#39;&lt;U40&#39;), (&#39;connectivity&#39;, &#39;O&#39;)])</span>
</pre></div>
</div>
<p>Similarly to the other geometry objects,
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a> objects
have <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code>, and like to the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementArray</span></code></a> object, it
has a <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> array that specifies the node IDs to connect with the
line.  The <code class="docutils literal notranslate"><span class="pre">description</span></code> field stores a name or description of each item in
the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a> as
a string with less than 40 characters.</p>
</section>
</section>
<section id="visualizing-degrees-of-freedom-on-a-geometry">
<h3><a class="toc-backref" href="#id12">Visualizing Degrees of Freedom on a Geometry</a><a class="headerlink" href="#visualizing-degrees-of-freedom-on-a-geometry" title="Permalink to this heading"></a></h3>
<p>Now that we have an understanding of our
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object, we would
like to visualize it.  In particular, we would like to visualize the local
coordinate systems in the geometry to verify that they were created correctly.</p>
<p>To do this, we will create a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object, which contains a set of nodes and directions.  Since we would like to
generate a coordinate system triad for each node, we will use the helper
function
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray.from_nodelist" title="sdynpy.core.sdynpy_coordinate.CoordinateArray.from_nodelist"><code class="xref py py-func docutils literal notranslate"><span class="pre">from_nodelist</span></code></a>
which creates degrees of freedom for all directions for each node passed in
as an argument.  Here we will use the entire list of node ID numbers from our
geometry.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">from_nodelist</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<section id="coordinates">
<h4><a class="toc-backref" href="#id13">Coordinates</a><a class="headerlink" href="#coordinates" title="Permalink to this heading"></a></h4>
<p>Here again is a good place to explore what makes up a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object, which we have just assigned to the variable <code class="docutils literal notranslate"><span class="pre">coordinates</span></code>.  We can
examine the data type of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
to see that it contains fields for a 64-bit unsigned integer as the <code class="docutils literal notranslate"><span class="pre">node</span></code>
field and an 8-bit signed integer for the <code class="docutils literal notranslate"><span class="pre">direction</span></code> field.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [11]: coordinates.dtype</span>
<span class="go">Out[11]: dtype([(&#39;node&#39;, &#39;&lt;u8&#39;), (&#39;direction&#39;, &#39;i1&#39;)])</span>
</pre></div>
</div>
<p><a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects store the direction as an integer where rotations are encoded:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Direction</p></th>
<th class="head"><p>Integer Encoding</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>X+</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>Y+</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>Z+</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>RX+</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>RY+</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>RZ+</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>X-</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>Y-</p></td>
<td><p>-2</p></td>
</tr>
<tr class="row-even"><td><p>Z-</p></td>
<td><p>-3</p></td>
</tr>
<tr class="row-odd"><td><p>RX-</p></td>
<td><p>-4</p></td>
</tr>
<tr class="row-even"><td><p>RY-</p></td>
<td><p>-5</p></td>
</tr>
<tr class="row-odd"><td><p>RZ-</p></td>
<td><p>-6</p></td>
</tr>
<tr class="row-even"><td><p>None</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>When we want to read
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects, the integer directions are typically transformed into the more
readable direction strings shown in the first column of the above table.  For
example, if we type <code class="docutils literal notranslate"><span class="pre">coordinates</span></code> into the console, the representation of the
object displays the string array version of the coordinates.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [12]: coordinates</span>
<span class="go">Out[12]:</span>
<span class="go">array([&#39;1X+&#39;, &#39;1Y+&#39;, &#39;1Z+&#39;, ..., &#39;20496X+&#39;, &#39;20496Y+&#39;, &#39;20496Z+&#39;],</span>
<span class="go">      dtype=&#39;&lt;U7&#39;)</span>
</pre></div>
</div>
<p>From the above, we can see that the <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> variable we just created
contains a degree of freedom for each of the positive X, Y, Z directions at
each node.</p>
<p>Many SDynPy objects allow indexing with a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object to automatically handle the bookkeeping aspect of selecting the right
data for each coordinate.</p>
</section>
<section id="plotting-coordinates">
<h4><a class="toc-backref" href="#id14">Plotting Coordinates</a><a class="headerlink" href="#plotting-coordinates" title="Permalink to this heading"></a></h4>
<p>At this point, we would like to plot our coordinates on top of our geometry.
For this we use the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_coordinate" title="sdynpy.core.sdynpy_geometry.Geometry.plot_coordinate"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_coordinate</span></code></a>
method of the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plotter</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                                   <span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that due to the density of the mesh, we had to make the <code class="docutils literal notranslate"><span class="pre">arrow_scale</span></code>
much smaller than the default.  Here also note that we passed the previously
defined <code class="docutils literal notranslate"><span class="pre">plot_options</span></code> into the <code class="docutils literal notranslate"><span class="pre">plot_kwargs</span></code> argument.  This method should
produce a graphic similar to the one shown below.</p>
<a class="reference internal image-reference" href="../_images/airplane_coordinate_systems.gif"><img alt="Airplane geometry with coordinate systems shown." src="../_images/airplane_coordinate_systems.gif" style="width: 600px;" /></a>
<p>If we zoom into the coordinate systems on the figure, we see that the Z+ (blue)
direction is always oriented perpendicular to the surface, and the X+ (red)
direction is always oriented towards the direction specified by the
<code class="docutils literal notranslate"><span class="pre">preferred_local_orientation</span></code> argument to the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.from_exodus.html#sdynpy.core.sdynpy_geometry.from_exodus" title="sdynpy.core.sdynpy_geometry.from_exodus"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.geometry.from_exodus</span></code></a>
function, which was the global Z+ direction.</p>
<a class="reference internal image-reference" href="../_images/airplane_coordinate_system_closeup.png"><img alt="Airplane geometry with coordinate systems shown close up." src="../_images/airplane_coordinate_system_closeup.png" style="width: 600px;" /></a>
</section>
</section>
<section id="creating-shapes-from-an-exodus-file">
<h3><a class="toc-backref" href="#id15">Creating Shapes from an Exodus File</a><a class="headerlink" href="#creating-shapes-from-an-exodus-file" title="Permalink to this heading"></a></h3>
<p>We just finished extracting geometry with local coordinate systems.  We will
now extract shapes from the
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_exodus.ExodusInMemory.html#sdynpy.fem.sdynpy_exodus.ExodusInMemory" title="sdynpy.fem.sdynpy_exodus.ExodusInMemory"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.ExodusInMemory</span></code></a>
object.  To do this, we will use the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.from_exodus.html#sdynpy.core.sdynpy_shape.from_exodus" title="sdynpy.core.sdynpy_shape.from_exodus"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.from_exodus</span></code></a>
function.  Note that shapes gathered from this function will be in the
global coordinate system, so we will assign the variable a name that denotes
that these are global shapes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes_global</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">from_exodus</span><span class="p">(</span><span class="n">fexo</span><span class="p">)</span>
</pre></div>
</div>
<section id="shapes">
<h4><a class="toc-backref" href="#id16">Shapes</a><a class="headerlink" href="#shapes" title="Permalink to this heading"></a></h4>
<p>At this point, it is useful to explore briefly the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object in the
IPython console.  The data type of the object is:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [13]: shapes_global.dtype</span>
<span class="go">Out[13]: dtype([(&#39;frequency&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                (&#39;damping&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                (&#39;coordinate&#39;, [(&#39;node&#39;, &#39;&lt;u8&#39;),</span>
<span class="go">                                (&#39;direction&#39;, &#39;i1&#39;)], (38058,)),</span>
<span class="go">                (&#39;shape_matrix&#39;, &#39;&lt;f8&#39;, (38058,)),</span>
<span class="go">                (&#39;modal_mass&#39;, &#39;&lt;f8&#39;), (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;), (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;), (&#39;comment5&#39;, &#39;&lt;U80&#39;)])</span>
</pre></div>
</div>
<p>The data type of
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> objects can change
depending on what type of shape and how many degrees of freedom are in the
shape.  <code class="docutils literal notranslate"><span class="pre">frequency</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> fields are stored as 64-bit floating
point numbers with one value per entry in the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>.  <code class="docutils literal notranslate"><span class="pre">modal_mass</span></code>
is also stored in the present
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>, but if the shape
is complex, then the modal mass might also be complex.  The <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code>
field holds the underlying shape data.  It has one entry for every degree of
freedom in the shape, and is represented by a floating point number for
normal modes or a complex number for complex modes.  Similarly, the
<code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field identifies which degree of freedom belongs to which entry
in the <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field.  The <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field stores data as
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects, and thus has the same data type as
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>.
Finally, there are five fields available for comments, which store string data
up to 80 characters which can be used to store any data the user feels is
relevant to the analysis.</p>
<p>One thing to note is that the <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field, due to the dimension of
the field being appended at the end of the array, will be transposed from the
typical representation of a mode shape matrix (degrees of freedom as rows and
mode indices as columns). The <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field will instead have the
shape of the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>
object itself as its first dimensions, and then the size of the <code class="docutils literal notranslate"><span class="pre">coordinate</span></code>
field as its last dimension.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [14]: shapes_global.shape</span>
<span class="go">Out[14]: (200,)</span>

<span class="go">In [15]: shapes_global.shape_matrix.shape</span>
<span class="go">Out[15]: (200, 38058)</span>
</pre></div>
</div>
</section>
<section id="correcting-negative-frequencies-and-array-views-versus-copies">
<h4><a class="toc-backref" href="#id17">Correcting Negative Frequencies and Array Views versus Copies</a><a class="headerlink" href="#correcting-negative-frequencies-and-array-views-versus-copies" title="Permalink to this heading"></a></h4>
<p>One thing to note is that sometimes finite element codes that solve for zero
frequency modes can have slight errors that result in small negative natural
frequencies.  These can, however, cause issues due to stiffness instabilities
if, for example, the system is integrated over time.  It is easy to set all of
these negative natural frequencies to positive natural frequencies.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes_global</span><span class="o">.</span><span class="n">frequency</span><span class="p">[</span><span class="n">shapes_global</span><span class="o">.</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>Note carefully here the order of operations in the above statement.  We have a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object containing
our shape data.  We then access the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field of that
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object and index
that array to select only those frequencies that are less than zero and set
them to zero.  Note the subtle difference to the following line of code.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes_global</span><span class="p">[</span><span class="n">shapes_global</span><span class="o">.</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>In the above line of code, we first index our
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object to access
only the shapes with frequency less than zero, then access the <code class="docutils literal notranslate"><span class="pre">frequency</span></code>
field of just those shapes and assign to zero.  This seems like it should be
the identical operation, correct?  Indeed, both operations return the same
negative frequency values.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [16]: shapes_global.frequency[shapes_global.frequency &lt; 0]</span>
<span class="go">Out[16]:</span>
<span class="go">array([-6.79983277e-05, -6.35834268e-05, -4.75579236e-05, -2.66030128e-05,</span>
<span class="go">       -2.39180665e-05])</span>

<span class="go">In [17]: shapes_global[shapes_global.frequency &lt; 0].frequency</span>
<span class="go">Out[17]:</span>
<span class="go">array([-6.79983277e-05, -6.35834268e-05, -4.75579236e-05, -2.66030128e-05,</span>
<span class="go">       -2.39180665e-05])</span>
</pre></div>
</div>
<p>Experienced users of NumPy should readily identify the subtle difference
between the above two operations, however.  In the second, the <code class="docutils literal notranslate"><span class="pre">shapes_global</span></code>
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> is indexed by a
logical array (a NumPy <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> consisting of True and False, True where
the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field is less than 0).  This will trigger NumPy’s advanced
indexing schemes, which <em>always return a copy of rather than a view into</em> the
underlying data.  Therefore, in the second case, what we are looking at is the
<code class="docutils literal notranslate"><span class="pre">frequency</span></code> field of a <em>copy</em> of our <code class="docutils literal notranslate"><span class="pre">shapes_global</span></code> variable rather than
the raw data.  Similarly, assigning directly to this copy will not change the
data of the original <code class="docutils literal notranslate"><span class="pre">shapes_global</span></code> variable, as can be demonstrated in the
IPython console.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [18]: shapes_global[shapes_global.frequency &lt; 0].frequency</span>
<span class="go">Out[18]:</span>
<span class="go">array([-6.79983277e-05, -6.35834268e-05, -4.75579236e-05, -2.66030128e-05,</span>
<span class="go">       -2.39180665e-05])</span>

<span class="go">In [19]: shapes_global[shapes_global.frequency &lt; 0].frequency = 0</span>

<span class="go">In [20]: shapes_global[shapes_global.frequency &lt; 0].frequency</span>
<span class="go">Out[20]:</span>
<span class="go">array([-6.79983277e-05, -6.35834268e-05, -4.75579236e-05, -2.66030128e-05,</span>
<span class="go">       -2.39180665e-05])</span>
</pre></div>
</div>
<p>We start by checking that there are negative frequencies, then we assign
those frequencies to zero, then check again if there are negative frequencies.
Indeed the negative frequencies still exist!  Again to reiterate, this is
because we have assigned the zero frequencies to a copy of the original object.</p>
<p>The correct way to assign to field data is to do all indexing to the final
target array, which in this case is the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field.  By doing it this
way, the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field that we are referencing is still the same
<code class="docutils literal notranslate"><span class="pre">frequency</span></code> field from the original <code class="docutils literal notranslate"><span class="pre">shapes_global</span></code> array, so assigning
to this array will modify the original <code class="docutils literal notranslate"><span class="pre">shapes_global</span></code> array’s data.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [21]: shapes_global.frequency[shapes_global.frequency &lt; 0]</span>
<span class="go">Out[21]:</span>
<span class="go">array([-6.79983277e-05, -6.35834268e-05, -4.75579236e-05, -2.66030128e-05,</span>
<span class="go">       -2.39180665e-05])</span>

<span class="go">In [22]: shapes_global.frequency[shapes_global.frequency &lt; 0] = 0</span>

<span class="go">In [23]: shapes_global.frequency[shapes_global.frequency &lt; 0]</span>
<span class="go">Out[23]: array([], dtype=float64)</span>
</pre></div>
</div>
<p>Here we see that if we do the indexing the correct way, after assigning the
<code class="docutils literal notranslate"><span class="pre">frequency</span></code> field data to zero, there are no remaining negative frequencies
(an empty array is returned).</p>
<p>If the reader does not understand these concepts, they are encouraged to read
and understand the NumPy
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">documentation on indexing</a>,
otherwise misapplying these nuanced concepts can introduce bugs into analyses
performed using SDynPy.</p>
</section>
<section id="transforming-shape-coordinate-systems">
<h4><a class="toc-backref" href="#id18">Transforming Shape Coordinate Systems</a><a class="headerlink" href="#transforming-shape-coordinate-systems" title="Permalink to this heading"></a></h4>
<p>As mentioned above, the shapes that come from the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.from_exodus.html#sdynpy.core.sdynpy_shape.from_exodus" title="sdynpy.core.sdynpy_shape.from_exodus"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.from_exodus</span></code></a>
function are defined in the global cordinate system.
We can see that if we plot the shapes on the <code class="docutils literal notranslate"><span class="pre">geometry</span></code> we loaded previously
using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_shape" title="sdynpy.core.sdynpy_geometry.Geometry.plot_shape"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_shape</span></code></a> method of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object, the shapes
do not look right, due to plotting shapes defined using a global coordinate
system onto a geometry defined using local coordinate systems.
For example, the shape below should be a rigid body mode
of the system, but instead appears to be a torsional mode of the system.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">plotter</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">shapes_global</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_mode_wrong_cs.gif"><img alt="Plotting a global shape on a local geometry results in incorrect motions." src="../_images/airplane_mode_wrong_cs.gif" style="width: 600px;" /></a>
<p>What we need to do is transform the global shapes into the local shapes defined
on the geometry.  We can do this using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.transform_coordinate_system" title="sdynpy.core.sdynpy_shape.ShapeArray.transform_coordinate_system"><code class="xref py py-func docutils literal notranslate"><span class="pre">transform_coordinate_system</span></code></a>
method of the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object.
This method takes two arguments; the first is a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object that defines
the coordinate systems that we are transforming “from” and the second is a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object that defines
the coordinate systems that we are transforming “to”.  We already have the “to”
geometry in the form of the local geometry we loaded from the Exodus file.
We therefore only need to create a global geometry corresponding to the global
coordinate system that our shapes are currently defined in to transform “from”.
This is easily done using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.from_exodus.html#sdynpy.core.sdynpy_geometry.from_exodus" title="sdynpy.core.sdynpy_geometry.from_exodus"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.geometry.from_exodus</span></code></a>
function while not passing in the arguments that specify the local coordinate
systems should be created.  Plotting the same <code class="docutils literal notranslate"><span class="pre">coordinates</span></code>
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a> on
this new geometry will verify that all node coordinate systems are aligned with
the global coordinate system.  We can also plot <code class="docutils literal notranslate"><span class="pre">shapes_global</span></code> with
<code class="docutils literal notranslate"><span class="pre">geometry_global</span></code> to verify that the shapes look right.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the global geometry</span>
<span class="n">geometry_global</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">from_exodus</span><span class="p">(</span><span class="n">fexo</span><span class="p">)</span>

<span class="c1"># Plot the coordinates on the global geometry</span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">geometry_global</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.005</span><span class="p">,</span>
                                          <span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">)</span>

<span class="c1"># Plot global shapes with global geometry</span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">geometry_global</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">shapes_global</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_global_coordinate_system_closeup.png"><img alt="Airplane geometry with global coordinate systems shown close up." src="../_images/airplane_global_coordinate_system_closeup.png" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../_images/airplane_mode_right_cs.gif"><img alt="Plotting a global shape on a global geometry results in correct motions." src="../_images/airplane_mode_right_cs.gif" style="width: 600px;" /></a>
<p>At this point, we have the requirements to transform coordinate systems.
We can now plot the local shapes with the local geometry to verify that the
shapes are indeed correct.  These shapes should look identical to the above
figure even though the underlying data is represented in a different coordinate
system.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Transform shapes to local coordinate systems from global coordinate systems</span>
<span class="n">shapes</span> <span class="o">=</span> <span class="n">shapes_global</span><span class="o">.</span><span class="n">transform_coordinate_system</span><span class="p">(</span><span class="n">geometry_global</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>

<span class="c1"># Plot the local shapes on the local geometry to verify</span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
</section>
</section>
</section>
<section id="optimizing-instrumentation-for-test">
<h2><a class="toc-backref" href="#id19">Optimizing Instrumentation for Test</a><a class="headerlink" href="#optimizing-instrumentation-for-test" title="Permalink to this heading"></a></h2>
<p>The reason we went through all the trouble to create shapes in local
coordinate systems is that these are the coordinate systems in which test
instrumentation is generally placed.  We will now want to downselect a set of
sensors to use in the actual test from a candidate set of instruments.</p>
<p>For this example, we will use the effective independence algorithm implemented in
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_dof.by_effective_independence.html#sdynpy.fem.sdynpy_dof.by_effective_independence" title="sdynpy.fem.sdynpy_dof.by_effective_independence"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.dof.by_effective_independence</span></code></a>.
This function starts with a candidate set of degrees of freedom and iteratively
throws away the degrees of freedom with the smallest contribution to the
effective independence of the system.  Because there are currently a lot of
nodes in our geometry (12,686), it will take a long time to consider each one
of these locations as a potential sensor in a test.  Instead, we will reduce
the candidate set by overlaying a grid of points over the test geometry with
a specified spacing.</p>
<p>We will first compute the maximum, minimum, and range of node positions in the
model to define the grid, and use NumPy’s <code class="docutils literal notranslate"><span class="pre">meshgrid</span></code> function to assemble the
grid.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the maximum and minimum of each component of the node positions (X,Y,Z)</span>
<span class="n">min_coords</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">max_coords</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Compute the size of the model in each direction</span>
<span class="n">range_coords</span> <span class="o">=</span> <span class="n">max_coords</span><span class="o">-</span><span class="n">min_coords</span>

<span class="c1"># Specify the grid spacing that we want to use</span>
<span class="n">grid_spacing</span> <span class="o">=</span> <span class="mf">0.25</span>

<span class="c1"># Compute the number of points along each direction in the grid</span>
<span class="n">num_grids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">range_coords</span><span class="o">/</span><span class="n">grid_spacing</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>

<span class="c1"># Create the grid in each dimension using linspace</span>
<span class="n">grid_arrays</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="nb">min</span><span class="p">,</span><span class="nb">max</span><span class="p">,</span><span class="n">num</span><span class="p">)</span>
               <span class="k">for</span> <span class="nb">min</span><span class="p">,</span><span class="nb">max</span><span class="p">,</span><span class="n">num</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">min_coords</span><span class="p">,</span><span class="n">max_coords</span><span class="p">,</span><span class="n">num_grids</span><span class="p">)]</span>
<span class="c1"># Use meshgrid to assemble the array grid.  Flatten the point dimension and</span>
<span class="c1"># transpose so the array has shape (n_points x 3)</span>
<span class="n">grid_points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">grid_arrays</span><span class="p">,</span><span class="n">indexing</span><span class="o">=</span><span class="s1">&#39;ij&#39;</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>With the grid points defined, we can now select the nodes in the geometry
closest to these grid points by using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray.by_position" title="sdynpy.core.sdynpy_geometry.NodeArray.by_position"><code class="xref py py-func docutils literal notranslate"><span class="pre">by_position</span></code></a> method
of the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> object.
However, there are points on the grid that are not particularly close to any
node in the geometry (e.g. points above the wing at the level of the tail tip)
so we will further reduce the candidate nodes by only keeping those where the
closest node to a grid position is within the specified <code class="docutils literal notranslate"><span class="pre">grid_spacing</span></code>.
The NumPy <code class="docutils literal notranslate"><span class="pre">unique</span></code> function can be used to eliminate repeated nodes if one
node ends up being closest to two grid points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Select nodes that are closest to the points in the grid</span>
<span class="n">candidate_nodes</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">by_position</span><span class="p">(</span><span class="n">grid_points</span><span class="p">)</span>
<span class="c1"># Reduce to only nodes that are within one grid spacing of their requested point</span>
<span class="n">candidate_nodes</span> <span class="o">=</span> <span class="n">candidate_nodes</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">candidate_nodes</span><span class="o">.</span><span class="n">coordinate</span> <span class="o">-</span> <span class="n">grid_points</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">grid_spacing</span><span class="p">]</span>
<span class="c1"># Remove duplicates</span>
<span class="n">candidate_node_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">candidate_nodes</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
</pre></div>
</div>
<p>At this point we need to create the shape matrix that the effective independence
algorithm will use to downselect degrees of freedom.  We will first develop a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
containing the degrees of freedom of the candidate set.  We will use the helper
function <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.coordinate_array.html#sdynpy.core.sdynpy_coordinate.coordinate_array" title="sdynpy.core.sdynpy_coordinate.coordinate_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.coordinate_array</span></code></a>
to create this set of degrees of freedom, using NumPy’s broadcasting
capabilities to fill out the array.
Here the nodes are the candidate node ids, and the directions are
1, 2, 3 corresponding to X+, Y+, Z+.  We pass in a shape
(<code class="docutils literal notranslate"><span class="pre">candidate_node_ids.size</span></code> x 1) array for the nodes and a shape (3) array for the
direction, which will be broadcast to a (<code class="docutils literal notranslate"><span class="pre">candidate_node_ids.size</span></code> x 3) array
output where the rows correspond to the node id and the columns correspond to
each direction.  For more information on broadcasting, see the NumPy
<a class="reference external" href="http://numpy.org/doc/stable/user/basics.broadcasting.html">documentation</a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the candidate degree of freedom set</span>
<span class="n">candidate_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">candidate_node_ids</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>

<span class="c1"># Plot the degrees of freedom to verify they were created correctly</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">candidate_dofs</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">plot_kwargs</span> <span class="o">=</span> <span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_candidate_sensor_locations.png"><img alt="Candidate sensor locations to select nodes" src="../_images/airplane_candidate_sensor_locations.png" style="width: 600px;" /></a>
<p>Now that we have selected our candidate degrees of freedom, we need to select
our target shapes.  Here we will consider the bandwidth of the test plus a bit
more to capture some effects of out-of-band modes.  We are interested in data
up to 200 Hz for this test, so we will consider shapes up to 300 Hz for this
instrumentation selection.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the shape bandwidth</span>
<span class="n">shape_bandwidth</span> <span class="o">=</span> <span class="mi">300</span>

<span class="c1"># Keep only shapes in the target set that have frequency less than the bandwidth</span>
<span class="n">target_shapes</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="n">shapes</span><span class="o">.</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="n">shape_bandwidth</span><span class="p">]</span>
</pre></div>
</div>
<p>Finally, the last definition needed is the number of sensors to keep.  In this
case, we will want to keep 30 triaxial accelerometers.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Define the shape bandwidth</span>
<span class="n">sensors_to_keep</span> <span class="o">=</span> <span class="mi">30</span>
</pre></div>
</div>
<p>At this point it is illustrative to examine what the
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_dof.by_effective_independence.html#sdynpy.fem.sdynpy_dof.by_effective_independence" title="sdynpy.fem.sdynpy_dof.by_effective_independence"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.dof.by_effective_independence</span></code></a>.
function wants as its arguments.  The first argument is <code class="docutils literal notranslate"><span class="pre">sensors_to_keep</span></code>,
which is the number we just defined.  The second is the <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code>.
Reading the documentation, this <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> should have its first dimension
corresponding to each sensor (here a sensor could be a channel or group of
channels for a triaxial accelerometer) and its last dimension be correspond to
each target mode.  We will therefore want to set up a matrix with shape
(<code class="docutils literal notranslate"><span class="pre">candidate_node_ids.size</span></code> x 3 x <code class="docutils literal notranslate"><span class="pre">target_shapes.size</span></code>).  This way, the
target shape dimension is last, and the group of channels corresponding to each
sensor is first.</p>
<p>Let’s start setting this up.  We already have a shape
(<code class="docutils literal notranslate"><span class="pre">candidate_node_ids.size</span></code> x 3) <code class="docutils literal notranslate"><span class="pre">candidate_dofs</span></code>
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>.
We can use that coordinate array to index into the <code class="docutils literal notranslate"><span class="pre">target_shapes</span></code>
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the shape matrix by indexing the target shapes with our candidate dofs</span>
<span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">target_shapes</span><span class="p">[</span><span class="n">candidate_dofs</span><span class="p">]</span>
</pre></div>
</div>
<p>Here it is illustrative to examine the sizes of the arrays in this operation in
the IPython console.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [24]: target_shapes.shape</span>
<span class="go">Out[24]: (43,)</span>

<span class="go">In [25]: candidate_dofs.shape</span>
<span class="go">Out[25]: (1217, 3)</span>

<span class="go">In [26]: shape_matrix.shape</span>
<span class="go">Out[26]: (43, 1217, 3)</span>
</pre></div>
</div>
<p>We see that we started with 43 shapes in our <code class="docutils literal notranslate"><span class="pre">target_shapes</span></code> array.  We then
index into that array with our (1217 x 3) <code class="docutils literal notranslate"><span class="pre">candidate_dofs</span></code> array.  This
selects a (1217 x 3) shape matrix for each of the 43 shapes, resulting in a
final <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> shape of (43 x 1217 x 3).  We are almost to the
desired shape of <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code>.  However, as stated in the documentation, the
mode dimension of the array should be last, and the sensor dimension should be
first.  We simply need to move the first axis (index 0 in Python’s 0-based
indexing) to the last index (index -1, where the negative index signifies
counting from the end of the array).  We can easily move array axes around
using NumPy’s <code class="docutils literal notranslate"><span class="pre">moveaxis</span></code> function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">shape_matrix</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Now if we re-examine the shape in the IPython console, we see that it is the
proper shape.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [27]: shape_matrix.shape</span>
<span class="go">Out[27]: (1217, 3, 43)</span>
</pre></div>
</div>
<p>We can now run the sensor selection algorithm using the effective independence
objective function.  The sensor selection schemes are contained in
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_dof.html#module-sdynpy.fem.sdynpy_dof" title="sdynpy.fem.sdynpy_dof"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sdpy.dof</span></code></a>, and we will use the
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_dof.by_effective_independence.html#sdynpy.fem.sdynpy_dof.by_effective_independence" title="sdynpy.fem.sdynpy_dof.by_effective_independence"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.dof.by_effective_independence</span></code></a>
function.  We give it our <code class="docutils literal notranslate"><span class="pre">sensors_to_keep</span></code> and <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code>, as well as
give the optional flag to <code class="docutils literal notranslate"><span class="pre">return_efi</span></code> so we can visualize the effective
independence of the shape matrix as degrees of freedom are removed.  We can
plot this function, as well as the kept degrees of freedom by indexing the
oridinal set of degrees of freedom with the <code class="docutils literal notranslate"><span class="pre">keep_indices</span></code> returned from
the
<a class="reference internal" href="../_autosummary/sdynpy.fem.sdynpy_dof.by_effective_independence.html#sdynpy.fem.sdynpy_dof.by_effective_independence" title="sdynpy.fem.sdynpy_dof.by_effective_independence"><code class="xref py py-func docutils literal notranslate"><span class="pre">by_effective_independence</span></code></a>
function.  Intuitively, the sensors seem well-placed, with many positioned at
the boundaries of the wing and tail, as well as a few on the nose and fuselage.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">keep_indices</span><span class="p">,</span><span class="n">efi</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">dof</span><span class="o">.</span><span class="n">by_effective_independence</span><span class="p">(</span>
    <span class="n">sensors_to_keep</span><span class="p">,</span> <span class="n">shape_matrix</span><span class="p">,</span><span class="n">return_efi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Plot the effective independence vs dofs</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;EFI vs DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">shape_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">efi</span><span class="p">)),</span> <span class="n">efi</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;EFI&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;DoF Remaining&#39;</span><span class="p">)</span>

<span class="c1"># Plot the kept dofs on the model</span>
<span class="n">keep_dofs</span> <span class="o">=</span> <span class="n">candidate_dofs</span><span class="p">[</span><span class="n">keep_indices</span><span class="p">]</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">keep_dofs</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span><span class="n">plot_kwargs</span> <span class="o">=</span> <span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/EFI_vs_DoF.png"><img alt="Effective Independence vs Sensors remaining" src="../_images/EFI_vs_DoF.png" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../_images/test_dofs_on_fem.png"><img alt="Test Sensors plotted on the Finite Element Model" src="../_images/test_dofs_on_fem.png" style="width: 600px;" /></a>
</section>
<section id="creating-a-test-geometry">
<h2><a class="toc-backref" href="#id20">Creating a Test Geometry</a><a class="headerlink" href="#creating-a-test-geometry" title="Permalink to this heading"></a></h2>
<p>Because the test sensors are a small subset of the nodes on the original
finite element model, it can be useful to add visualization features to the
test geometry to help visualize responses from the test.  We have already
explored elements, which our finite element model has in abundance, so for the
test geometry we will use
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">tracelines</span></code></a>
to aid in visualization.  We will use the helper function
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.add_traceline" title="sdynpy.core.sdynpy_geometry.Geometry.add_traceline"><code class="xref py py-func docutils literal notranslate"><span class="pre">add_traceline</span></code></a>.</p>
<p>The first step in this process is to simply reduce the original geometry down
to our kept sensor locations. using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.reduce" title="sdynpy.core.sdynpy_geometry.Geometry.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">reduce</span></code></a> method.
This method will discard any coordinate systems, tracelines, or elements that
do not entirely consist of the nodes that are kept, which in this case means
that the geometry will consist of only nodes and their coordinate systems.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a test geometry and shapes to plot on the test geometry</span>
<span class="n">test_geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">keep_dofs</span><span class="o">.</span><span class="n">node</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [28]: test_geometry</span>
<span class="go">Out[28]:</span>
<span class="go">Node</span>
<span class="go">   Index,     ID,        X,        Y,        Z, DefCS, DisCS</span>
<span class="go">    (0,),   2796,   -0.051,    0.497,   -2.562, 20497,  2796</span>
<span class="go">    (1,),   5248,   -0.095,    0.031,    0.000, 20497,  5248</span>
<span class="go">    (2,),   6157,   -4.970,    0.310,   -2.500, 20497,  6157</span>
<span class="go">    (3,),   6172,   -1.413,   -0.001,   -2.500, 20497,  6172</span>
<span class="go">    (4,),   6214,   -3.989,    0.224,   -2.500, 20497,  6214</span>
<span class="go">    (5,),   6272,   -2.438,   -0.037,   -2.500, 20497,  6272</span>
<span class="go">    (6,),   6376,   -4.970,    0.310,   -4.000, 20497,  6376</span>
<span class="go">    (7,),   6392,   -3.989,    0.224,   -4.000, 20497,  6392</span>
<span class="go">    (8,),   6405,   -3.192,    0.155,   -4.000, 20497,  6405</span>
<span class="go">    (9,),   8143,   -1.384,   -0.129,   -4.000, 20497,  8143</span>
<span class="go">   (10,),   8160,   -2.438,   -0.037,   -4.000, 20497,  8160</span>
<span class="go">   (11,),  11664,    2.438,   -0.037,   -2.500, 20497, 11664</span>
<span class="go">   (12,),  11705,    4.970,    0.310,   -2.500, 20497, 11705</span>
<span class="go">   (13,),  11722,    3.989,    0.224,   -2.500, 20497, 11722</span>
<span class="go">   (14,),  11735,    3.192,    0.155,   -2.500, 20497, 11735</span>
<span class="go">   (15,),  11764,    1.413,   -0.001,   -2.500, 20497, 11764</span>
<span class="go">   (16,),  11892,    2.438,   -0.037,   -4.000, 20497, 11892</span>
<span class="go">   (17,),  11909,    1.384,   -0.129,   -4.000, 20497, 11909</span>
<span class="go">   (18,),  13603,    4.970,    0.310,   -4.000, 20497, 13603</span>
<span class="go">   (19,),  13647,    3.192,    0.155,   -4.000, 20497, 13647</span>
<span class="go">   (20,),  13660,    3.989,    0.224,   -4.000, 20497, 13660</span>
<span class="go">   (21,),  17107,    2.000,   -0.062,   -6.000, 20497, 17107</span>
<span class="go">   (22,),  17563,    2.000,    0.062,   -7.000, 20497, 17563</span>
<span class="go">   (23,),  17573,    1.123,    0.062,   -7.000, 20497, 17573</span>
<span class="go">   (24,),  18331,    0.063,    2.000,   -6.000, 20497, 18331</span>
<span class="go">   (25,),  18416,    0.063,    1.185,   -7.000, 20497, 18416</span>
<span class="go">   (26,),  18787,   -0.062,    2.000,   -7.000, 20497, 18787</span>
<span class="go">   (27,),  19579,   -2.000,   -0.062,   -6.000, 20497, 19579</span>
<span class="go">   (28,),  19651,   -2.000,    0.063,   -7.000, 20497, 19651</span>
<span class="go">   (29,),  19665,   -1.123,    0.063,   -7.000, 20497, 19665</span>

<span class="go">Coordinate_system</span>
<span class="go">   Index,     ID,                 Name, Color,       Type</span>
<span class="go">    (0,),   2796,       Node 2796 Disp,     1,  Cartesian</span>
<span class="go">    (1,),   5248,       Node 5248 Disp,     1,  Cartesian</span>
<span class="go">    (2,),   6157,       Node 6157 Disp,     1,  Cartesian</span>
<span class="go">    (3,),   6172,       Node 6172 Disp,     1,  Cartesian</span>
<span class="go">    (4,),   6214,       Node 6214 Disp,     1,  Cartesian</span>
<span class="go">    (5,),   6272,       Node 6272 Disp,     1,  Cartesian</span>
<span class="go">    (6,),   6376,       Node 6376 Disp,     1,  Cartesian</span>
<span class="go">    (7,),   6392,       Node 6392 Disp,     1,  Cartesian</span>
<span class="go">    (8,),   6405,       Node 6405 Disp,     1,  Cartesian</span>
<span class="go">    (9,),   8143,       Node 8143 Disp,     1,  Cartesian</span>
<span class="go">   (10,),   8160,       Node 8160 Disp,     1,  Cartesian</span>
<span class="go">   (11,),  11664,      Node 11664 Disp,     1,  Cartesian</span>
<span class="go">   (12,),  11705,      Node 11705 Disp,     1,  Cartesian</span>
<span class="go">   (13,),  11722,      Node 11722 Disp,     1,  Cartesian</span>
<span class="go">   (14,),  11735,      Node 11735 Disp,     1,  Cartesian</span>
<span class="go">   (15,),  11764,      Node 11764 Disp,     1,  Cartesian</span>
<span class="go">   (16,),  11892,      Node 11892 Disp,     1,  Cartesian</span>
<span class="go">   (17,),  11909,      Node 11909 Disp,     1,  Cartesian</span>
<span class="go">   (18,),  13603,      Node 13603 Disp,     1,  Cartesian</span>
<span class="go">   (19,),  13647,      Node 13647 Disp,     1,  Cartesian</span>
<span class="go">   (20,),  13660,      Node 13660 Disp,     1,  Cartesian</span>
<span class="go">   (21,),  17107,      Node 17107 Disp,     1,  Cartesian</span>
<span class="go">   (22,),  17563,      Node 17563 Disp,     1,  Cartesian</span>
<span class="go">   (23,),  17573,      Node 17573 Disp,     1,  Cartesian</span>
<span class="go">   (24,),  18331,      Node 18331 Disp,     1,  Cartesian</span>
<span class="go">   (25,),  18416,      Node 18416 Disp,     1,  Cartesian</span>
<span class="go">   (26,),  18787,      Node 18787 Disp,     1,  Cartesian</span>
<span class="go">   (27,),  19579,      Node 19579 Disp,     1,  Cartesian</span>
<span class="go">   (28,),  19651,      Node 19651 Disp,     1,  Cartesian</span>
<span class="go">   (29,),  19665,      Node 19665 Disp,     1,  Cartesian</span>
<span class="go">   (30,),  20497,               Global,     1,  Cartesian</span>

<span class="go">Traceline</span>
<span class="go">   Index,     ID,          Description, Color, # Nodes</span>
<span class="go">----------- Empty -------------</span>

<span class="go">Element</span>
<span class="go">   Index,     ID, Type, Color, # Nodes</span>
<span class="go">----------- Empty -------------</span>
</pre></div>
</div>
<p>At this point, we would like to connect the nodes with tracelines.  We can
plot the kept sensor degrees of freedom on the reduced <code class="docutils literal notranslate"><span class="pre">test_geometry</span></code>, and
specify <code class="docutils literal notranslate"><span class="pre">label_dofs=True</span></code> to create labels at each of the coordinates.  This
will allow us to easily see which nodes should be connected.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s plot the coordinates with the dofs labeled to aid us in creating the</span>
<span class="c1"># tracelines</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">keep_dofs</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/test_geometry_labeled.png"><img alt="Labeled degrees of freedom on the test geometry" src="../_images/test_geometry_labeled.png" style="width: 600px;" /></a>
<p>With the points labeled, it is easy to see which nodes should be connected using
tracelines.  When we create tracelines, we will also set the colors, using
<code class="docutils literal notranslate"><span class="pre">color=1</span></code> (blue) for the fuselage, <code class="docutils literal notranslate"><span class="pre">color=7</span></code> (green) for the wings, and
<code class="docutils literal notranslate"><span class="pre">color=13</span></code> (pink) for the tail.  After the tracelines are added, it is much
easier to visualize the structure of the airplane.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Fuselage</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">add_traceline</span><span class="p">([</span><span class="mi">5248</span><span class="p">,</span><span class="mi">2796</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># Wings</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">add_traceline</span><span class="p">([</span><span class="mi">6172</span><span class="p">,</span><span class="mi">6272</span><span class="p">,</span><span class="mi">6214</span><span class="p">,</span><span class="mi">6157</span><span class="p">,</span><span class="mi">6376</span><span class="p">,</span><span class="mi">6392</span><span class="p">,</span><span class="mi">6405</span><span class="p">,</span><span class="mi">8160</span><span class="p">,</span><span class="mi">8143</span><span class="p">,</span><span class="mi">6172</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">add_traceline</span><span class="p">([</span><span class="mi">11909</span><span class="p">,</span><span class="mi">11892</span><span class="p">,</span><span class="mi">13647</span><span class="p">,</span><span class="mi">13660</span><span class="p">,</span><span class="mi">13603</span><span class="p">,</span><span class="mi">11705</span><span class="p">,</span><span class="mi">11722</span><span class="p">,</span><span class="mi">11735</span><span class="p">,</span><span class="mi">11664</span><span class="p">,</span><span class="mi">11764</span><span class="p">,</span><span class="mi">11909</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="mi">7</span><span class="p">)</span>
<span class="c1"># Tail</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">add_traceline</span><span class="p">([</span><span class="mi">19579</span><span class="p">,</span><span class="mi">19651</span><span class="p">,</span><span class="mi">19665</span><span class="p">,</span><span class="mi">19579</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">add_traceline</span><span class="p">([</span><span class="mi">17573</span><span class="p">,</span><span class="mi">17563</span><span class="p">,</span><span class="mi">17107</span><span class="p">,</span><span class="mi">17573</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">add_traceline</span><span class="p">([</span><span class="mi">18787</span><span class="p">,</span><span class="mi">18416</span><span class="p">,</span><span class="mi">18331</span><span class="p">,</span><span class="mi">18787</span><span class="p">],</span><span class="n">color</span><span class="o">=</span><span class="mi">13</span><span class="p">)</span>

<span class="c1"># Now plot the geometry to see the tracelines</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">keep_dofs</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.02</span><span class="p">,</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/test_geometry_with_tracelines_labeled.png"><img alt="Labeled degrees of freedom on the test geometry with tracelines" src="../_images/test_geometry_with_tracelines_labeled.png" style="width: 600px;" /></a>
<p>It is also useful to reduce the shapes down to the test degrees of freedom,
which we can do using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.reduce" title="sdynpy.core.sdynpy_shape.ShapeArray.reduce"><code class="xref py py-func docutils literal notranslate"><span class="pre">ShapeArray.reduce</span></code></a> method,
and we will need to specify a damping value (here 2% is used) as there is no
damping in the finite element model.  We can then plot our test shapes on our
test geometry to make sure everything looks right.  We can look at the
Modal Assurance Criterion matrix of our reduced set of shapes to
ensure that we can distinguish the shapes from the test sensors.  The MAC
can be computed with the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.mac.html#sdynpy.core.sdynpy_shape.mac" title="sdynpy.core.sdynpy_shape.mac"><code class="xref py py-func docutils literal notranslate"><span class="pre">ShapeArray.mac</span></code></a> function, and the
matrix can be plotted nicely using the
<a class="reference internal" href="../_autosummary/sdynpy.signal_processing.sdynpy_correlation.matrix_plot.html#sdynpy.signal_processing.sdynpy_correlation.matrix_plot" title="sdynpy.signal_processing.sdynpy_correlation.matrix_plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.correlation.matrix_plot</span></code></a>
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now get the test shapes by reducing the target shapes to the test dofs</span>
<span class="n">test_shapes</span> <span class="o">=</span> <span class="n">target_shapes</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">keep_dofs</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
<span class="c1"># We&#39;ll need to add damping to the model too</span>
<span class="n">test_shapes</span><span class="o">.</span><span class="n">damping</span><span class="o">=</span><span class="mf">0.02</span>
<span class="c1"># Plot the geometry to see what it looks like</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">test_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
<span class="c1"># Look at the mac for the target shapes with our set of degrees of freedom</span>
<span class="n">sdpy</span><span class="o">.</span><span class="n">correlation</span><span class="o">.</span><span class="n">matrix_plot</span><span class="p">(</span><span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">mac</span><span class="p">(</span><span class="n">test_shapes</span><span class="p">),</span><span class="n">text_size</span> <span class="o">=</span> <span class="mi">8</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/test_shape.gif"><img alt="Representative elastic shape plotted on the test geometry" src="../_images/test_shape.gif" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../_images/test_mac.png"><img alt="MAC matrix of the test shapes" src="../_images/test_mac.png" style="width: 600px;" /></a>
<section id="oops-an-instrumentation-error">
<h3><a class="toc-backref" href="#id21">OOPS! An Instrumentation Error!</a><a class="headerlink" href="#oops-an-instrumentation-error" title="Permalink to this heading"></a></h3>
<p>Installing instrumentation is a tedious process that must be well-documented
for success of a given test.  For large channel-count tests, it is almost
inevitable that there will be some kind of sensor or geometry error, so it is
useful to develop workflows to verify that sensors are oriented correctly.
Here we will purposefully introduce an instrumentation error by setting the
displacement coordinate system of one of our sensors to the global coordinate
system rather than its correct local coordinate system.  We will then
investigate a workflow in SDynPy for identifying correcting this error.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Copy the geometry so we don&#39;t overwrite our correct version</span>
<span class="n">test_geometry_error</span> <span class="o">=</span> <span class="n">test_geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="c1"># Change the displacement coordinate system of the 5th node to the global</span>
<span class="c1"># coordinate system</span>
<span class="n">test_geometry_error</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">disp_cs</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">test_geometry_error</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
</pre></div>
</div>
</section>
</section>
<section id="running-a-virtual-experiment-rigid-body-checkouts">
<h2><a class="toc-backref" href="#id22">Running a Virtual Experiment: Rigid Body Checkouts</a><a class="headerlink" href="#running-a-virtual-experiment-rigid-body-checkouts" title="Permalink to this heading"></a></h2>
<p>One approach to validating the test geometry and channel table is to perform
rigid body checks, where the structure is
excited at a frequency well below the elastic modes of the system to elicit a
rigid body response.  These response shapes can be visualized on the geometry
and should appear rigid.  If, for example, a sensor is moving out of phase
with the rest of the sensors, it is fairly certain there is an instrumentation
or bookkeeping error.  When looking at acceleration response, these rigid
shapes should also have very small imaginary parts compared to their real parts.
Finally, a projector can be used to project the measured rigid body shapes
through analytic rigid body shapes created from the test geometry.  This
operation will remove any “non-rigid” components of the measured shapes.  By
subtracting this “rigidized” version from the measured shapes, a residual can
be created where large values in the residual point to non-rigid motions.</p>
<div class="math notranslate nohighlight">
\[\mathbf{R} = \mathbf{\Phi} - \mathbf{\Phi}_a{\mathbf{\Phi}_a}^+\mathbf{\Phi}\]</div>
<section id="creating-a-system-object-to-integrate">
<h3><a class="toc-backref" href="#id23">Creating a System Object to Integrate</a><a class="headerlink" href="#creating-a-system-object-to-integrate" title="Permalink to this heading"></a></h3>
<p>We will now simulate one of these rigid body tests by integrating equations of
motion.  SDynPy uses <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>
objects to represent dynamical systems.
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> objects contain mass,
stiffness, and damping matrices.  They also can contain a transformation matrix
to return to physical coordinates if the internal state degrees of freedom are
represented in a reduced space (for example, a mode shape matrix is the
transformation between modal mass, stiffness, and damping matrices and the
corresponding physical coordinates).
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> objects also contain
a <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">coordinate</span></code></a>
to aid in bookkeeping.</p>
<p>We can easily create a modal <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>
from our existing shapes by using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.system" title="sdynpy.core.sdynpy_shape.ShapeArray.system"><code class="xref py py-func docutils literal notranslate"><span class="pre">ShapeArray.system</span></code></a> method.
This will return a state matrix in modal space.  We can use the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.spy" title="sdynpy.core.sdynpy_system.System.spy"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.spy</span></code></a> method to visualize
the structure of the created system.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a System from the test shapes</span>
<span class="n">test_system</span> <span class="o">=</span> <span class="n">test_shapes</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
<span class="c1"># Look at the structure of the System object</span>
<span class="n">test_system</span><span class="o">.</span><span class="n">spy</span><span class="p">()</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/modal_system_spy.png"><img alt="Structure of the test system object" src="../_images/modal_system_spy.png" style="width: 600px;" /></a>
<p>We can see from the above matrix plot that the internal state is diagonal,
consisting of 43 modal degrees of freedom, whereas the transformation matrices
(which are the mode shape matrices in this case) are full, consisting of 90
physical degrees of freedom.</p>
<section id="exploring-the-system-object">
<h4><a class="toc-backref" href="#id24">Exploring the System Object</a><a class="headerlink" href="#exploring-the-system-object" title="Permalink to this heading"></a></h4>
<p>Here is a good place to take time to investigate the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>
object we have just created.  We can look at the <code class="docutils literal notranslate"><span class="pre">mass</span></code>, <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>, and
<code class="docutils literal notranslate"><span class="pre">damping</span></code> attributes to see those matrices, and verify that they are indeed
diagonal for the modal system we have created.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [29]: test_system.mass</span>
<span class="go">Out[29]:</span>
<span class="go">array([[1., 0., 0., ..., 0., 0., 0.],</span>
<span class="go">       [0., 1., 0., ..., 0., 0., 0.],</span>
<span class="go">       [0., 0., 1., ..., 0., 0., 0.],</span>
<span class="go">       ...,</span>
<span class="go">       [0., 0., 0., ..., 1., 0., 0.],</span>
<span class="go">       [0., 0., 0., ..., 0., 1., 0.],</span>
<span class="go">       [0., 0., 0., ..., 0., 0., 1.]])</span>

<span class="go">In [30]: test_system.stiffness</span>
<span class="go">Out[30]:</span>
<span class="go">array([[      0.        ,       0.        ,       0.        , ...,</span>
<span class="go">              0.        ,       0.        ,       0.        ],</span>
<span class="go">       [      0.        ,       0.        ,       0.        , ...,</span>
<span class="go">              0.        ,       0.        ,       0.        ],</span>
<span class="go">       [      0.        ,       0.        ,       0.        , ...,</span>
<span class="go">              0.        ,       0.        ,       0.        ],</span>
<span class="go">       ...,</span>
<span class="go">       [      0.        ,       0.        ,       0.        , ...,</span>
<span class="go">        2868905.99964993,       0.        ,       0.        ],</span>
<span class="go">       [      0.        ,       0.        ,       0.        , ...,</span>
<span class="go">              0.        , 3210105.88194563,       0.        ],</span>
<span class="go">       [      0.        ,       0.        ,       0.        , ...,</span>
<span class="go">              0.        ,       0.        , 3289727.48791008]])</span>

<span class="go">In [31]: test_system.damping</span>
<span class="go">Out[31]:</span>
<span class="go">array([[ 0.        ,  0.        ,  0.        , ...,  0.        ,</span>
<span class="go">         0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        , ...,  0.        ,</span>
<span class="go">         0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        , ...,  0.        ,</span>
<span class="go">         0.        ,  0.        ],</span>
<span class="go">       ...,</span>
<span class="go">       [ 0.        ,  0.        ,  0.        , ..., 67.75138079,</span>
<span class="go">         0.        ,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        , ...,  0.        ,</span>
<span class="go">        71.66707341,  0.        ],</span>
<span class="go">       [ 0.        ,  0.        ,  0.        , ...,  0.        ,</span>
<span class="go">         0.        , 72.55042371]])</span>
</pre></div>
</div>
<p>We can also look at the <code class="docutils literal notranslate"><span class="pre">transformation</span></code> and <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> to see
that the bookkeeping from internal state (modal) degree of freedom to
physical degree of freedom is maintained.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [32]: test_system.transformation</span>
<span class="go">Out[32]:</span>
<span class="go">array([[-2.76026978e-03, -1.40194807e-03,  4.58617331e-03, ...,</span>
<span class="go">         1.73749203e-03, -3.09022372e-04, -1.68270938e-05],</span>
<span class="go">       [ 6.53050658e-04, -5.80137822e-04, -2.07032636e-03, ...,</span>
<span class="go">         1.46528917e-04,  6.02431820e-04, -5.76349533e-03],</span>
<span class="go">       [ 1.69407153e-03,  3.83686628e-04, -7.59999135e-04, ...,</span>
<span class="go">         5.49012119e-04,  2.74121905e-03,  2.04985114e-04],</span>
<span class="go">       ...,</span>
<span class="go">       [-8.55739072e-03,  8.65502669e-04,  9.38297408e-04, ...,</span>
<span class="go">         1.34896916e-02,  3.71546727e-03,  1.47339469e-03],</span>
<span class="go">       [-4.93925263e-05, -8.19915019e-03, -2.66942214e-03, ...,</span>
<span class="go">         2.39905468e-03, -1.48742295e-05, -2.91024169e-05],</span>
<span class="go">       [-6.55791597e-03,  3.30305914e-04, -6.16004354e-03, ...,</span>
<span class="go">         1.31560277e-02,  3.15253196e-03,  1.19728196e-03]])</span>

<span class="go">In [33]: test_system.coordinate</span>
<span class="go">Out[33]:</span>
<span class="go">coordinate_array(string_array=</span>
<span class="go">array([&#39;2796X+&#39;, &#39;2796Y+&#39;, &#39;2796Z+&#39;, &#39;5248X+&#39;, &#39;5248Y+&#39;, &#39;5248Z+&#39;,</span>
<span class="go">       &#39;6157X+&#39;, &#39;6157Y+&#39;, &#39;6157Z+&#39;, &#39;6172X+&#39;, &#39;6172Y+&#39;, &#39;6172Z+&#39;,</span>
<span class="go">       &#39;6214X+&#39;, &#39;6214Y+&#39;, &#39;6214Z+&#39;, &#39;6272X+&#39;, &#39;6272Y+&#39;, &#39;6272Z+&#39;,</span>
<span class="go">       &#39;6376X+&#39;, &#39;6376Y+&#39;, &#39;6376Z+&#39;, &#39;6392X+&#39;, &#39;6392Y+&#39;, &#39;6392Z+&#39;,</span>
<span class="go">       &#39;6405X+&#39;, &#39;6405Y+&#39;, &#39;6405Z+&#39;, &#39;8143X+&#39;, &#39;8143Y+&#39;, &#39;8143Z+&#39;,</span>
<span class="go">       &#39;8160X+&#39;, &#39;8160Y+&#39;, &#39;8160Z+&#39;, &#39;11664X+&#39;, &#39;11664Y+&#39;, &#39;11664Z+&#39;,</span>
<span class="go">       &#39;11705X+&#39;, &#39;11705Y+&#39;, &#39;11705Z+&#39;, &#39;11722X+&#39;, &#39;11722Y+&#39;, &#39;11722Z+&#39;,</span>
<span class="go">       &#39;11735X+&#39;, &#39;11735Y+&#39;, &#39;11735Z+&#39;, &#39;11764X+&#39;, &#39;11764Y+&#39;, &#39;11764Z+&#39;,</span>
<span class="go">       &#39;11892X+&#39;, &#39;11892Y+&#39;, &#39;11892Z+&#39;, &#39;11909X+&#39;, &#39;11909Y+&#39;, &#39;11909Z+&#39;,</span>
<span class="go">       &#39;13603X+&#39;, &#39;13603Y+&#39;, &#39;13603Z+&#39;, &#39;13647X+&#39;, &#39;13647Y+&#39;, &#39;13647Z+&#39;,</span>
<span class="go">       &#39;13660X+&#39;, &#39;13660Y+&#39;, &#39;13660Z+&#39;, &#39;17107X+&#39;, &#39;17107Y+&#39;, &#39;17107Z+&#39;,</span>
<span class="go">       &#39;17563X+&#39;, &#39;17563Y+&#39;, &#39;17563Z+&#39;, &#39;17573X+&#39;, &#39;17573Y+&#39;, &#39;17573Z+&#39;,</span>
<span class="go">       &#39;18331X+&#39;, &#39;18331Y+&#39;, &#39;18331Z+&#39;, &#39;18416X+&#39;, &#39;18416Y+&#39;, &#39;18416Z+&#39;,</span>
<span class="go">       &#39;18787X+&#39;, &#39;18787Y+&#39;, &#39;18787Z+&#39;, &#39;19579X+&#39;, &#39;19579Y+&#39;, &#39;19579Z+&#39;,</span>
<span class="go">       &#39;19651X+&#39;, &#39;19651Y+&#39;, &#39;19651Z+&#39;, &#39;19665X+&#39;, &#39;19665Y+&#39;, &#39;19665Z+&#39;],</span>
<span class="go">      dtype=&#39;&lt;U7&#39;))</span>
</pre></div>
</div>
</section>
</section>
<section id="setting-up-the-integration-and-forcing-function">
<h3><a class="toc-backref" href="#id25">Setting up the Integration and Forcing Function</a><a class="headerlink" href="#setting-up-the-integration-and-forcing-function" title="Permalink to this heading"></a></h3>
<p>We aim integrate our <code class="docutils literal notranslate"><span class="pre">test_system</span></code> using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.time_integrate</span></code></a>
method, but first we need to set up its required
sampling parameters.  We will specify our test bandwidth, as well as an
integration oversample factor to ensure that the integration is performed
accurately.
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> objects represent Linear,
Time-Invariant systems, so the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lsim.html">scipy.signal.lsim</a>
function is used for integration within the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.time_integrate</span></code></a>
function, and this typically only requires a factor of 10x the desired
sampling rate to achieve reasonable results.  We will also define the desired
frequency spacing for the test.  The other sampling parameters can be
derived from these definitions.  We will measure 10 frames so averaging
can be performed when computing frequency response functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># First let&#39;s set up our general sampling parameters for our test.</span>
<span class="n">test_bandwidth</span> <span class="o">=</span> <span class="mi">200</span> <span class="c1"># Hz</span>
<span class="n">integration_oversample</span> <span class="o">=</span> <span class="mi">10</span> <span class="c1">#x</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">test_bandwidth</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">integration_oversample</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">sample_rate</span>
<span class="n">df</span> <span class="o">=</span> <span class="mf">0.125</span> <span class="c1"># Hz</span>
<span class="n">samples_per_frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">sample_rate</span><span class="o">/</span><span class="n">df</span><span class="p">)</span>
<span class="n">rb_frames</span> <span class="o">=</span> <span class="mi">10</span>
</pre></div>
</div>
<p>We will now create the forcing function for our rigid body test, which will be
a sine wave.  The first elastic mode of the test article is near 6 Hz, so we
choose a frequency that is much lower than that value.  We can then use the
<a class="reference internal" href="../_autosummary/sdynpy.signal_processing.sdynpy_generator.sine.html#sdynpy.signal_processing.sdynpy_generator.sine" title="sdynpy.signal_processing.sdynpy_generator.sine"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.generator.sine</span></code></a>
function to produce a sine wave with the proper sampling parameters.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now we will create a sine signal that we can use for rigid body checkouts</span>
<span class="n">rb_frequency</span> <span class="o">=</span> <span class="mf">0.5</span> <span class="c1"># Hz</span>
<span class="n">force</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">sine</span><span class="p">(</span><span class="n">rb_frequency</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="o">*</span><span class="n">rb_frames</span><span class="p">)</span>
<span class="c1"># Plot the sine wave to make sure it is correct</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;Sine Force Signal&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="o">*</span><span class="n">rb_frames</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">force</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/Sine_Force_Signal.png"><img alt="Sinusoidal signal applied to the structure" src="../_images/Sine_Force_Signal.png" style="width: 600px;" /></a>
<p>Finally, we will chose the coordinates at which we will excite the structure.
We can examine our previous plots of the labeled test geometry to identify
degrees of freedom that are approximately through the center of gravity of the
structure, which will result in approximately translational motions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># To run the rigid body tests, we select degrees of freedom approximately</span>
<span class="c1"># through the CG of the part.</span>
<span class="n">rb_coordinates</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;2796Z+&#39;</span><span class="p">,</span><span class="s1">&#39;11722Y+&#39;</span><span class="p">,</span><span class="s1">&#39;2796X+&#39;</span><span class="p">])</span>
</pre></div>
</div>
</section>
<section id="running-the-integration-to-generate-synthetic-test-data">
<h3><a class="toc-backref" href="#id26">Running the Integration to Generate Synthetic Test Data</a><a class="headerlink" href="#running-the-integration-to-generate-synthetic-test-data" title="Permalink to this heading"></a></h3>
<p>We will now loop through each of our excitation degrees of freedom and integrate
the System’s response to the force located at that postiion using
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.time_integrate</span></code></a>.
This will give us references and responses as
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> objects.
We will then truncate off the first second of the response in order to remove
the startup transients from the data using
<code class="xref py py-func docutils literal notranslate"><span class="pre">TimeHistoryArray.extract_elements_by_abscissa</span></code>.
We will then pass the truncated data into the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data" title="sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray.from_time_data</span></code></a>
function to produce frequency response functions as a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
object.  Once the frequency response functions are computed, we can query the
<code class="docutils literal notranslate"><span class="pre">ordinate</span></code> field of the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
to get the deflection shape, which we will store into a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.shape_array.html#sdynpy.core.sdynpy_shape.shape_array" title="sdynpy.core.sdynpy_shape.shape_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape_array</span></code></a> helper
function.  We append each shape to a running list, and then concatenate all the
shapes into one <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>
object, which we can plot on our erroneous geometry.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create a list to hold our shapes</span>
<span class="n">rb_shapes</span> <span class="o">=</span> <span class="p">[]</span>
<span class="c1"># Loop through each of our excitation locations</span>
<span class="k">for</span> <span class="n">rb_coordinate</span> <span class="ow">in</span> <span class="n">rb_coordinates</span><span class="p">:</span>
    <span class="c1"># Perform time integration to get the responses to our sine wave</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Integrating Rigid Body Excitation at </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rb_coordinate</span><span class="p">)))</span>
    <span class="n">responses</span><span class="p">,</span><span class="n">references</span> <span class="o">=</span> <span class="n">test_system</span><span class="o">.</span><span class="n">time_integrate</span><span class="p">(</span>
        <span class="n">force</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">references</span><span class="o">=</span><span class="n">rb_coordinate</span><span class="p">)</span>
    <span class="c1"># Plot the responses and references</span>
    <span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">num</span><span class="o">=</span><span class="s1">&#39;Rigid Body Test </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">rb_coordinate</span><span class="p">)))</span>
    <span class="n">responses</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Acceleration&#39;</span><span class="p">)</span>
    <span class="n">references</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Force&#39;</span><span class="p">)</span>
    <span class="c1"># Truncate the initial portions of the functions so we eliminate the</span>
    <span class="c1"># transient portion of the response</span>
    <span class="n">responses</span> <span class="o">=</span> <span class="n">responses</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="n">references</span> <span class="o">=</span> <span class="n">references</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span><span class="p">)</span>
    <span class="c1"># Now we want to create an FRF from the references and responses</span>
    <span class="n">frf</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">TransferFunctionArray</span><span class="o">.</span><span class="n">from_time_data</span><span class="p">(</span><span class="n">references</span><span class="p">,</span><span class="n">responses</span><span class="p">,</span><span class="n">samples_per_frame</span><span class="p">)</span>
    <span class="c1"># Now we want to get the value at our frequency line because the rest will</span>
    <span class="c1"># be noise</span>
    <span class="n">frequency_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">frf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">-</span> <span class="n">rb_frequency</span><span class="p">))</span>
    <span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">frf</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">frequency_index</span><span class="p">]</span>
    <span class="c1"># Now let&#39;s create a shapearray object so we can plot the shapes</span>
    <span class="n">rb_shape</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape_array</span><span class="p">(</span><span class="n">frf</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">,</span><span class="n">shape_matrix</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                                <span class="n">rb_frequency</span><span class="p">,</span><span class="n">comment1</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">rb_coordinate</span><span class="p">))</span>
    <span class="n">rb_shapes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rb_shape</span><span class="p">)</span>

<span class="c1"># Combine all rb_shapes into one shape array</span>
<span class="n">rb_shapes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">rb_shapes</span><span class="p">)</span>

<span class="c1"># Now let&#39;s plot those shapes on our (incorrect) geometry</span>
<span class="n">test_geometry_error</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">rb_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<p>Throughout the above code, the responses and reference signal were plotted; a
representative figure is shown below, showing the sinusoidal response of the
system at the requested degrees of freedom.</p>
<a class="reference internal image-reference" href="../_images/example_rigid_body_test.png"><img alt="Responses to the excitation applied to the structure" src="../_images/example_rigid_body_test.png" style="width: 600px;" /></a>
<p>When we plot the measured rigid shapes against the geometry where we
intentionally introduce errors, we see that one of the sensors on the wing
seems to be moving opposite the rest of the wing.  We will investigate this
more thoroughly in a moment.</p>
<a class="reference internal image-reference" href="../_images/error_rigid_shape.gif"><img alt="Rigid body shapes shown on erroneous geometry" src="../_images/error_rigid_shape.gif" style="width: 600px;" /></a>
</section>
<section id="exploring-time-data-objects">
<h3><a class="toc-backref" href="#id27">Exploring Time Data Objects</a><a class="headerlink" href="#exploring-time-data-objects" title="Permalink to this heading"></a></h3>
<p>Before we move on to analyzing the rigid body datasets, we will first take some
time to explore some of the data objects that we have created.  Namely, we
generated some
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> objects
and a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
object for each excitation degree of freedom.</p>
<p>In SDynPy, all data objects inherit from the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a> class, which
represents a general, multi-dimensional data container.  This class, in turn,
inherits from the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>,
so all the broadcasting and attribute access features are available as well.</p>
<p>We will start by examining <code class="docutils literal notranslate"><span class="pre">responses</span></code> from the previous block of code.  We
see that it is a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> object.
We can look at its <code class="docutils literal notranslate"><span class="pre">dtype</span></code> to see what data it contains.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [34]: responses</span>
<span class="go">Out[34]: TimeHistoryArray with shape 90 and 316000 elements per function</span>

<span class="go">In [35]: responses.dtype</span>
<span class="go">Out[35]: dtype([(&#39;abscissa&#39;, &#39;&lt;f4&#39;, (316000,)),</span>
<span class="go">                (&#39;ordinate&#39;, &#39;&lt;f8&#39;, (316000,)),</span>
<span class="go">                (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment5&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;coordinate&#39;,</span>
<span class="go">                     [(&#39;node&#39;, &#39;&lt;u8&#39;), (&#39;direction&#39;, &#39;i1&#39;)],</span>
<span class="go">                     (1,))</span>
<span class="go">               ])</span>
</pre></div>
</div>
<p>Being a <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a>
object, responses consists of real data.  It has floating point <code class="docutils literal notranslate"><span class="pre">abscissa</span></code>
and <code class="docutils literal notranslate"><span class="pre">ordinate</span></code> fields to contain the independent time and dependent response
variables, respectively.  Note that the <code class="docutils literal notranslate"><span class="pre">abscissa</span></code> and <code class="docutils literal notranslate"><span class="pre">ordinate</span></code> fields
have the size of the length of the data record; in this case, it the time
data consists of 316,000 samples.  It also has five 80-character string fields
where comments can be stored.  Finally, it has a <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field that stores
the degree of freedom information for each data record.  Note the rather
peculiar length 1 on the <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field.  This is to signify that a time
history signal can be considered a 1D data array, which we will see is contrary
to, for example,
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
objects which are 2D, having both a response (output) coordinate and a reference
(input) coordinate.  Again, remember that these extra dimensions are appended
to the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a>
dimensions.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [35]: responses.shape</span>
<span class="go">Out[35]: (90,)</span>

<span class="go">In [36]: responses.ordinate.shape</span>
<span class="go">Out[36]: (90, 316000)</span>

<span class="go">In [37]: responses.coordinate.shape</span>
<span class="go">Out[37]: (90, 1)</span>
</pre></div>
</div>
<p>Consider the previous object in contrast to the <code class="docutils literal notranslate"><span class="pre">frf</span></code> variable, which is a
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
object.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [38]: frf</span>
<span class="go">Out[38]: TransferFunctionArray with shape 90 x 1 and 16000 elements per function</span>

<span class="go">In [39]: frf.dtype</span>
<span class="go">Out[39]: dtype([(&#39;abscissa&#39;, &#39;&lt;f4&#39;, (16000,)),</span>
<span class="go">                (&#39;ordinate&#39;, &#39;&lt;c16&#39;, (16000,)),</span>
<span class="go">                (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment5&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;coordinate&#39;,</span>
<span class="go">                     [(&#39;node&#39;, &#39;&lt;u8&#39;), (&#39;direction&#39;, &#39;i1&#39;)],</span>
<span class="go">                     (2,))</span>
<span class="go">                ])</span>
</pre></div>
</div>
<p><a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
has all the same fields as
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a>,
except they are different shapes and types.  Because frequency response data
is complex, the <code class="docutils literal notranslate"><span class="pre">ordinate</span></code> field is now a 16-byte complex number rather than
an 8-byte floating point number.  Similarly, because there are now reference
and response coordinates associated with each data record, the length of the
<code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field is now 2.</p>
</section>
<section id="identifying-bad-geometry-with-rigid-body-checkouts-in-sdynpy">
<h3><a class="toc-backref" href="#id28">Identifying Bad Geometry with Rigid Body Checkouts in SDynPy</a><a class="headerlink" href="#identifying-bad-geometry-with-rigid-body-checkouts-in-sdynpy" title="Permalink to this heading"></a></h3>
<p>Now that we’ve understood the data objects a bit better, we can return to the
task at hand, which is to sort out our geometry and channel table, which has
an intentionally incorrect sensor.</p>
<p>SDynPy has some built-in tools for doing rigid body checkouts, plotting the
complex plane and the residual discussed previously.  These are contained in
the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.rigid_body_check.html#sdynpy.core.sdynpy_shape.rigid_body_check" title="sdynpy.core.sdynpy_shape.rigid_body_check"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.rigid_body_check</span></code></a>
function.  Simply give the function the geometry and shapes, and it will
attempt to figure out which nodes are suspicious and warrant further
investigation.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># It looks like there is an error in the shapes (go figure!).  Let&#39;s perform</span>
<span class="c1"># a more quantitative analysis on the shapes to see what is wrong</span>
<span class="n">suspicious_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">rigid_body_check</span><span class="p">(</span>
    <span class="n">test_geometry_error</span><span class="p">,</span> <span class="n">rb_shapes</span><span class="p">)</span>
</pre></div>
</div>
<p>We can see on the complex plane plots that the imaginary part is significantly
smaller than the real part, meaning we are well away from elastic modes and
all of our gauges have the correct phase.  The residual plot immediately
highlights the sensors that are not behaving like they should, which allows
the test engineer to hone in on that sensor to figure out what is wrong.</p>
<a class="reference internal image-reference" href="../_images/rigid_body_check_complex_plane.png"><img alt="Real and imaginary parts of the complex shape" src="../_images/rigid_body_check_complex_plane.png" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../_images/rigid_body_check_residual.png"><img alt="Residual plot showing erroneous sensors." src="../_images/rigid_body_check_residual.png" style="width: 600px;" /></a>
<p>While the example problem shown here only has external sensors, many times
internal sensors may be suspicious, and without access to them, it can be
difficult to investigate the potential incorrect orientations of the sensors.
For this reason, SDynPy includes an approach to identify the “best” orientation
of the sensor using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.rigid_body_fix_node_orientation.html#sdynpy.core.sdynpy_shape.rigid_body_fix_node_orientation" title="sdynpy.core.sdynpy_shape.rigid_body_fix_node_orientation"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.rigid_body_fix_node_orientation</span></code></a>
function.  If we give this function a geometry, a set of rigid shapes, and a
list of suspicious nodes, it will attempt to find the correct orientation of
of the sensors at the suspicious nodes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Let&#39;s see if we can&#39;t let SDynPy figure out the correct orientation for that</span>
<span class="c1"># sensor in the geometry given the data.</span>
<span class="n">suspicious_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">suspicious_dofs</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
<span class="n">test_geometry_corrected</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">rigid_body_fix_node_orientation</span><span class="p">(</span>
    <span class="n">test_geometry_error</span><span class="p">,</span> <span class="n">rb_shapes</span><span class="p">,</span><span class="n">suspicious_nodes</span><span class="p">)</span>

<span class="c1"># Let&#39;s see what the fix looks like compared to the way the sensor is actually</span>
<span class="c1"># oriented</span>
<span class="n">test_geometry_error</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">from_nodelist</span><span class="p">(</span><span class="n">suspicious_nodes</span><span class="p">),</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">)</span>
<span class="n">test_geometry_corrected</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">from_nodelist</span><span class="p">(</span><span class="n">suspicious_nodes</span><span class="p">),</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">)</span>
<span class="n">test_geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">from_nodelist</span><span class="p">(</span><span class="n">suspicious_nodes</span><span class="p">),</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">)</span>

<span class="c1"># Plot the rigid shapes on the corrected geometry</span>
<span class="n">test_geometry_corrected</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">rb_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
</pre></div>
</div>
<p>We see that when we plotted the coordinate systems, SDynPy was able to take the
initial erroneous coordinate system (left) and correct it (center) so that it
matched the original coordinate system (right) that we had before we introduced
the instrumentation error.</p>
<a class="reference internal image-reference" href="../_images/geometry_error.png"><img alt="Erroneous coordinate system" src="../_images/geometry_error.png" style="width: 30%;" /></a>
<a class="reference internal image-reference" href="../_images/geometry_corrected.png"><img alt="Corrected coordinate system" src="../_images/geometry_corrected.png" style="width: 30%;" /></a>
<a class="reference internal image-reference" href="../_images/geometry_truth.png"><img alt="Truth coordinate system" src="../_images/geometry_truth.png" style="width: 30%;" /></a>
<p>We see now that when we plot the shapes on the corrected geometry, it indeed
looks like rigid motion.</p>
<a class="reference internal image-reference" href="../_images/corrected_rigid_shape.gif"><img alt="Rigid body shapes plotted with corrected geometry." src="../_images/corrected_rigid_shape.gif" style="width: 600px;" /></a>
</section>
</section>
<section id="running-a-virtual-experiment-modal-testing">
<h2><a class="toc-backref" href="#id29">Running a Virtual Experiment: Modal Testing</a><a class="headerlink" href="#running-a-virtual-experiment-modal-testing" title="Permalink to this heading"></a></h2>
<p>Now that we have validated test geometry, it is time to perform a modal test.
Again, we will simulate this virtually for this test.</p>
<p>The first thing we will do is select drive points to get all of the modes of
the system.  We will simply select positions here intuitively.  We will select
wing tips, tail tip, and nose points.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">drive_points</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="p">[</span>
    <span class="s1">&#39;6157Z+&#39;</span><span class="p">,</span>
    <span class="s1">&#39;11705Z+&#39;</span><span class="p">,</span>
    <span class="s1">&#39;18787Y+&#39;</span><span class="p">,</span>
    <span class="s1">&#39;5248Y+&#39;</span><span class="p">,</span>
    <span class="p">])</span>

<span class="n">test_geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">drive_points</span><span class="p">,</span><span class="n">plot_kwargs</span><span class="o">=</span><span class="n">plot_options</span><span class="p">,</span>
                              <span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_modal_drive_points.png"><img alt="Drive points used for a MIMO modal test." src="../_images/airplane_modal_drive_points.png" style="width: 600px;" /></a>
<p>Now we would like to set up a force for our modal test.  Here we will use a
random excitation, which will enable us to excite the structure with all
drive points simultaneously, which results in a Multiple-Input, Multiple-Output
modal test.</p>
<p>We can set up a random force using the
<a class="reference internal" href="../_autosummary/sdynpy.signal_processing.sdynpy_generator.random.html#sdynpy.signal_processing.sdynpy_generator.random" title="sdynpy.signal_processing.sdynpy_generator.random"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.generator.random</span></code></a>
function.  We will provide it the number of forces, the total number of samples,
the time step, and a high-frequency cutoff to ensure that we don’t have
aliasing when we downsample from the integration oversampling factor back to our
test bandwidth.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now let&#39;s create a force.  We will do a random excitation</span>
<span class="n">modal_frames</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">random_forces</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">random</span><span class="p">(</span>
    <span class="n">drive_points</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">modal_frames</span><span class="o">*</span><span class="n">samples_per_frame</span><span class="p">,</span><span class="n">dt</span><span class="o">=</span><span class="n">dt</span><span class="p">,</span>
    <span class="n">high_frequency_cutoff</span><span class="o">=</span><span class="n">test_bandwidth</span><span class="p">)</span>
<span class="c1"># Look at the signal statistics</span>
<span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">random_forces</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;Random Excitation&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">random_forces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span>
           <span class="n">random_forces</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Force&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time&#39;</span><span class="p">)</span>
<span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">random_forces</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">dt</span><span class="p">)</span>
<span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">random_forces</span><span class="p">,</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span><span class="nb">abs</span><span class="p">(</span><span class="n">fft</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Force&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Here we see we have random signal with a sharp cutoff in the frequency domain.
We have 4 signals, one for each force location.</p>
<a class="reference internal image-reference" href="../_images/Airplane_Random_Excitation.png"><img alt="Random signals used to excite the modal test" src="../_images/Airplane_Random_Excitation.png" style="width: 600px;" /></a>
<p>We will again do integration of our test system using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.time_integrate</span></code></a>
function, and we will then downsample the resulting data to our test bandwidth.
We can again pass the reference and response data into the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data" title="sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray.from_time_data</span></code></a>
function to compute FRFs.  Note that because we now have random data, we will
use a window function and apply an overlap.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now let&#39;s run the modal test</span>
<span class="n">responses_modal</span><span class="p">,</span><span class="n">references_modal</span> <span class="o">=</span> <span class="n">test_system</span><span class="o">.</span><span class="n">time_integrate</span><span class="p">(</span>
        <span class="n">random_forces</span><span class="p">,</span><span class="n">dt</span><span class="p">,</span><span class="n">references</span><span class="o">=</span><span class="n">drive_points</span><span class="p">)</span>

<span class="c1"># Now let&#39;s downsample to the actual measurement (removing the 10x integration</span>
<span class="c1"># oversample)</span>
<span class="n">responses_sampled</span> <span class="o">=</span> <span class="n">responses_modal</span><span class="o">.</span><span class="n">extract_elements</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">integration_oversample</span><span class="p">))</span>
<span class="n">references_sampled</span> <span class="o">=</span> <span class="n">references_modal</span><span class="o">.</span><span class="n">extract_elements</span><span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="n">integration_oversample</span><span class="p">))</span>

<span class="c1"># Compute FRFs.</span>
<span class="n">frf_sampled</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">TransferFunctionArray</span><span class="o">.</span><span class="n">from_time_data</span><span class="p">(</span>
    <span class="n">references_sampled</span><span class="p">,</span><span class="n">responses_sampled</span><span class="p">,</span><span class="n">samples_per_frame</span><span class="o">//</span><span class="n">integration_oversample</span><span class="p">,</span>
    <span class="n">overlap</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Since we now have a large number of FRFs, it can be
difficult to visualize them all simultaneously, so we will use SDynpy’s
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> to allow us to quickly
look through all the functions to ensure they look right.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now let&#39;s use GUIPlot to look at the functions</span>
<span class="n">plotter</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">GUIPlot</span><span class="p">(</span><span class="n">frf_sampled</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_gui_plot.png"><img alt="Drive points used for a MIMO modal test." src="../_images/airplane_gui_plot.png" style="width: 600px;" /></a>
</section>
<section id="fitting-modes-using-polymax">
<h2><a class="toc-backref" href="#id30">Fitting Modes using PolyMax</a><a class="headerlink" href="#fitting-modes-using-polymax" title="Permalink to this heading"></a></h2>
<p>Now that we have frequency response functions created, we can fit modes to them.
SDynPy has two mode fitters implemented,
<code class="xref py py-class docutils literal notranslate"><span class="pre">PolyMax</span></code> and
<a class="reference internal" href="../_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC</span></code></a>.  Both curve fitters can
be used via graphical user interface or via Python commands if it is desirable
to automate the curve fitting.  This example will use the
<code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.PolyMax_GUI</span></code> approach.</p>
<section id="running-polymax">
<h3><a class="toc-backref" href="#id31">Running PolyMax</a><a class="headerlink" href="#running-polymax" title="Permalink to this heading"></a></h3>
<p>We open the PolyMax GUI by initializing the
<code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.PolyMax_GUI</span></code> class
with our frequency response function dataset <code class="docutils literal notranslate"><span class="pre">frf_sampled</span></code></p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now that we have FRFs we can go fit modes.  We will first look at using</span>
<span class="c1"># PolyMax</span>
<span class="n">pm</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">PolyMax_GUI</span><span class="p">(</span><span class="n">frf_sampled</span><span class="p">)</span>
</pre></div>
</div>
<p>The initial screen shows mode indicator functions, as well as options for
computing the initial stabilization diagram.  We can see from the shown
Complex Mode Indicator function that there are a few instances of closely-spaced
modes.  We can drag the frequency region on the figure to select the frequency
range of interest, set the polynomial orders, and press the button to compute
the stabilization curve.</p>
<a class="reference internal image-reference" href="../_images/airplane_polymax_stabilization.png"><img alt="Setting up parameters to compute the stabilization plot in PolyMax" src="../_images/airplane_polymax_stabilization.png" style="width: 600px;" /></a>
<p>Once the stabilization plot is computed, stable poles can be selected by
clicking on them in the stabilization plot.  Once all poles are selected,
shapes can be computed.</p>
<a class="reference internal image-reference" href="../_images/airplane_polymax_stabilization_selection.png"><img alt="Selecting poles on the stabilization plot in PolyMax" src="../_images/airplane_polymax_stabilization_selection.png" style="width: 600px;" /></a>
<p>The final tab of the PolyMax implementation allows you to see how well the
modes fit to the measured frequency response data.  On this page, modes can be
saved to a file.</p>
<a class="reference internal image-reference" href="../_images/airplane_polymax_stabilization_resynthesis.png"><img alt="Visualizing the modal fits in PolyMax" src="../_images/airplane_polymax_stabilization_resynthesis.png" style="width: 600px;" /></a>
</section>
<section id="comparing-test-and-finite-element-modes">
<h3><a class="toc-backref" href="#id32">Comparing Test and Finite Element Modes</a><a class="headerlink" href="#comparing-test-and-finite-element-modes" title="Permalink to this heading"></a></h3>
<p>Once modes are fit in the GUI and saved to disk, we can load them back into our
analysis.  We initially compute a Modal Assurance Criterion matrix between the
fit shapes and our finite element shapes to compare the results.  We can also
print a shape comparison table obtained by the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.shape_comparison_table.html#sdynpy.core.sdynpy_shape.shape_comparison_table" title="sdynpy.core.sdynpy_shape.shape_comparison_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.shape_comparison_table</span></code></a>
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># In the PolyMax GUI we saved the shapes to disk, so we will now load them.</span>
<span class="n">test_shapes_polymax</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;shapes_polymax.npy&#39;</span><span class="p">)</span>

<span class="c1"># Let&#39;s compare the shapes to the finite element model shapes</span>
<span class="n">mac</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">mac</span><span class="p">(</span><span class="n">test_shapes</span><span class="p">,</span><span class="n">test_shapes_polymax</span><span class="p">)</span>
<span class="n">sdpy</span><span class="o">.</span><span class="n">correlation</span><span class="o">.</span><span class="n">matrix_plot</span><span class="p">(</span>
    <span class="n">mac</span><span class="p">,</span><span class="n">text_size</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="n">shape_correspondences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mac</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="n">shape_1</span> <span class="o">=</span> <span class="n">test_shapes_polymax</span><span class="p">[</span><span class="n">shape_correspondences</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
<span class="n">shape_2</span> <span class="o">=</span> <span class="n">test_shapes</span><span class="p">[</span><span class="n">shape_correspondences</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
<span class="nb">print</span><span class="p">(</span><span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">shape_comparison_table</span><span class="p">(</span><span class="n">shape_1</span><span class="p">,</span> <span class="n">shape_2</span><span class="p">,</span>
                                        <span class="n">percent_error_format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:0.4f}</span><span class="s1">%&#39;</span><span class="p">))</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_test_vs_fem_mac.png"><img alt="MAC between fit shapes and FEM shapes" src="../_images/airplane_test_vs_fem_mac.png" style="width: 600px;" /></a>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">Mode  Freq 1 (Hz)  Freq 2 (Hz)  Freq Error  Damp 1  Damp 2  Damp Error  MAC</span>
<span class="go">   1         6.00         6.00    -0.0067%   2.36%   2.00%    17.9820%  100</span>
<span class="go">   2        13.40        13.40     0.0218%   2.06%   2.00%     2.9605%  100</span>
<span class="go">   3        30.59        30.60    -0.0458%   2.01%   2.00%     0.4512%  100</span>
<span class="go">   4        30.73        30.74    -0.0344%   2.01%   2.00%     0.4827%   99</span>
<span class="go">   5        31.73        31.73     0.0077%   1.99%   2.00%    -0.7148%  100</span>
<span class="go">   6        33.31        33.31     0.0025%   1.99%   2.00%    -0.3471%  100</span>
<span class="go">   7        39.02        39.01     0.0114%   1.98%   2.00%    -1.0855%  100</span>
<span class="go">   8        46.78        46.77     0.0156%   1.97%   2.00%    -1.4382%   99</span>
<span class="go">   9        47.28        47.27     0.0189%   2.00%   2.00%    -0.0342%  100</span>
<span class="go">  10        57.49        57.49    -0.0003%   2.00%   2.00%     0.1664%  100</span>
<span class="go">  11        66.02        66.02     0.0012%   2.00%   2.00%    -0.0377%  100</span>
<span class="go">  12        75.28        75.28    -0.0000%   2.00%   2.00%     0.0906%  100</span>
<span class="go">  13        92.58        92.58    -0.0026%   2.00%   2.00%     0.1076%  100</span>
<span class="go">  14        95.39        95.40    -0.0078%   2.00%   2.00%     0.1584%  100</span>
<span class="go">  15        97.19        97.20    -0.0061%   1.99%   2.00%    -0.3016%  100</span>
<span class="go">  16        99.94        99.94    -0.0013%   2.00%   2.00%    -0.1005%  100</span>
<span class="go">  17       107.30       107.30    -0.0018%   2.00%   2.00%     0.1139%  100</span>
<span class="go">  18       138.97       138.96     0.0065%   1.99%   2.00%    -0.5165%  100</span>
<span class="go">  19       140.82       140.81     0.0016%   2.01%   2.00%     0.3194%  100</span>
<span class="go">  20       142.06       142.04     0.0097%   2.00%   2.00%     0.2438%   99</span>
<span class="go">  21       148.12       148.13    -0.0045%   2.01%   2.00%     0.3527%  100</span>
<span class="go">  22       158.70       158.70     0.0005%   2.01%   2.00%     0.2717%  100</span>
<span class="go">  23       164.16       164.15     0.0063%   2.00%   2.00%     0.1195%  100</span>
<span class="go">  24       172.71       172.68     0.0183%   1.98%   2.00%    -0.8317%   98</span>
<span class="go">  25       172.99       172.96     0.0171%   1.98%   2.00%    -0.8663%   99</span>
<span class="go">  26       183.52       183.53    -0.0042%   1.98%   2.00%    -1.1180%  100</span>
</pre></div>
</div>
<p>Another way to compare shapes is to overlay them.  This is easily done within
SDynPy using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.overlay_shapes" title="sdynpy.core.sdynpy_shape.ShapeArray.overlay_shapes"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.overlay_shapes</span></code></a>
function.  The output of this function is a “combined” geometry and “combined”
shape.  The nodes, coordinate systems, elements, and tracelines are all combined
into one geometry, and the id values of each of these elements is offset to
avoid conflicts.  The shape degrees of freedom are also concatenated and offset
similarly to produce the appropriate shape visualization.</p>
<p>Note that our test shapes might be 180 degrees out of phase with the
finite element model shapes, so we will first compute the dot product between
the two sets of shapes and flip the sign on any shape where the dot product is
negative.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compare shapes visually.  First we need to get the correct flipping in case</span>
<span class="c1"># the shapes are 180 out of phase</span>
<span class="n">shape_phasing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,ij-&gt;i&#39;</span><span class="p">,</span><span class="n">shape_1</span><span class="o">.</span><span class="n">shape_matrix</span><span class="p">,</span><span class="n">shape_2</span><span class="o">.</span><span class="n">shape_matrix</span><span class="p">))</span>
<span class="n">shape_1</span> <span class="o">=</span> <span class="n">shape_1</span><span class="o">*</span><span class="n">shape_phasing</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

<span class="c1"># Plot on the test geometry</span>
<span class="n">test_comparison_geometry</span><span class="p">,</span><span class="n">test_comparison_shapes</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">overlay_shapes</span><span class="p">(</span>
    <span class="p">(</span><span class="n">test_geometry</span><span class="p">,</span><span class="n">test_geometry</span><span class="p">),(</span><span class="n">shape_1</span><span class="p">,</span><span class="n">shape_2</span><span class="p">),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">test_comparison_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">test_comparison_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>
<span class="c1"># Plot on the fem geometry</span>
<span class="n">fem_comparison_geometry</span><span class="p">,</span><span class="n">fem_comparison_shapes</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">overlay_shapes</span><span class="p">(</span>
    <span class="p">(</span><span class="n">test_geometry</span><span class="p">,</span><span class="n">geometry_global</span><span class="p">),(</span><span class="n">shape_1</span><span class="p">,</span><span class="n">shapes_global</span><span class="p">[</span><span class="n">shape_correspondences</span><span class="p">[</span><span class="mi">0</span><span class="p">]]),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">fem_comparison_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">fem_comparison_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">,</span>
                                   <span class="n">deformed_opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">undeformed_opacity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_shape_overlay_test.gif"><img alt="Overlay of test and FEM shape on test geometry" src="../_images/airplane_shape_overlay_test.gif" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../_images/airplane_shape_overlay_fem.gif"><img alt="Overlay of test and FEM shape on FEM" src="../_images/airplane_shape_overlay_fem.gif" style="width: 600px;" /></a>
</section>
</section>
<section id="serep-expansion">
<h2><a class="toc-backref" href="#id33">SEREP Expansion</a><a class="headerlink" href="#serep-expansion" title="Permalink to this heading"></a></h2>
<p>Often times, the “stick” test geometry can be insufficient for communicating
results to test stakeholders, particularly when there are only uniaxial
sensors on the test.  Among other things, the System Equivalent Reduction
Expansion Process (SEREP) can be useful for expanding data at test sensors out
to the full finite element space for better visualization.  SDynPy makes it
easy to perform SEREP using the
<a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.expand" title="sdynpy.core.sdynpy_shape.ShapeArray.expand"><code class="xref py py-func docutils literal notranslate"><span class="pre">ShapeArray.expand</span></code></a> method.
Particularly in this case where we have kept the test geometry node IDs
equivalent to the original finite element node IDs, the expansion bookkeeping
is handled automatically.</p>
<p>We first need to create the set of shapes to use to expand the test shapes.
These will be the finite element shapes in the test bandwidth.  We then call
the <a class="reference internal" href="../_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.expand" title="sdynpy.core.sdynpy_shape.ShapeArray.expand"><code class="xref py py-func docutils literal notranslate"><span class="pre">ShapeArray.expand</span></code></a>
method, giving it the test geometry, finite element geometry, and expansion
basis shapes.  Note here that the global shapes and global geometry are used
in the expansion.  All coordinate transformations between the local test geometry
and global finite element geometry are handled automatically by SDynPy.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Perform the expansion using the finite element shapes in the bandwidth</span>
<span class="n">expansion_basis</span> <span class="o">=</span> <span class="n">shapes_global</span><span class="p">[</span><span class="n">shapes_global</span><span class="o">.</span><span class="n">frequency</span> <span class="o">&lt;</span> <span class="n">shape_bandwidth</span><span class="p">]</span>
<span class="n">expanded_shapes</span> <span class="o">=</span> <span class="n">test_shapes_polymax</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">test_geometry</span><span class="p">,</span><span class="n">geometry_global</span><span class="p">,</span>
                                             <span class="n">expansion_basis</span><span class="p">)</span>
<span class="c1"># We can then plot the expanded shapes on the original finite element geometry</span>
<span class="n">geometry_global</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">expanded_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">)</span>

<span class="c1"># Or overlay the geometries and shapes</span>
<span class="n">expansion_comparison_geometry</span><span class="p">,</span><span class="n">expansion_comparison_shapes</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">overlay_shapes</span><span class="p">(</span>
    <span class="p">(</span><span class="n">test_geometry</span><span class="p">,</span><span class="n">geometry_global</span><span class="p">),(</span><span class="n">test_shapes_polymax</span><span class="p">,</span><span class="n">expanded_shapes</span><span class="p">),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="n">expansion_comparison_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">expansion_comparison_shapes</span><span class="p">,</span><span class="n">plot_options</span><span class="p">,</span>
                                         <span class="n">deformed_opacity</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span><span class="n">undeformed_opacity</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<a class="reference internal image-reference" href="../_images/airplane_serep_expansion.gif"><img alt="Expanded test shapes on the shape on FEM" src="../_images/airplane_serep_expansion.gif" style="width: 600px;" /></a>
<a class="reference internal image-reference" href="../_images/airplane_serep_expansion_overlay.gif"><img alt="Overlay of test and expanded test shape on FEM" src="../_images/airplane_serep_expansion_overlay.gif" style="width: 600px;" /></a>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../examples.html" class="btn btn-neutral float-left" title="SDynpy Examples" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="rattlesnake_demonstration.html" class="btn btn-neutral float-right" title="Rattlesnake Demonstration" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2022 National Technology &amp; Engineering Solutions of Sandia,     LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS,     the U.S. Government retains certain rights in this software.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>