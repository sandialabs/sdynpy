<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modal Tutorial 06: Complex Modes &mdash; SDynPy 0.14.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/nbsphinx-code-cells.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script src="../../_static/clipboard.min.js"></script>
        <script src="../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="SDynPy Programming Interface" href="../../modules.html" />
    <link rel="prev" title="Modal Tutorial 05 Part F: Comparing Test and Analysis" href="../Modal_05_Experimental_Modal_Analysis/Modal_05f_Comparing_Test_and_Analysis.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html">
            
              <img src="../../_static/logo_horizontal_light.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../sdynpy_showcase.html">SDynPy Showcase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples.html">SDynpy Examples</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../modal_tutorials.html">Modal Tutorials</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../Modal_01_What_is_Modal_Analysis/Modal_01_What_is_Modal_Analysis.html">Modal Tutorial 01: What is modal analysis?</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Modal_02_Basics_of_Vibrations/Modal_02_Basics_of_Vibrations.html">Modal Tutorial 02: Basics of Vibrations</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Modal_03_Multi_DoF_Vibrations/Modal_03_Multi_DoF_Vibrations.html">Modal Tutorial 03: Vibrations of Systems with Multiple Degrees of Freedom</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Modal_04_Modal_Analysis/Modal_04_Modal_Analysis.html">Modal Tutorial 04: Modal Analysis</a></li>
<li class="toctree-l2"><a class="reference internal" href="../Modal_05_Experimental_Modal_Analysis/Modal_05_Experimental_Modal_Analysis.html">Modal Tutorial 05: Experimental Modal Analysis</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Modal Tutorial 06: Complex Modes</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#The-Second-Order,-Linear-Differential-System-of-Equations">The Second-Order, Linear Differential System of Equations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Real-Modes----Damping-is-Hard">Real Modes – Damping is Hard</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Geometric-Interpretation-of-the-Eigenvalues-and-Eigenvectors">Geometric Interpretation of the Eigenvalues and Eigenvectors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#An-Infinite-Number-of-Mode-Shapes">An Infinite Number of Mode Shapes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Units-with-Scaled-Mode-Shapes">Units with Scaled Mode Shapes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Adding-Damping">Adding Damping</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Complex-Modes----The-General-Solution">Complex Modes – The General Solution</a></li>
<li class="toctree-l3"><a class="reference internal" href="#An-Example-Problem">An Example Problem</a></li>
<li class="toctree-l3"><a class="reference internal" href="#Frequency-Response-Functions-and-Modal-Parameters">Frequency Response Functions and Modal Parameters</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Real-Modes">Real Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Complex-Modes">Complex Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#What-are-Real-Modes-in-the-Complex-Mode-Framework?">What are Real Modes in the Complex Mode Framework?</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Back-to-our-Example-Problem">Back to our Example Problem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Solving-for-Modal-Parameters-from-FRFs">Solving for Modal Parameters from FRFs</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Setting-up-the-System-of-Equations">Setting up the System of Equations</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Selecting-Coefficients-that-Minimize-Errors">Selecting Coefficients that Minimize Errors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Solving-the-Constrained-Problem">Solving the Constrained Problem</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Extracting-Poles-and-Participation-Factors">Extracting Poles and Participation Factors</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Stabilization-Diagrams">Stabilization Diagrams</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Back-to-the-Example-Problem">Back to the Example Problem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Fitting-Mode-Shapes-to-FRF-Data">Fitting Mode Shapes to FRF Data</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#Fitting-Residuals-for-Out-of-Band-Modes">Fitting Residuals for Out-of-Band Modes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#A-Note-on-Types-of-FRFs">A Note on Types of FRFs</a></li>
<li class="toctree-l4"><a class="reference internal" href="#Normalizing-Mode-Shapes">Normalizing Mode Shapes</a></li>
<li class="toctree-l4"><a class="reference internal" href="#id1">Back to the Example Problem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#Summary">Summary</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../modules.html">SDynPy Programming Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">SDynPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../modal_tutorials.html">Modal Tutorials</a></li>
      <li class="breadcrumb-item active">Modal Tutorial 06: Complex Modes</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/modal_tutorials/Modal_06_Complex_Modes/Modal_06_Complex_Modes.ipynb.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="Modal-Tutorial-06:-Complex-Modes">
<h1>Modal Tutorial 06: Complex Modes<a class="headerlink" href="#Modal-Tutorial-06:-Complex-Modes" title="Permalink to this heading"></a></h1>
<p>Complex modes can be unintuitive and difficult to understand compared to real normal modes. George Fox Lang wrote an article in Sound and Vibration magazine called “Matrix Madness and Complex Confusion… A Review of Complex Modes from Multiple Viewpoints.” He states:</p>
<blockquote>
<div><p>Complex Modes is one of those topics that every vibration practitioner understands – just not fully.</p>
</div></blockquote>
<p>The author of this document agrees with Lang; in fact, his own lack of knowledge of complex modes is what caused him to write this document, to teach himself what is going on!</p>
<p>To better understand complex modes, we will start from the differential equations of motion and develop the theory of complex modes, discussing:</p>
<ul class="simple">
<li><p>Real Modes and their Limitations</p></li>
<li><p>The state space transformation to derive the complex mode eigenvalue problem</p></li>
<li><p>Computing natural frequency, damping, and complex mode shapes</p></li>
<li><p>Computing FRFs from the modal parameters</p></li>
</ul>
<p>This document will largely follow the equations from the following sources:</p>
<ul class="simple">
<li><p><a class="reference external" href="https://doi.org/10.1016/j.ymssp.2023.110621">An engineering interpretation of the complex modal mass in structural dynamics by Lopez and Brinckner</a></p></li>
<li><p><a class="reference external" href="http://www.sandv.com/downloads/1211lang.pdf">Matrix Madness and Complex Confusion… A Review of Complex Modes from Multiple Viewpoints by Lang</a></p></li>
<li><p><a class="reference external" href="https://content.iospress.com/articles/shock-and-vibration/sav00272">The PolyMAX Frequency-domain Method: a New Standard for Modal Parameter Estimation? by Peeters, et al.</a></p></li>
</ul>
<section id="The-Second-Order,-Linear-Differential-System-of-Equations">
<h2>The Second-Order, Linear Differential System of Equations<a class="headerlink" href="#The-Second-Order,-Linear-Differential-System-of-Equations" title="Permalink to this heading"></a></h2>
<p>Most vibration engineers are familiar with the standard system of second-order, linear differential equations.</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}\ddot{\mathbf{x}} + \mathbf{C}\dot{\mathbf{x}} + \mathbf{K}{\mathbf{x}} = \mathbf{F}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is the system mass matrix, <span class="math notranslate nohighlight">\(\mathbf{C}\)</span> is the system damping matrix, <span class="math notranslate nohighlight">\(\mathbf{K}\)</span> is the system stiffness matrix, <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> is the forcing applied to the system, and <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is the system displacement response. <span class="math notranslate nohighlight">\(\dot{\mathbf{x}}\)</span> and <span class="math notranslate nohighlight">\(\ddot{\mathbf{x}}\)</span> represent the first and second derivatives of the response, velocity and acceleration, respectively.</p>
<p>For a standard linear, time-invariant (LTI) system, the mass, stiffness matrices are not functions of time (i.e. the mass of the system doesn’t change). However, the forces and responses are generally a function of time.</p>
</section>
<section id="Real-Modes----Damping-is-Hard">
<h2>Real Modes – Damping is Hard<a class="headerlink" href="#Real-Modes----Damping-is-Hard" title="Permalink to this heading"></a></h2>
<p>Many times, when we are just starting out, we will simply ignore the damping in our part because it is “hard” or it doesn’t fit with our elegant mathematical tools.</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}\ddot{\mathbf{x}} + \mathbf{K}{\mathbf{x}} = \mathbf{F}\]</div>
<p>To try to understand the free vibration response of the this system, we can make the following assumptions:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\mathbf{F} = \mathbf{0}\)</span> – There is no force on the system.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{x} = \mathbf{\phi}\cos(\omega t)\)</span> – The response of the system looks like some shape <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> that will vibrate over time (represented mathematically by multiplying by a cosine function), and the vibration will have a frequency of <span class="math notranslate nohighlight">\(\omega\)</span> radians per second.</p></li>
</ul>
<p>Using the chain rule for differentiation, it follows that <span class="math notranslate nohighlight">\(\ddot{\mathbf{x}} = -\omega^2\mathbf{\phi}\cos(\omega t)\)</span></p>
<p>We can substitute these equations into the previous equation to arrive at an equation in the form of the well-known <a class="reference external" href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Generalized_eigenvalue_problem">Generalized Eigenvalue Problem</a>.</p>
<p>First we make the substitutions.</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}(-\omega^2\mathbf{\phi}\cos(\omega t)) + \mathbf{K}\mathbf{\phi}\cos(\omega t) = \mathbf{0}\]</div>
<p>We can then recognize that the term <span class="math notranslate nohighlight">\(\cos(\omega t))\)</span> is in general nonzero so can be cancelled.</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}(-\omega^2\mathbf{\phi}) + \mathbf{K}\mathbf{\phi} = \mathbf{0}\]</div>
<p>We can then add <span class="math notranslate nohighlight">\(\omega^2\mathbf{M}\mathbf{\phi}\)</span> to both sides of the equation.</p>
<div class="math notranslate nohighlight">
\[\mathbf{K}\mathbf{\phi} = \omega^2\mathbf{M}\mathbf{\phi}\]</div>
<p>This is now the same form of the <a class="reference external" href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Generalized_eigenvalue_problem">Generalized Eigenvalue Problem</a>, which is <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{v} = \lambda\mathbf{B}\mathbf{v}\)</span>.</p>
<p>Here it can help to further rearrange the equation by premultiplying by the inverse of the mass matrix <span class="math notranslate nohighlight">\(\mathbf{M}^{-1}\)</span>. Note that this is generally acceptable to do, because the mass matrix should generally be positive definite and therefore invertable (said another way, every degree of freedom in the system has mass associated with it).</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}^{-1}\mathbf{K}\mathbf{\phi} = \omega^2\mathbf{\phi}\]</div>
<section id="Geometric-Interpretation-of-the-Eigenvalues-and-Eigenvectors">
<h3>Geometric Interpretation of the Eigenvalues and Eigenvectors<a class="headerlink" href="#Geometric-Interpretation-of-the-Eigenvalues-and-Eigenvectors" title="Permalink to this heading"></a></h3>
<p>We can gain intuition here by thinking about what the eigenvalue problem means <em>geometrically</em>. We have a vector <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> that represents some shape. Looking at the right side of the equation, if we multiply that vector by a scalar <span class="math notranslate nohighlight">\(\omega^2\)</span>, it will simply scale the length of the vector, but not change its direction in which it’s pointing. In the context of a vibration shape, this means that it will scale the shape larger or smaller, but it won’t change the shape of
vibration. You get a bigger or smaller vibration with the same shape.</p>
<p>Now because of the equality, the left-hand side of the equation must be equivalent to the right-hand side of the equation, which means that the left-hand side must also be equivalent to simply scaling the original vector <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span>. However, we know from linear algebra that multiplying a vector by a matrix will in general change the length of the vector <em>and</em> where the vector is pointing. In the context of our vibration shape <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span>, this means that multiplying a
vibration shape by a matrix will in general change not only the size of the vibration shape, but the shape itself.</p>
<p>Let’s look at a brief example to illustrate this point.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

<span class="c1"># Set random seed so we can get repeatable results for the documentation.</span>
<span class="c1"># Remove this line to allow the matrices and vectors to be random.</span>
<span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">seed</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

<span class="c1"># Create a vector to test</span>
<span class="n">vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">],</span>
                   <span class="p">[</span><span class="mi">2</span><span class="p">]])</span>

<span class="c1"># Now create a random scalar</span>
<span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">()</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scalar:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">scalar</span><span class="p">)</span>

<span class="c1"># Now create a random matrix</span>
<span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Matrix:&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>

<span class="c1"># Now multiply the vector by the scalar, and multiply the vector by the matrix</span>
<span class="n">vector_scalar</span> <span class="o">=</span> <span class="n">scalar</span><span class="o">*</span><span class="n">vector</span>
<span class="n">vector_matrix</span> <span class="o">=</span> <span class="n">matrix</span><span class="nd">@vector</span> <span class="c1"># Matrix multiplication is @ in numpy.</span>

<span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">5</span><span class="p">),</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="o">*</span><span class="n">vector</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="o">*</span><span class="n">vector_scalar</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Multiply Vector by Scalar&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="o">*</span><span class="n">vector</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="o">*</span><span class="n">vector_matrix</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Original Vector&#39;</span><span class="p">,</span><span class="s1">&#39;Modified Vector&#39;</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Multiply Vector by Matrix&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Scalar:
0.5507979025745755
Matrix:
[[0.70814782 0.29090474]
 [0.51082761 0.89294695]]
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_4_1.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_4_1.png" />
</div>
</div>
<p>Clearly, multiplying by a scalar has resulted in a vector with the same direction and a different length, whereas multiplying by a matrix has changed not only the length, but also the direction of the vector.</p>
<p>The resulting direction of the vector will not only be dependent on the matrix that it is multiplied by, but also the original vector itself. Multiplying different vectors by the same matrix will generally result in a different final direction of the resulting vectors. We can investigate this by multiplying many different vectors by the matrix from the previous step.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Here we make a 20x20 grid of 2x1 vectors that we can multiply by our matrix</span>
<span class="n">vectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">20</span><span class="n">j</span><span class="p">,</span><span class="o">-</span><span class="mi">3</span><span class="p">:</span><span class="mi">3</span><span class="p">:</span><span class="mi">20</span><span class="n">j</span><span class="p">][</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

<span class="n">scaled_vectors</span> <span class="o">=</span> <span class="n">matrix</span> <span class="o">@</span> <span class="n">vectors</span>

<span class="c1"># Reshape for easier plotting</span>
<span class="n">vectors_for_plotting</span> <span class="o">=</span> <span class="n">vectors</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">scaled_vectors_for_plotting</span> <span class="o">=</span> <span class="n">scaled_vectors</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="o">*</span><span class="n">vectors_for_plotting</span><span class="p">,</span> <span class="o">*</span><span class="n">vectors_for_plotting</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;blue&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">quiver</span><span class="p">(</span><span class="o">*</span><span class="n">vectors_for_plotting</span><span class="p">,</span> <span class="o">*</span><span class="n">scaled_vectors_for_plotting</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;red&#39;</span><span class="p">,</span> <span class="n">angles</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale_units</span><span class="o">=</span><span class="s1">&#39;xy&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Original Vector&#39;</span><span class="p">,</span><span class="s1">&#39;Multiplied Vector&#39;</span><span class="p">]);</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_6_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_6_0.png" />
</div>
</div>
<p>Clearly, we can see that in general, vectors in different directions will be modified by the matrix differently. However, looking closely at the above plot, we can see that there are vectors in particular directions that maintain their original direction after multiplication by the matrix (a change in length is acceptable). And if you recall, we are looking for exactly such a vector that when multiplied by a matrix retains its direction. Therefore, in order to solve the eigenvalue equation
listed previously, we need to find these special directions. We can’t just use any shape <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span>. We have to find particular shapes <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> that when multiplied by the system matrices <span class="math notranslate nohighlight">\(\mathbf{M}^{-1}\mathbf{K}\)</span> do not change shape but perhaps get bigger or smaller. Mathematically, we call these vectors the <em>eigenvectors</em> where the prefix <em>eigen</em> is German for <em>particular</em>. In structural dynamics, we call these particular shapes the <em>mode shapes</em>, and they have
many special properties.</p>
<p>Similarly, we call the scalar quantity <span class="math notranslate nohighlight">\(\omega^2\)</span> that gets multiplied by the eigenvector the <em>eigenvalue</em>. It is the particular value that goes along with the particular vector. We will generally have as many eigenvector/eigenvalue pairs as we have degrees of freedom in the system.</p>
<p>We note that there are linear algebra tools available to solve for the eigenvalues and eigenvectors of a given matrix. For example, in Numpy, we can use <code class="docutils literal notranslate"><span class="pre">np.linalg.eig</span></code>. We can then plot the eigenvector directions on the above figure to show that they indeed align with the directions where the vectors are scaled but the direction does not change. Note also that there are two degrees of freedom in this problem, so we find two eigenvectors, or two directions where the direction of the vectors do
not change.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">eigenvalues</span><span class="p">,</span> <span class="n">eigenvectors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">matrix</span><span class="p">)</span>
<span class="c1"># Plot the positive and negative eigenvectors so it looks like a line through the origin</span>
<span class="c1"># Also reshape them so they are easier to plot</span>
<span class="c1"># Multiply by 4 so they take up the whole plot</span>
<span class="n">eigenvectors_to_plot</span> <span class="o">=</span> <span class="mi">4</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">eigenvectors</span><span class="p">,</span><span class="o">-</span><span class="n">eigenvectors</span><span class="p">))</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="o">*</span><span class="n">eigenvectors_to_plot</span><span class="p">,</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">([</span><span class="o">-</span><span class="mi">3</span><span class="p">,</span><span class="mi">3</span><span class="p">])</span>
<span class="n">fig</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_8_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_8_0.png" />
</div>
</div>
<p>We see that vectors that are along the directions represented by the eigenvectors do not change direction, only change scale.</p>
<p>Without approximation or loss of generality, we can take <em>all</em> of the eigenvectors or mode shapes of a system as column vectors and <em>stack</em> them side-by-side to form a matrix. This matrix forms a coordinate transformation: in the same way we can transform between a local and global coordinate system, we can also transform between <em>physical</em> and <em>modal</em> degrees of freedom. Physical degrees of freedom are generally represented by some physical quantity (e.g., Point 1 moves 2.5 centimeters in the
vertical direction). Modal degrees of freedom are generally represented by some <em>modal degree of freedom</em> or <em>modal quantity</em>. Motions are then represented by how much of each mode shape is present in the motion (e.g., the system moves with a shape that looks like mode shape 1 scaled up by a factor of 2, plus mode shape 2 scaled down by a factor of 1/2). We can represent this mathematically by saying physical motions <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> are represented by a linear combination of shapes
<span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span>. We call the coefficient matrix <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> the <em>modal coefficients</em> or <em>modal degrees of freedom</em>, because they describe how much of each mode shape in <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> is present in <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{x} = \mathbf{\phi}\mathbf{q}\]</div>
<p>We can substitute this transformation into our original undamped equations of motion to get equations of motion in terms of the modal degrees of freedom <span class="math notranslate nohighlight">\(\mathbf{q}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}\mathbf{\phi}\ddot{\mathbf{q}} + \mathbf{K}\mathbf{\phi}{\mathbf{q}} = \mathbf{F}\]</div>
<p>We note that the mode shapes <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> are invariant in time, (they are a function of the matrices <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{K}\)</span>, which are also invariant in time). Therefore taking the derivative of the physical response <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> is simply</p>
<div class="math notranslate nohighlight">
\[\ddot{\mathbf{x}} = \mathbf{\phi}\ddot{\mathbf{q}}\]</div>
<p>While the transformed equation above is technically valid, we generally do not like this form, because it breaks the symmetry of the mass and stiffness matrices. For all real structures, the mass, stiffness, and damping matrices should be symmetric. This is a function of Netwton’s third law of equal and opposite reactions: if there is a force developing at degree of freedom 1 due to motion of degree of freedom 2, an equal and opposite force will develop on degree of freedom 2 due to degree of
freedom 1 pushing back on it. Currently, however, in our transformed equations of motion, the new effective mass matrix <span class="math notranslate nohighlight">\(\mathbf{M}\mathbf{\phi}\)</span> is not symmetric, nor is the equivalent effective stiffness matrix. We therefore premultiply the equations of motion by <span class="math notranslate nohighlight">\(\mathbf{\phi}^T\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\ddot{\mathbf{q}} + \mathbf{\phi}^T\mathbf{K}\mathbf{\phi}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<p>In this final format, the effective mass and stiffness matrices <span class="math notranslate nohighlight">\(\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{\phi}^T\mathbf{K}\mathbf{\phi}\)</span> are symmetric. We will often make a substitution</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{M}}=\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\]</div>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{K}}=\mathbf{\phi}^T\mathbf{K}\mathbf{\phi}\]</div>
<p>where <span class="math notranslate nohighlight">\(\tilde{\mathbf{M}}\)</span> and <span class="math notranslate nohighlight">\(\tilde{\mathbf{K}}\)</span> are referred to as the <em>modal mass</em> and <em>modal stiffness</em> matrices. The modal system of equations is then</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{M}}\ddot{\mathbf{q}} + \tilde{\mathbf{K}}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<p>The symmetry of the system matrices is not the only interesting property when we transform into modal coordinates. It turns out that the mode shapes <span class="math notranslate nohighlight">\(\mathbf{\phi}\)</span> <em>diagonalize</em> the mass and stiffness matrices. The modal mass and stiffness matrices, formed by pre- and post-multiplying the mass and stiffness matrices by the mode shapes, are diagonal. This physically means that there is no coupling between modal degrees of freedom; the response of mode 1 does not depend at all on the
response of mode 2. They can be treated as entirely separate equations. Compare this to a physical mass and stiffness matrix, where there would be coupling between the degrees of freedom.</p>
<p>We can think about this concept physically. In the physical domain, if I pluck the end of a beam, all of the degrees of freedom on the beam will eventually vibrate. This is because the physical degrees of freedom are all connected to one another through the mass and stiffness of a beam. In the modal domain, however, if I pluck “mode 1” (an admittedly hard thing to accomplish in practice, as you would need to deform the beam into its first mode shape and then let it go instantaneously), none of
the other modes will be excited at all, because there is no coupling between them. Note that this still means that the entire beam will vibrate, because the mode shape of the beam contains all the beam degrees of freedom, so if the mode shape vibrates, the whole beam vibrates. In fact because the modal representation described above is exact, plucking the end of a beam will result in exactly the same beam motion regardless of whether it is represented by modal or physical degrees of freedom. The
modal transformation is simply a different way to represent a dynamic system.</p>
</section>
<section id="An-Infinite-Number-of-Mode-Shapes">
<h3>An Infinite Number of Mode Shapes<a class="headerlink" href="#An-Infinite-Number-of-Mode-Shapes" title="Permalink to this heading"></a></h3>
<p>One last concept to describe before we move on is the concept of mode shape scaling. From the previous figure, we saw that each eigenvector of a matrix mostly represented a particular direction, rather than a specific vector. Any vector in that direction would be only scaled by the matrix instead of having its direction modified. Therefore, eigenvectors are only really unique up to a scale factor. An eigenvector times a scalar is still a valid eigenvector of a matrix, so you could argue there
are an infinite number of eigenvectors of any matrix.</p>
<p>Rather than allowing for any arbitrary scaling of eigenvectors, we will often scale them to some preferred normalization. One might, for example, scale an eigenvector such that it has a length of 1, i.e. make it a unit vector. Another might, for example, scale a specific degree of freedom to 1. The most common scaling on an eigenvector, particularly in the context of structural dynamics where an eigenvector represents a mode shape, is to scale the eigenvectors such that the modal mass matrix
<span class="math notranslate nohighlight">\(\tilde{\mathbf{M}}\)</span> is equal to the identity matrix. This is known as <em>mass normalization</em>. We have already described how the modal mass matrix is diagonal. To mass-normalize a mode shape, we only need to scale the mode shape such that the diagonal entries obtained when computing the modal mass matrix end up being 1. To do this for the <span class="math notranslate nohighlight">\(r\)</span>th mode, we can simply compute the modal mass matrix with a single unscaled mode shape <span class="math notranslate nohighlight">\(\tilde{\mathbf{\phi}}_r\)</span>, then divide the mode
shapes by the square-root of the diagonal entry of the modal mass matrix corresponding to that mode shape.</p>
<div class="math notranslate nohighlight">
\[\mathbf{\phi}_r = \frac{\tilde{\mathbf{\phi}}_r}{\sqrt{{\tilde{\mathbf{\phi}}_r}^T\mathbf{M}\tilde{\mathbf{\phi}}_r}}\]</div>
<p>When we compute the modal stiffness using mass normalized modes, the entries on the diagonal of the modal stiffness matrix will be equal to the natural frequency squared. For example, for the <span class="math notranslate nohighlight">\(r\)</span>th mode shape:</p>
<div class="math notranslate nohighlight">
\[{\mathbf{\phi}_r}^T\mathbf{K}\mathbf{\phi}_r = {\omega_r}^2\]</div>
</section>
<section id="Units-with-Scaled-Mode-Shapes">
<h3>Units with Scaled Mode Shapes<a class="headerlink" href="#Units-with-Scaled-Mode-Shapes" title="Permalink to this heading"></a></h3>
<p>Note that when we mass-normalize the mode shapes, the mode shapes will have a unit of <span class="math notranslate nohighlight">\(\frac{1}{\sqrt{m}}\)</span>. The mass matrix has dimensions of <span class="math notranslate nohighlight">\(m\)</span> where <span class="math notranslate nohighlight">\(m\)</span> is the unit of mass, and to equal the dimensionless identity matrix when the modal mass matrix is assembled, the mode shape units from pre- and post-multiplying must cancel out the units of the mass matrix. The modal coefficient <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> must then have units of <span class="math notranslate nohighlight">\({l}{\sqrt{m}}\)</span> where <span class="math notranslate nohighlight">\(l\)</span> is a length
dimension, and one must recall that taking a derivative over time adds a <span class="math notranslate nohighlight">\(\frac{1}{t}\)</span> where <span class="math notranslate nohighlight">\(t\)</span> is the unit representing time.</p>
<p>As an example, we will assume we have a meter/kilogram/newton/second unit system. The modal transformation equation must have consistent units.</p>
<div class="math notranslate nohighlight">
\[\mathbf{x} = \mathbf{\phi}\mathbf{q}\]</div>
<div class="math notranslate nohighlight">
\[\left[m\right] = \left[\frac{1}{\sqrt{kg}}\right]\left[m\sqrt{kg}\right]\]</div>
<p>Similarly, the equations of motion must have consistent units.</p>
<div class="math notranslate nohighlight">
\[\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\ddot{\mathbf{q}} + \mathbf{\phi}^T\mathbf{K}\mathbf{\phi}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<div class="math notranslate nohighlight">
\[\left[\frac{1}{\sqrt{kg}}\right]\left[kg\right]\left[\frac{1}{\sqrt{kg}}\right]\left[\frac{m\sqrt{kg}}{s^2}\right] + \left[\frac{1}{\sqrt{kg}}\right]\left[\frac{N}{m}\right]\left[\frac{1}{\sqrt{kg}}\right]\left[m\sqrt{kg}\right] = \left[\frac{1}{\sqrt{kg}}\right]\left[N\right]\]</div>
<p>We can substitute <span class="math notranslate nohighlight">\(\left[N\right] = \left[\frac{kg{\,}m}{s^2}\right]\)</span></p>
<div class="math notranslate nohighlight">
\[\left[\frac{1}{\sqrt{kg}}\right]\left[kg\right]\left[\frac{1}{\sqrt{kg}}\right]\left[\frac{m\sqrt{kg}}{s^2}\right] + \left[\frac{1}{\sqrt{kg}}\right]\left[\frac{kg{\,}m}{m{\,}s^2}\right]\left[\frac{1}{\sqrt{kg}}\right]\left[m\sqrt{kg}\right] = \left[\frac{1}{\sqrt{kg}}\right]\left[\frac{kg{\,}m}{s^2}\right]\]</div>
<p>Then with a good deal of cancelling units</p>
<div class="math notranslate nohighlight">
\[\left[\frac{m\sqrt{kg}}{s^2}\right] + \left[\frac{m\sqrt{kg}}{s^2}\right] = \left[\frac{m\sqrt{kg}}{s^2}\right]\]</div>
</section>
<section id="Adding-Damping">
<h3>Adding Damping<a class="headerlink" href="#Adding-Damping" title="Permalink to this heading"></a></h3>
<p>Eventually, we will need to consider the damping values that we simply disregarded previously. If we bring back our original damped system of equations, and transform to modal space, we end up with the following equations of motion:</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}\ddot{\mathbf{x}} + \mathbf{C}\dot{\mathbf{x}} + \mathbf{K}{\mathbf{x}} = \mathbf{F}\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\ddot{\mathbf{q}} + \mathbf{\phi}^T\mathbf{C}\mathbf{\phi}\dot{\mathbf{q}} + \mathbf{\phi}^T\mathbf{K}\mathbf{\phi}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{M}}\ddot{\mathbf{q}} + \tilde{\mathbf{C}}\dot{\mathbf{q}} + \tilde{\mathbf{K}}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<p>Here the matrix <span class="math notranslate nohighlight">\(\tilde{\mathbf{C}} = \mathbf{\phi}^T\mathbf{C}\mathbf{\phi}\)</span> is referred to as the modal damping matrix.</p>
<p>The important consideration that we must make to determine if the mode shapes that we have computed are still valid mode shapes is to understand if the modal damping matrix is also diagonalized by the mode shape matrix. If it is, then our mode shapes are still valid: they represent independent, uncoupled degrees of freedom in our system. However if the modal damping matrix is not diagonal, that means there is coupling between the degrees of freedom, and the degrees of freedom represented by the
equation are not actually modal degrees of freedom.</p>
<p>The mode shapes can diagonalize the damping matrix, but only in a very limited case. Since the mode shapes only decouple the mass and stiffness matrices from which they were computed, the damping matrix will only be decoupled completely if the physical damping matrix is a linear combination of the physical mass and stiffness matrices.</p>
<div class="math notranslate nohighlight">
\[\mathbf{C} = \alpha\mathbf{M} + \beta\mathbf{K}\]</div>
<p>This is known as <em>proportional damping</em>, where the damping is proportional to the mass and stiffness of the system. Transforming to modal coordinates will diagonalize this matrix. If we do have proportional damping, and we use mass normalized modes for the modal transformation, the modal damping matrix will be diagonal, and the entry corresponding to the <span class="math notranslate nohighlight">\(r\)</span>th mode will be equal to</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{C}}_{rr} = {\mathbf{\phi}_r}^T\mathbf{C}\mathbf{\phi}_r = 2\zeta_r\omega_r = \alpha+\beta\omega_r^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega_r\)</span> is the natural frequency and <span class="math notranslate nohighlight">\(\zeta_r\)</span> is the fraction of critical damping for mode <span class="math notranslate nohighlight">\(r\)</span>.</p>
<p>We only get a diagonal modal damping matrix in this case. For any other case, we will still have off-diagonal terms. Luckily for us, these diagonal terms are often small, so using the real mode shapes derived from the mass and stiffness of the system is not a terrible approximation. However, there are cases where the approximation is not good, and in those cases, we need to turn to a different toolset to help us analyze the system.</p>
</section>
</section>
<section id="Complex-Modes----The-General-Solution">
<h2>Complex Modes – The General Solution<a class="headerlink" href="#Complex-Modes----The-General-Solution" title="Permalink to this heading"></a></h2>
<p>A more general solution to decoupling damped vibration problems requires us to rearange our equations of motion. Rather than treating the system of equations as <span class="math notranslate nohighlight">\(N\)</span> equations with a second order derivative, we will instead treat the system of equations as <span class="math notranslate nohighlight">\(2N\)</span> first-order equations using a simple introducton of a new variable <span class="math notranslate nohighlight">\(\mathbf{v} = \dot{\mathbf{x}}\)</span> to represent velocity. In this way, we can eliminate the double-derivative in the acceleration term
(<span class="math notranslate nohighlight">\(\ddot{\mathbf{x}} = \dot{\mathbf{v}}\)</span>)</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}\dot{\mathbf{v}} + \mathbf{C}\dot{\mathbf{x}} + \mathbf{K}{\mathbf{x}} = \mathbf{F}\]</div>
<p>However, we now need to add some relationship between <span class="math notranslate nohighlight">\(v\)</span> and <span class="math notranslate nohighlight">\(x\)</span>. We could simply write <span class="math notranslate nohighlight">\(\mathbf{v} = \dot{\mathbf{x}}\)</span> as we showed above. However, it will be useful to keep our matrices symmetric, so we will construct the equations in a slightly more complex way.</p>
<div class="math notranslate nohighlight">
\[\mathbf{M}\dot{\mathbf{x}} - \mathbf{M}\mathbf{v} = \mathbf{0}\]</div>
<p>We can combine these two sets of equations into one set of equations of the form <span class="math notranslate nohighlight">\(\mathbf{A}\dot{\mathbf{z}}+\mathbf{B}\mathbf{z} = \mathbf{u}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\begin{bmatrix}\dot{\mathbf{v}}\\\dot{\mathbf{x}}\end{bmatrix} + \begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}{\mathbf{v}}\\{\mathbf{x}}\end{bmatrix} = \begin{bmatrix}\mathbf{0}\\\mathbf{F}\end{bmatrix}\end{split}\]</div>
<p>Here we note that our coefficient matrices are both symmetric, the first term contains all of the derivatives, the second term contains no derivatives, and the right-hand side of the equation contains our input forces.</p>
<p>We can perform a similar operation as previous to try to understand the free response of the system. We will make the following assumptions.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\begin{bmatrix}\mathbf{0}\\\mathbf{F}\end{bmatrix} = \begin{bmatrix}\mathbf{0}\\\mathbf{0}\end{bmatrix}\)</span> – The force into the system is zero.</p></li>
<li><p><span class="math notranslate nohighlight">\(\begin{bmatrix}\mathbf{v}\\\mathbf{x}\end{bmatrix} = \begin{bmatrix}\lambda\mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}e^{\lambda t}\)</span> – The response is a complex sinusoid.</p></li>
</ul>
<p>In this case, the first assumption is essentially identical to the first assumption in the real mode shape case. The second assumption is essentially a complex generalization of the second assumption made in the real mode shape case. In this generalization, instead of a “real” shape where all responses are either in-phase or 180<span class="math notranslate nohighlight">\(^\circ\)</span> out-of-phase, the shape can now be complex, meaning there can be any phasing between different values in the shape. The exponential <span class="math notranslate nohighlight">\(e\)</span> now
represents an oscillatory portion and decaying or growing portion of the response (<span class="math notranslate nohighlight">\(\lambda\)</span> is in general a complex number. The imaginary portion of it will result in sinusoidal motion of the form <span class="math notranslate nohighlight">\(e^{j\theta} = \cos{\theta} + j\sin{\theta}\)</span> where <span class="math notranslate nohighlight">\(j = \sqrt{-1}\)</span>. The real part will result in exponential decay or exponential growth of the form <span class="math notranslate nohighlight">\(e^{x}\)</span>). The term <span class="math notranslate nohighlight">\(\lambda\)</span> appears on the first row of the second assumption due to the chain rule when differentiating
<span class="math notranslate nohighlight">\(\mathbf{v} = \dot{x}\)</span>.</p>
<p>Using the chain rule for differentiation, we can also say <span class="math notranslate nohighlight">\(\begin{bmatrix}\dot{\mathbf{v}}\\\dot{\mathbf{x}}\end{bmatrix} = \lambda\begin{bmatrix}\lambda\mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}e^{\lambda t}\)</span></p>
<p>We can then apply these assumptions to our equations of motion:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\left(\lambda \begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}e^{\lambda t}\right) + \begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}e^{\lambda t} = \begin{bmatrix}\mathbf{0}\\\mathbf{0}\end{bmatrix}\end{split}\]</div>
<p>We can again recognize that the term <span class="math notranslate nohighlight">\(e^{\lambda t}\)</span> is in general nonzero and therefore can be cancelled.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\left(\lambda \begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}\right) + \begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = \begin{bmatrix}\mathbf{0}\\\mathbf{0}\end{bmatrix}\end{split}\]</div>
<p>We can then subtract <span class="math notranslate nohighlight">\(\begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}\)</span> from both sides of the equation and we end up with</p>
<div class="math notranslate nohighlight">
\[\begin{split}\lambda \begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = - \begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}\end{split}\]</div>
<p>While a little more complex, this equation is also a <a class="reference external" href="https://en.wikipedia.org/wiki/Eigendecomposition_of_a_matrix#Generalized_eigenvalue_problem">Generalized Eigenvalue Problem</a>.</p>
<p>Transforming the eigenvalues and eigenvectors into natural frequencies and mode shapes is not as straightforward in the present case with complex modes. In general, we will solve for <span class="math notranslate nohighlight">\(2N\)</span> complex eigenvalues; however, due to the fact that the matrices are real, the eigenvalues will be complex conjugates of one another. We will often hear these values called <em>poles</em> because they are zeros of the denominator polynomials in the frequency response function formulation that we will discuss
later.</p>
<p>The eigenvalues <span class="math notranslate nohighlight">\(\lambda\)</span> are often expressed as a function of the critical damping ratio <span class="math notranslate nohighlight">\(\zeta\)</span> and the natural frequency <span class="math notranslate nohighlight">\(\omega\)</span>. For the <span class="math notranslate nohighlight">\(r\)</span>th mode,</p>
<div class="math notranslate nohighlight">
\[\lambda_r = -\zeta_r \omega_r + j\omega_r\sqrt{1-\zeta_r^2}\]</div>
<p>The real part <span class="math notranslate nohighlight">\(-\zeta_r \omega_r\)</span> drives the exponential decay of the sinusoid. The imaginary part drives the oscillatory behavior. Because of this, the term <span class="math notranslate nohighlight">\(\omega_r\sqrt{1-\zeta_r}\)</span> is often referred to as the <em>damped natural frequency</em> <span class="math notranslate nohighlight">\(\omega_d\)</span></p>
<div class="math notranslate nohighlight">
\[\omega_{dr} = \omega_r\sqrt{1-\zeta_r^2}\]</div>
<p>To recover the natural frequency <span class="math notranslate nohighlight">\(\omega_r\)</span>, we can simply take the magnitude of the eigenvalue.</p>
<div class="math notranslate nohighlight">
\[\left|\lambda_r\right| = \sqrt{\Re{(\lambda_r)}^2 + \Im{(\lambda_r)}^2} = \sqrt{(\zeta_r^2 \omega_r^2) + (\omega_r^2 (1-\zeta_r^2))} = \sqrt{\omega_r^2 + \omega_r^2\zeta_r^2 - \omega_r^2\zeta_r^2} = \omega_r\]</div>
<p>To recover the damping ratio, we can divide the negative real part of the eigenvalue by the magnitude of the eigenvalue.</p>
<div class="math notranslate nohighlight">
\[- \frac{\Re{(\lambda_r)}}{\left|\lambda_r\right|} = \frac{\zeta_r\omega_r}{\omega_r} = \zeta_r\]</div>
<p>Note that for complex modes, the damping is part of the solution to the free vibration problem and appears in the solution, whereas in the real mode case where damping was ignored, it was not.</p>
<p>We will also solve for <span class="math notranslate nohighlight">\(2N\)</span> eigenvectors. These will also appear in complex conjugate pairs. They will be of the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}\end{split}\]</div>
<p>We can extract the mode shape from the eigenvector simply by selecting the bottom partition of the vector.</p>
<p>The equations to compute the modal mass and modal damping matrices are the same as those used in the case of real modes. However, in general, the modal mass and modal damping matrices are not diagonal and have complex elements.</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{M}}=\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\]</div>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{C}}=\mathbf{\phi}^T\mathbf{C}\mathbf{\phi}\]</div>
<p>Recall that the eigenvalue problem we solved for was with respect to the generalized form <span class="math notranslate nohighlight">\(\mathbf{A}\dot{\mathbf{z}}+\mathbf{B}\mathbf{z} = \mathbf{u}\)</span>. Therefore the eigenvectors will diagonalize these matrices.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}^T\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = \begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}^T\mathbf{A}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = \tilde{\mathbf{A}}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}^T\begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = \begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}^T\mathbf{B}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = \tilde{\mathbf{B}}\end{split}\]</div>
<p>We often refer to these matrices <span class="math notranslate nohighlight">\(\tilde{\mathbf{A}}\)</span> and <span class="math notranslate nohighlight">\(\tilde{\mathbf{B}}\)</span> as the <em>Modal A</em> and <em>Modal B</em> matrices.</p>
<p>Modal mass is defined in different ways for complex modes. Some references will treat the diagonal entries in Modal A <span class="math notranslate nohighlight">\(\tilde{\mathbf{A}}_{rr}\)</span> directly as the modal mass values. Other references define the modal mass for the <span class="math notranslate nohighlight">\(r\)</span>th mode <span class="math notranslate nohighlight">\(m_r\)</span> as:</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{A}}_{rr} = 2\lambda_r m_r + 2\zeta_r\omega_r m_r = 2j\omega_{dr} m_r\]</div>
<div class="math notranslate nohighlight">
\[m_r = \frac{\tilde{\mathbf{A}}_{rr}}{2j\omega_{dr}}\]</div>
<p>It doesn’t really matter which definition is used as long as the definition is consistently used when reconstructing responses from modal parameters. This document will proceed with the modal mass defined as the diagonal terms of <span class="math notranslate nohighlight">\(\tilde{\mathbf{A}}\)</span>.</p>
<p>We can also see that if we premultiply the eigenvalue equation by our eigenvectors, we get a relationship between the Modal A and Modal B matrices.</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{B}}_{rr} = -\lambda_r \tilde{\mathbf{A}}_{rr}\]</div>
</section>
<section id="An-Example-Problem">
<h2>An Example Problem<a class="headerlink" href="#An-Example-Problem" title="Permalink to this heading"></a></h2>
<p>Before we get too far, let’s illustrate some of these concepts with a small example problem. We will generate a 3-degree-of-freedom problem that we will simulate. We will explore undamped, proportionally damped, and generally damped cases.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">scipy.linalg</span> <span class="k">as</span> <span class="nn">la</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">from</span> <span class="nn">IPython.display</span> <span class="kn">import</span> <span class="n">display</span><span class="p">,</span> <span class="n">HTML</span>

<span class="k">def</span> <span class="nf">pretty_print_table</span><span class="p">(</span><span class="n">df</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">display</span><span class="p">(</span> <span class="n">HTML</span><span class="p">(</span> <span class="n">df</span><span class="o">.</span><span class="n">to_html</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\\</span><span class="s2">n&quot;</span><span class="p">,</span><span class="s2">&quot;&lt;br&gt;&quot;</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>

<span class="c1"># Set up physical matrices</span>
<span class="n">K</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span> <span class="mi">6000</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000</span><span class="p">,</span>     <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="o">-</span><span class="mi">2000</span><span class="p">,</span>  <span class="mi">4000</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000</span><span class="p">],</span>
              <span class="p">[</span>    <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2000</span><span class="p">,</span>  <span class="mi">6000</span><span class="p">]])</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
              <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]])</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="mf">1.36</span><span class="o">/</span><span class="mi">2</span>
<span class="n">beta</span> <span class="o">=</span> <span class="mf">0.00154865</span><span class="o">/</span><span class="mi">2</span>
<span class="n">C_proportional</span> <span class="o">=</span> <span class="n">alpha</span><span class="o">*</span><span class="n">M</span><span class="o">+</span><span class="n">beta</span><span class="o">*</span><span class="n">K</span>

<span class="n">C_general</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">14</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                      <span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">],</span>
                      <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">10</span><span class="p">]])</span><span class="o">/</span><span class="mi">2</span>
</pre></div>
</div>
</div>
<p>For the complex mode cases, let’s construct the <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> matrices. The <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> matrix will depend on damping, the <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> matrix will not.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># For convenience, construct a matrix of zeros</span>
<span class="n">Z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
<span class="c1"># Assemble State Space Matrices</span>
<span class="n">A_undamped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">Z</span><span class="p">,</span> <span class="n">M</span><span class="p">],</span>
                       <span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">Z</span><span class="p">]])</span>
<span class="n">A_proportional</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">Z</span><span class="p">,</span> <span class="n">M</span><span class="p">],</span>
                           <span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">C_proportional</span><span class="p">]])</span>
<span class="n">A_general</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">Z</span><span class="p">,</span> <span class="n">M</span><span class="p">],</span>
                      <span class="p">[</span><span class="n">M</span><span class="p">,</span> <span class="n">C_general</span><span class="p">]])</span>
<span class="n">B</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="o">-</span><span class="n">M</span><span class="p">,</span> <span class="n">Z</span><span class="p">],</span>
              <span class="p">[</span> <span class="n">Z</span><span class="p">,</span> <span class="n">K</span><span class="p">]])</span>
</pre></div>
</div>
</div>
<p>Now let’s compute the eigenvalues and eigenvectors. For the 2nd-order eigenvalue using the mass and stiffness matrices directly, we can use the <code class="docutils literal notranslate"><span class="pre">eigh</span></code> function which assumes Hermetian, positive definite matrices. For the complex mode cases, we will have to use the more general <code class="docutils literal notranslate"><span class="pre">eig</span></code> function.</p>
<p>When using an eigenvalue solver, be wary of the order that matrices occur in the function call. For example, in the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html">scipy.linalg.eig documentation</a>, it states the following:</p>
<blockquote>
<div><p><strong>scipy.linalg.eig(a, b=None, left=False, right=True, overwrite_a=False, overwrite_b=False, check_finite=True, homogeneous_eigvals=False)</strong></p>
<p>Solve an ordinary or generalized eigenvalue problem of a square matrix.</p>
<p>Find eigenvalues w and right or left eigenvectors of a general matrix:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">a</span>   <span class="n">vr</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>        <span class="n">b</span>   <span class="n">vr</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
<span class="n">a</span><span class="o">.</span><span class="n">H</span> <span class="n">vl</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="n">b</span><span class="o">.</span><span class="n">H</span> <span class="n">vl</span><span class="p">[:,</span><span class="n">i</span><span class="p">]</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">.H</span></code> is the Hermitian conjugation.</p>
</div></blockquote>
<p>SciPy uses the definition <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{v} = \lambda\mathbf{B}\mathbf{v}\)</span> for its eigenvalue problem, and our equation we have defined as <span class="math notranslate nohighlight">\(- \mathbf{B}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix} = \lambda \mathbf{A}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}\)</span>. Note that what SciPy calls <code class="docutils literal notranslate"><span class="pre">a</span></code> in its function call is what we have defined as <span class="math notranslate nohighlight">\(-\mathbf{B}\)</span>, and what SciPy calls <code class="docutils literal notranslate"><span class="pre">b</span></code> is what we have defined as <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute Eigenvalues and Eigenvectors</span>
<span class="n">lam_2ndOrder</span><span class="p">,</span><span class="n">E_2ndOrder</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eigh</span><span class="p">(</span><span class="n">K</span><span class="p">,</span><span class="n">M</span><span class="p">)</span>
<span class="n">lam_undamped</span><span class="p">,</span> <span class="n">E_undamped</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="o">-</span><span class="n">B</span><span class="p">,</span><span class="n">A_undamped</span><span class="p">)</span>
<span class="n">lam_proportional</span><span class="p">,</span> <span class="n">E_proportional</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="o">-</span><span class="n">B</span><span class="p">,</span><span class="n">A_proportional</span><span class="p">)</span>
<span class="n">lam_general</span><span class="p">,</span> <span class="n">E_general</span> <span class="o">=</span> <span class="n">la</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="o">-</span><span class="n">B</span><span class="p">,</span><span class="n">A_general</span><span class="p">)</span>

<span class="c1"># Since the half the complex eigenvalues and eigenvectors are complex conjugates of one another,</span>
<span class="c1"># we will only keep those corresponding to the eigenvalues with imaginary part &gt; 0</span>
<span class="n">keep_undamped</span> <span class="o">=</span> <span class="n">lam_undamped</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">keep_proportional</span> <span class="o">=</span> <span class="n">lam_proportional</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span>
<span class="n">keep_general</span> <span class="o">=</span> <span class="n">lam_general</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span>

<span class="c1"># Now reduce to just those we want to keep</span>
<span class="n">lam_undamped</span> <span class="o">=</span> <span class="n">lam_undamped</span><span class="p">[</span><span class="n">keep_undamped</span><span class="p">]</span>
<span class="n">E_undamped</span> <span class="o">=</span> <span class="n">E_undamped</span><span class="p">[:,</span><span class="n">keep_undamped</span><span class="p">]</span>
<span class="n">lam_proportional</span> <span class="o">=</span> <span class="n">lam_proportional</span><span class="p">[</span><span class="n">keep_proportional</span><span class="p">]</span>
<span class="n">E_proportional</span> <span class="o">=</span> <span class="n">E_proportional</span><span class="p">[:,</span><span class="n">keep_proportional</span><span class="p">]</span>
<span class="n">lam_general</span> <span class="o">=</span> <span class="n">lam_general</span><span class="p">[</span><span class="n">keep_general</span><span class="p">]</span>
<span class="n">E_general</span> <span class="o">=</span> <span class="n">E_general</span><span class="p">[:,</span><span class="n">keep_general</span><span class="p">]</span>

<span class="c1"># Let&#39;s also sort the eigenvalues so they are all ascending</span>
<span class="k">for</span> <span class="n">evals</span><span class="p">,</span><span class="n">evects</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="n">lam_2ndOrder</span><span class="p">,</span> <span class="n">lam_undamped</span><span class="p">,</span> <span class="n">lam_proportional</span><span class="p">,</span> <span class="n">lam_general</span><span class="p">],</span>
                        <span class="p">[</span><span class="n">E_2ndOrder</span><span class="p">,</span> <span class="n">E_undamped</span><span class="p">,</span> <span class="n">E_proportional</span><span class="p">,</span> <span class="n">E_general</span><span class="p">]):</span>
    <span class="n">isort</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">evals</span><span class="p">))</span>
    <span class="n">evals</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">evals</span><span class="p">[</span><span class="n">isort</span><span class="p">]</span>
    <span class="n">evects</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">evects</span><span class="p">[:,</span><span class="n">isort</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Now we can extract the natural frequencies and damping ratios from the eigenvalues.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute natural frequencies</span>
<span class="n">omega_2ndOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">lam_2ndOrder</span><span class="p">)</span>
<span class="n">omega_undamped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam_undamped</span><span class="p">)</span>
<span class="n">omega_proportional</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam_proportional</span><span class="p">)</span>
<span class="n">omega_general</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam_general</span><span class="p">)</span>

<span class="c1"># Compute damping ratios</span>
<span class="n">zeta_undamped</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lam_undamped</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam_undamped</span><span class="p">)</span>
<span class="n">zeta_proportional</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lam_proportional</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam_proportional</span><span class="p">)</span>
<span class="n">zeta_general</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">lam_general</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lam_general</span><span class="p">)</span>

<span class="c1"># Compute damped natural frequencies</span>
<span class="n">omega_d_undamped</span> <span class="o">=</span> <span class="n">omega_undamped</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_undamped</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">omega_d_proportional</span> <span class="o">=</span> <span class="n">omega_proportional</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_proportional</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="n">omega_d_general</span> <span class="o">=</span> <span class="n">omega_general</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Let’s plot these datasets in a table.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Undamped&#39;</span><span class="p">,</span><span class="s1">&#39;Proportional Damping&#39;</span><span class="p">,</span><span class="s1">&#39;General Damping&#39;</span><span class="p">],</span>
                  <span class="n">index</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;Mass Matrix&#39;</span><span class="p">,</span><span class="s1">&#39;Stiffness Matrix&#39;</span><span class="p">,</span><span class="s1">&#39;Damping Matrix&#39;</span><span class="p">,</span><span class="s1">&#39;Poles&#39;</span><span class="p">,</span><span class="s1">&#39;Natural Frequencies&#39;</span><span class="p">,</span><span class="s1">&#39;Damping Ratios&#39;</span><span class="p">],</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Mass Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Undamped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Mass Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportional Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Mass Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;General Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Stiffness Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Undamped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Stiffness Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportional Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Stiffness Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;General Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">K</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Damping Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Undamped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">C_proportional</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Damping Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportional Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">C_proportional</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Damping Matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;General Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">C_general</span><span class="p">)</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Poles&#39;</span><span class="p">,</span> <span class="s1">&#39;Undamped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lam_undamped</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Poles&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportional Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lam_proportional</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Poles&#39;</span><span class="p">,</span> <span class="s1">&#39;General Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lam_general</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Natural Frequencies&#39;</span><span class="p">,</span> <span class="s1">&#39;Undamped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">omega_undamped</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Natural Frequencies&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportional Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">omega_proportional</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Natural Frequencies&#39;</span><span class="p">,</span> <span class="s1">&#39;General Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">omega_general</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Damping Ratios&#39;</span><span class="p">,</span> <span class="s1">&#39;Undamped&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">zeta_undamped</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Damping Ratios&#39;</span><span class="p">,</span> <span class="s1">&#39;Proportional Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">zeta_proportional</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="s1">&#39;Damping Ratios&#39;</span><span class="p">,</span> <span class="s1">&#39;General Damping&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">zeta_general</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
<span class="n">pretty_print_table</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Undamped</th>
      <th>Proportional Damping</th>
      <th>General Damping</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>Mass Matrix</th>
      <td>[[2 0 0]<br> [0 3 0]<br> [0 0 2]]</td>
      <td>[[2 0 0]<br> [0 3 0]<br> [0 0 2]]</td>
      <td>[[2 0 0]<br> [0 3 0]<br> [0 0 2]]</td>
    </tr>
    <tr>
      <th>Stiffness Matrix</th>
      <td>[[ 6000 -2000     0]<br> [-2000  4000 -2000]<br> [    0 -2000  6000]]</td>
      <td>[[ 6000 -2000     0]<br> [-2000  4000 -2000]<br> [    0 -2000  6000]]</td>
      <td>[[ 6000 -2000     0]<br> [-2000  4000 -2000]<br> [    0 -2000  6000]]</td>
    </tr>
    <tr>
      <th>Damping Matrix</th>
      <td>[[0. 0. 0.]<br> [0. 0. 0.]<br> [0. 0. 0.]]</td>
      <td>[[ 6.00595 -1.54865  0.     ]<br> [-1.54865  5.1373  -1.54865]<br> [ 0.      -1.54865  6.00595]]</td>
      <td>[[ 7. -1.  0.]<br> [-1.  5. -1.]<br> [ 0. -1.  5.]]</td>
    </tr>
    <tr>
      <th>Poles</th>
      <td>[[0.+27.2518998j ]<br> [0.+54.77225575j]<br> [0.+59.92217695j]]</td>
      <td>[[-0.62753244+27.24467371j]<br> [-1.5014875 +54.75167153j]<br> [-1.73017173+59.89719356j]]</td>
      <td>[[-0.73753202+27.24242803j]<br> [-1.50037636+54.76028673j]<br> [-1.59542495+59.89042233j]]</td>
    </tr>
    <tr>
      <th>Natural Frequencies</th>
      <td>[[27.2518998 ]<br> [54.77225575]<br> [59.92217695]]</td>
      <td>[[27.2518998 ]<br> [54.77225575]<br> [59.92217695]]</td>
      <td>[[27.25240977]<br> [54.78083727]<br> [59.91166888]]</td>
    </tr>
    <tr>
      <th>Damping Ratios</th>
      <td>[[-0.]<br> [-0.]<br> [-0.]]</td>
      <td>[[0.02302711]<br> [0.02741329]<br> [0.02887365]]</td>
      <td>[[0.027063  ]<br> [0.02738871]<br> [0.02662962]]</td>
    </tr>
  </tbody>
</table></div>
</div>
<p>We will now look at the eigenvectors. To start out, we will normalize the eigenvectors <strong>to a value that is NOT equal to unity modal mass or unity Modal A</strong>. This is useful while we are learning, because if we have unity modal mass, it allows us to be sloppy and simply drop or ignore effects of the modal mass. This could result in significant errors down the road if we assume that the formulae we developed for the unity modal mass case also apply to the non-unity modal mass case. It is therefore
better to develop and check all the formulae with non-unity modal mass to ensure that we understand its effects and have accounted for it successfully. We will deliberately normalize to a value not equal to 1, because many eigenvector solvers will automatically normalize for us.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Normalize Eigenvectors using einsum to pull out the m_ii terms from the modal normalization matrix</span>
<span class="c1"># We will multiply by 2 to ensure non-unity modal mass.</span>
<span class="n">E_2ndOrder</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">E_2ndOrder</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_2ndOrder</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">E_2ndOrder</span><span class="p">))</span>
<span class="n">E_undamped</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">E_undamped</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_undamped</span><span class="p">,</span><span class="n">A_undamped</span><span class="p">,</span><span class="n">E_undamped</span><span class="p">))</span>
<span class="n">E_proportional</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">E_proportional</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_proportional</span><span class="p">,</span><span class="n">A_proportional</span><span class="p">,</span><span class="n">E_proportional</span><span class="p">))</span>
<span class="n">E_general</span> <span class="o">=</span> <span class="mi">2</span><span class="o">*</span><span class="n">E_general</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_general</span><span class="p">,</span><span class="n">A_general</span><span class="p">,</span><span class="n">E_general</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>Now that we have the eigenvectors normalized to a non-unity modal mass, we will compute the Modal Mass and Modal A matrices to extract the modal mass.</p>
<p>We will use <code class="docutils literal notranslate"><span class="pre">np.einsum</span></code> in the same way we used previously but here we will describe it a bit better. Numpy’s <code class="docutils literal notranslate"><span class="pre">einsum</span></code> function implements a generalized version of Einstein Summation Notation. While we can represent matrix operations like multiplication simply by using symbols for the matrices</p>
<div class="math notranslate nohighlight">
\[\mathbf{C} = \mathbf{A}\mathbf{B}\]</div>
<p>we can also represent those operations with the indices</p>
<div class="math notranslate nohighlight">
\[C_{ik} = A_{ij}B_{jk}\]</div>
<p>In the previous equation, we have the index <span class="math notranslate nohighlight">\(i\)</span> representing the rows of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, and the index <span class="math notranslate nohighlight">\(j\)</span> representing the columns. Similarly for <span class="math notranslate nohighlight">\(\mathbf{B}\)</span>, we have the indices <span class="math notranslate nohighlight">\(j\)</span> representing the rows and <span class="math notranslate nohighlight">\(k\)</span> representing the columns. When we do matrix multiplication, we sum over the inner dimension, e.g., the <span class="math notranslate nohighlight">\(j\)</span> indices, and that index drops out. We are left with rows <span class="math notranslate nohighlight">\(i\)</span> and columns <span class="math notranslate nohighlight">\(k\)</span> of our output matrix <span class="math notranslate nohighlight">\(\mathbf{C}\)</span>. This
operation would be represented in Numpy’s <code class="docutils literal notranslate"><span class="pre">einsum</span></code> function as</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ij,jk-&gt;ik&#39;</span><span class="p">,</span><span class="n">A</span><span class="p">,</span><span class="n">B</span><span class="p">)</span>
</pre></div>
</div>
<p>The first argument <code class="docutils literal notranslate"><span class="pre">'ij,jk-&gt;ik'</span></code> is a string that gives the index operations to be performed. We see that there is an arrow <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> that separates input indices and output indices, and the different input indices are separated by a comma, and there is only one set of output indices. The remaining arguments are the actual matrices corresponding to the input indices passed in the first argument. Therefore <code class="docutils literal notranslate"><span class="pre">ij</span></code> will be associated with <code class="docutils literal notranslate"><span class="pre">A</span></code>, and <code class="docutils literal notranslate"><span class="pre">jk</span></code> will be associated with <code class="docutils literal notranslate"><span class="pre">B</span></code>. The output
indices on the right side of the arrow <code class="docutils literal notranslate"><span class="pre">ik</span></code> will be associated with the function’s output <code class="docutils literal notranslate"><span class="pre">C</span></code>. We note that any index not listed in the output indices will be summed over and drop out.</p>
<p>This notation is very useful for writing complex matrix expressions in a compact way. For example, if instead of <span class="math notranslate nohighlight">\(\mathbf{C} = \mathbf{A}\mathbf{B}\)</span> we wanted to do <span class="math notranslate nohighlight">\(\mathbf{C} = \mathbf{A}^T\mathbf{B}\)</span>, we can simply swap the indices on <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, which now means we are summing across the rows of <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>, which is equivalent to matrix multiplication by a transpose.</p>
<div class="math notranslate nohighlight">
\[\mathbf{C} = \mathbf{A}^T\mathbf{B}\]</div>
<div class="math notranslate nohighlight">
\[C_{ik} = A_{ji}B_{jk}\]</div>
<p>We can therefore represent a more complex product like</p>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{M}}=\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\]</div>
<p>as</p>
<div class="math notranslate nohighlight">
\[\tilde{{M}}_{il}={\phi}_{ji}{M}_{jk}{\phi}_{kl}\]</div>
<p>In the previous equation, we can see that the <span class="math notranslate nohighlight">\(j\)</span> index corresponds to the rows of the mass matrix and the rows of the mode shape matrix. Because we sum over <span class="math notranslate nohighlight">\(j\)</span>, this is equivalent to multiplying the matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> by <span class="math notranslate nohighlight">\(\mathbf{\phi}^T\)</span>. We can indeed improve upon this if, for example, we wanted a 1D array of modal mass values, rather than a 2D matrix that we will then need to extract the diagonals from. We can replace the <span class="math notranslate nohighlight">\(l\)</span> index with another <span class="math notranslate nohighlight">\(i\)</span> index
and have the output specify just a single <span class="math notranslate nohighlight">\(i\)</span>, and we will get a 1D array of modal mass values. As an aside, this is a syntax that is not acceptable in true Einstein Summation Notation, where a repeated index is automatically summed over. In Numpy’s generalized version, it subverts some of these very strict rules to give more flexibility to the user.</p>
<div class="math notranslate nohighlight">
\[\tilde{{M}}_{i}={\phi}_{ji}{M}_{jk}{\phi}_{ki}\]</div>
<p>We can then perform these operations in code to solve for the modal mass and modal A quantities.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">mm_2ndOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_2ndOrder</span><span class="p">,</span><span class="n">M</span><span class="p">,</span><span class="n">E_2ndOrder</span><span class="p">)</span>
<span class="n">ma_undamped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_undamped</span><span class="p">,</span><span class="n">A_undamped</span><span class="p">,</span><span class="n">E_undamped</span><span class="p">)</span>
<span class="n">ma_proportional</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_proportional</span><span class="p">,</span><span class="n">A_proportional</span><span class="p">,</span><span class="n">E_proportional</span><span class="p">)</span>
<span class="n">ma_general</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_general</span><span class="p">,</span><span class="n">A_general</span><span class="p">,</span><span class="n">E_general</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>The last thing we will do is to pull out the mode shapes from the eigenvectors. For the 2nd Order case, the mode shapes are the eigenvectors. But for the complex case, the mode shapes are the lower half of the eigenvector matrix.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">phi</span> <span class="o">=</span> <span class="n">E_2ndOrder</span>
<span class="n">psi_undamped</span> <span class="o">=</span> <span class="n">E_undamped</span><span class="p">[</span><span class="n">E_undamped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:,:]</span>
<span class="n">psi_proportional</span> <span class="o">=</span> <span class="n">E_proportional</span><span class="p">[</span><span class="n">E_proportional</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:,:]</span>
<span class="n">psi_general</span> <span class="o">=</span> <span class="n">E_general</span><span class="p">[</span><span class="n">E_general</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:,:]</span>
</pre></div>
</div>
</div>
<p>We should be able to check that the top half of the eigenvector matrix is the bottom half multiplied by the eigenvalue.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\lambda \mathbf{\psi}\\\mathbf{\psi}\end{bmatrix}\end{split}\]</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">E_general</span><span class="p">[:</span><span class="n">E_general</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">,:]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-1.16839552-1.20937963j,  3.7348689 +3.68391729j,
        -3.16635239-3.71568777j],
       [-2.60749708-2.75808733j, -0.10439594+0.09881697j,
         2.00036437+2.07501753j],
       [-1.15358519-1.22327319j, -3.46966805-3.92680586j,
        -3.52944456-3.37788878j]])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lam_general</span><span class="o">*</span><span class="n">psi_general</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[13]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-1.16839552-1.20937963j,  3.7348689 +3.68391729j,
        -3.16635239-3.71568777j],
       [-2.60749708-2.75808733j, -0.10439594+0.09881697j,
         2.00036437+2.07501753j],
       [-1.15358519-1.22327319j, -3.46966805-3.92680586j,
        -3.52944456-3.37788878j]])
</pre></div></div>
</div>
<p>One final thing to note is that in general, the mode shapes extracted from a complex analysis will not diagonalize the orignal mass, stiffness, or damping matrices, as these were not the matrices the eigensolution was performed on. There will be off-diagonal terms, and they will be complex.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_general</span><span class="o">.</span><span class="n">T</span><span class="nd">@M@psi_general</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-6.13061679e-08-7.34176433e-02j, -1.43810774e-04+9.83528782e-06j,
         1.15410477e-04+2.13846966e-06j],
       [-1.43810774e-04+9.83528782e-06j, -1.24812005e-07-3.65342888e-02j,
        -1.36140173e-04+1.88235958e-06j],
       [ 1.15410477e-04+2.13846966e-06j, -1.36140173e-04+1.88235958e-06j,
         1.86118173e-07-3.33825843e-02j]])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_general</span><span class="o">.</span><span class="n">T</span><span class="nd">@C_general@psi_general</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-0.00014982-0.10829239j,  0.00048468+0.01181488j,
         0.00045558-0.01005105j],
       [ 0.00048468+0.01181488j, -0.00125664-0.1096167j ,
        -0.00020565+0.01561439j],
       [ 0.00045558-0.01005105j, -0.00020565+0.01561439j,
         0.00140645-0.10654111j]])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_general</span><span class="o">.</span><span class="n">T</span><span class="nd">@K@psi_general</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[16]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-6.49635076e-05-5.45227499e+01j,  2.15177460e-01-2.97517095e-03j,
        -1.87975974e-01-1.36004490e-02j],
       [ 2.15177460e-01-2.97517095e-03j, -1.51087546e-03-1.09568400e+02j,
         4.46495302e-01+1.79584080e-02j],
       [-1.87975974e-01-1.36004490e-02j,  4.46495302e-01+1.79584080e-02j,
         1.57583896e-03-1.19907950e+02j]])
</pre></div></div>
</div>
</section>
<section id="Frequency-Response-Functions-and-Modal-Parameters">
<h2>Frequency Response Functions and Modal Parameters<a class="headerlink" href="#Frequency-Response-Functions-and-Modal-Parameters" title="Permalink to this heading"></a></h2>
<p>Now that we have familiarized ourselves with the modal parameters for real and complex modes, let’s discuss the relationship to the frequency response function. This is of utmost importance, because we eventually would like to fit the modal parameters from the frequency response functions, as well as reconstruct frequency response functions from the modal parameters.</p>
<section id="Real-Modes">
<h3>Real Modes<a class="headerlink" href="#Real-Modes" title="Permalink to this heading"></a></h3>
<p>Starting with the modal system of equations, and assuming proportional damping, we have</p>
<div class="math notranslate nohighlight">
\[\mathbf{\phi}^T\mathbf{M}\mathbf{\phi}\ddot{\mathbf{q}} + \mathbf{\phi}^T\mathbf{C}\mathbf{\phi}\dot{\mathbf{q}} + \mathbf{\phi}^T\mathbf{K}\mathbf{\phi}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<div class="math notranslate nohighlight">
\[\tilde{\mathbf{M}}\ddot{\mathbf{q}} + \tilde{\mathbf{C}}\dot{\mathbf{q}} + \tilde{\mathbf{K}}{\mathbf{q}} = \mathbf{\phi}^T\mathbf{F}\]</div>
<p>We can also substitute in the diagonal values for the modal parameters. <em>Note the inclusion of the modal mass</em> <span class="math notranslate nohighlight">\(m_r\)</span> <em>in all terms, because we have not assumed mass normalized modes in this case</em>. We will represent the generalized modal force <span class="math notranslate nohighlight">\(\mathbf{\phi}^T\mathbf{F}\)</span> as <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\left[m_r\right]\ddot{\mathbf{q}} + \left[2\zeta_r\omega_r m_r\right]\dot{\mathbf{q}} + \left[\omega_r^2m_r\right]{\mathbf{q}} = \mathbf{Q}\]</div>
<p>We can then use the <em>Laplace Transform</em> to make this differential equation into an algebraic one.</p>
<div class="math notranslate nohighlight">
\[\left[m_r\right]s^2{\mathbf{q}} + \left[2\zeta_r\omega_r m_r\right]s{\mathbf{q}} + \left[\omega_r^2m_r\right]{\mathbf{q}} = \mathbf{Q}\]</div>
<p>We can collect terms of <span class="math notranslate nohighlight">\(\mathbf{q}\)</span> to create an equation of the form <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{x} = \mathbf{b}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\left[m_rs^2 + 2\zeta_r\omega_r m_rs + \omega_r^2m_r\right]{\mathbf{q}} = \mathbf{Q}\]</div>
<p>Because the equation is diagonal, inverting the coefficient matrix is trival.</p>
<div class="math notranslate nohighlight">
\[{\mathbf{q}} = \left[\frac{1}{m_rs^2 + 2\zeta_r\omega_r m_rs + \omega_r^2m_r}\right]\mathbf{Q}\]</div>
<p>This is now a representation of a <em>modal</em> transfer function. If we apply a set of <em>modal</em> forces <span class="math notranslate nohighlight">\(\mathbf{Q}\)</span>, we get out a set of <em>modal</em> responses <span class="math notranslate nohighlight">\(\mathbf{q}\)</span>. To transform to physical space, we need to transform our modal quantities to physical quantities. We know the substitution for modal forces <span class="math notranslate nohighlight">\(\mathbf{Q} = \mathbf{\phi}^T\mathbf{F}\)</span>, and we know our equation for physical response from modal responses <span class="math notranslate nohighlight">\(\mathbf{x} = \mathbf{\phi}\mathbf{q}\)</span>. Therefore we can make
the subsitution for modal force, and pre-multiply the entire equation by the mode shape matrix.</p>
<div class="math notranslate nohighlight">
\[\mathbf{x} = \mathbf{\phi}{\mathbf{q}} = \mathbf{\phi}\left[\frac{1}{m_rs^2 + 2\zeta_r\omega_r m_rs + \omega_r^2m_r}\right]\mathbf{\phi}^T\mathbf{F}\]</div>
<p>If instead of the entire Laplace domain we only consider sinusoidal responses, we can substitute <span class="math notranslate nohighlight">\(s=j\omega\)</span> to get the familiar form for the frequency response function.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H} = \mathbf{\phi}\left[\frac{1}{-m_r\omega^2 + 2j\zeta_r\omega_r m_r\omega + \omega_r^2m_r}\right]\mathbf{\phi}^T\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{H} = \sum_{r=1}^N\frac{\mathbf{\phi}_r\mathbf{\phi}_r^T}{-m_r\omega^2 + 2j\zeta_r\omega_r m_r\omega + \omega_r^2m_r}\]</div>
<p>To pull out a specific entry in the FRF matrix, we can index the mode shapes.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\frac{\phi_{ir}\phi_{jr}}{-m_r\omega^2 + 2j\zeta_r\omega_r m_r\omega + \omega_r^2m_r}\]</div>
</section>
<section id="Complex-Modes">
<h3>Complex Modes<a class="headerlink" href="#Complex-Modes" title="Permalink to this heading"></a></h3>
<p>The derivation for the frequency response function in terms of complex modes is similar. Recall that our physical vector for the complex state space formulation includes velocities and displacements. Similarly our eigenvectors consisted of pairs of shapes, the shape and its complex conjugate. Therefore, in the case of complex modes, the projection from modal space to physical space is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{v}\\\mathbf{x}\end{bmatrix} = \begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix}\end{split}\]</div>
<p>Applying the transformation to the complex state space equation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\begin{bmatrix}\dot{\mathbf{v}}\\\dot{\mathbf{x}}\end{bmatrix} + \begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}{\mathbf{v}}\\{\mathbf{x}}\end{bmatrix} = \begin{bmatrix}\mathbf{0}\\\mathbf{F}\end{bmatrix}\end{split}\]</div>
<p>Gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\dot{\mathbf{q}}\\\dot{\mathbf{q}}^*\end{bmatrix} + \begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix} = \begin{bmatrix}\mathbf{0}\\\mathbf{F}\end{bmatrix}\end{split}\]</div>
<p>And then pre-multiplying by the eigenvector matrix transpose completes the transformation into modal space.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}^T\begin{bmatrix}\mathbf{0} &amp; \mathbf{M} \\ \mathbf{M} &amp; \mathbf{C}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\dot{\mathbf{q}}\\\dot{\mathbf{q}}^*\end{bmatrix} + \begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}^T\begin{bmatrix} -\mathbf{M} &amp; \mathbf{0} \\ \mathbf{0} &amp; \mathbf{K}\end{bmatrix}\begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix} = \begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}^T\begin{bmatrix}\mathbf{0}\\\mathbf{F}\end{bmatrix}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}= \begin{bmatrix}\lambda \mathbf{\psi}^T &amp; \mathbf{\psi}^T \\ \lambda^* {\mathbf{\psi}^*}^T &amp; {\mathbf{\psi}^*}^T\end{bmatrix}\begin{bmatrix}\mathbf{0}\\\mathbf{F}\end{bmatrix} = \begin{bmatrix}\mathbf{\psi}^T \\ {\mathbf{\psi}^*}^T\end{bmatrix}\mathbf{F}\end{split}\]</div>
<p>Transforming into the modal matrices</p>
<div class="math notranslate nohighlight">
\[\begin{split}\tilde{\mathbf{A}}\begin{bmatrix}\dot{\mathbf{q}}\\\dot{\mathbf{q}}^*\end{bmatrix} + \tilde{\mathbf{B}}\begin{bmatrix}{\mathbf{q}}\\{\mathbf{q}}^*\end{bmatrix} = \begin{bmatrix}\mathbf{Q} \\ \mathbf{Q}^*\end{bmatrix}\end{split}\]</div>
<p>We recognize that the diagonal terms of <span class="math notranslate nohighlight">\(\tilde{\mathbf{A}}\)</span> are simply what we’ve defined as the modal mass, and the diagonal terms of <span class="math notranslate nohighlight">\(\tilde{\mathbf{B}}\)</span> are simply the negative modal mass times the eigenvector <span class="math notranslate nohighlight">\(\tilde{\mathbf{B}}_{rr} = -\lambda_r \tilde{\mathbf{A}}_{rr}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\left[m_r\right] &amp; \mathbf{0} \\ \mathbf{0} &amp; \left[m_r\right]\end{bmatrix}\begin{bmatrix}\dot{\mathbf{q}}\\\dot{\mathbf{q}}^*\end{bmatrix} - \begin{bmatrix}\lambda_r\left[m_r\right] &amp; \mathbf{0} \\ \mathbf{0} &amp; {\lambda_r}^*\left[m_r\right]\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix}  = \begin{bmatrix}\mathbf{Q} \\ \mathbf{Q}^*\end{bmatrix}\end{split}\]</div>
<p>Once again, transforming to the Laplace Domain,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}s\left[m_r\right] &amp; \mathbf{0} \\ \mathbf{0} &amp; s\left[m_r\right]\end{bmatrix}\begin{bmatrix}{\mathbf{q}}\\{\mathbf{q}}^*\end{bmatrix} - \begin{bmatrix}\lambda_r\left[m_r\right] &amp; \mathbf{0} \\ \mathbf{0} &amp; {\lambda_r}^*\left[m_r\right]\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix}  = \begin{bmatrix}\mathbf{Q} \\ \mathbf{Q}^*\end{bmatrix}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}(s-\lambda)\left[m_r\right] &amp; \mathbf{0} \\ \mathbf{0} &amp; (s-\lambda^*)\left[m_r\right]\end{bmatrix}\begin{bmatrix}{\mathbf{q}}\\{\mathbf{q}}^*\end{bmatrix}  = \begin{bmatrix}\mathbf{Q} \\ \mathbf{Q}^*\end{bmatrix}\end{split}\]</div>
<p>Once again, because this matrix is diagonal, it is easy to invert.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}{\mathbf{q}}\\{\mathbf{q}}^*\end{bmatrix} = \begin{bmatrix}\frac{1}{(s-\lambda)\left[m_r\right]} &amp; \mathbf{0} \\ \mathbf{0} &amp; \frac{1}{(s-\lambda^*)\left[m_r\right]}\end{bmatrix}\begin{bmatrix}\mathbf{Q} \\ \mathbf{Q}^*\end{bmatrix}\end{split}\]</div>
<p>This is the modal transfer function.</p>
<p>To compute the transfer functions between the force <span class="math notranslate nohighlight">\(\mathbf{F}\)</span> and the response <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> (we ignore <span class="math notranslate nohighlight">\(\mathbf{v}\)</span> here), we can use the identities <span class="math notranslate nohighlight">\(\begin{bmatrix}\mathbf{Q} \\ \mathbf{Q}^*\end{bmatrix} = \begin{bmatrix}\mathbf{\psi}^T \\ {\mathbf{\psi}^*}^T\end{bmatrix}\mathbf{F}\)</span>, which we defined previously, and the last row of
<span class="math notranslate nohighlight">\(\begin{bmatrix}\mathbf{v}\\\mathbf{x}\end{bmatrix} = \begin{bmatrix}\lambda \mathbf{\psi} &amp; \lambda^* \mathbf{\psi}^* \\ \mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix}\)</span>, which is <span class="math notranslate nohighlight">\(\mathbf{x} = \begin{bmatrix}\mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\mathbf{q}\\\mathbf{q}^*\end{bmatrix}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{x} = \begin{bmatrix}\mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}{\mathbf{q}}\\{\mathbf{q}}^*\end{bmatrix} = \begin{bmatrix}\mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\frac{1}{(s-\lambda)\left[m_r\right]} &amp; \mathbf{0} \\ \mathbf{0} &amp; \frac{1}{(s-\lambda^*)\left[m_r\right]}\end{bmatrix}\begin{bmatrix}\mathbf{\psi}^T \\ {\mathbf{\psi}^*}^T\end{bmatrix}\mathbf{F}\end{split}\]</div>
<p>The transfer function in the <span class="math notranslate nohighlight">\(s\)</span>-domain is then</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{H} = \begin{bmatrix}\mathbf{\psi} &amp; \mathbf{\psi}^*\end{bmatrix}\begin{bmatrix}\frac{1}{(s-\lambda)\left[m_r\right]} &amp; \mathbf{0} \\ \mathbf{0} &amp; \frac{1}{(s-\lambda^*)\left[m_r\right]}\end{bmatrix}\begin{bmatrix}\mathbf{\psi}^T \\ {\mathbf{\psi}^*}^T\end{bmatrix}\end{split}\]</div>
<p>Because it is diagonal, we can take it out of matrix form and put it into summation form, which reveals the usual partial fraction form of the transfer function.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H} = \sum_{r=1}^N\left( \frac{\mathbf{\psi}_r\mathbf{\psi}_r^T}{m_r(s-\lambda_r)} + \frac{\mathbf{\psi}_r^*{\mathbf{\psi}_r^*}^T}{m_r(s-\lambda_r^*)}\right)\]</div>
<p>We can extract a specific transfer function <span class="math notranslate nohighlight">\(\mathbf{H}_{ij}\)</span></p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\left( \frac{\mathbf{\psi}_{ir}\mathbf{\psi}_{jr}}{m_r(s-\lambda_r)} + \frac{\mathbf{\psi}_{ir}^*\mathbf{\psi}_{jr}^*}{m_r(s-\lambda_r^*)}\right)\]</div>
<p>To translate into more intuitive variables, we can make the following substitutions.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\lambda_r = -\sigma_r + j\omega_{dr} = -\zeta_r\omega_r + j\omega_r\sqrt{1-\zeta_r^2}\)</span> - Substitute the poles for the natural frequency and critical damping ratio.</p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{\psi}_{ir} = \mathbf{\psi}_{ir}^R + j\mathbf{\psi}_{ir}^I\)</span> - Split the mode shapes into real and imaginary parts.</p></li>
</ul>
<p>From these, it follows that the complex conjugate versions simply have the sign flipped on their imaginary components.</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(\lambda_r^* = -\sigma_r - j\omega_{dr} = -\zeta_r\omega_r - j\omega_r\sqrt{1-\zeta_r^2}\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\mathbf{\psi}_{ir} = \mathbf{\psi}_{ir}^R - j\mathbf{\psi}_{ir}^I\)</span></p></li>
</ul>
<p>Substituting these into the previous equation, we get</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\left( \frac{\left(\mathbf{\psi}_{ir}^R + j\mathbf{\psi}_{ir}^I\right)\left(\mathbf{\psi}_{jr}^R + j\mathbf{\psi}_{jr}^I\right)}{m_r(s-\left(-\sigma_r + j\omega_{dr}\right))} + \frac{\left(\mathbf{\psi}_{ir}^R - j\mathbf{\psi}_{ir}^I\right)\left(\mathbf{\psi}_{jr}^R - j\mathbf{\psi}_{jr}^I\right)}{m_r(s-\left(-\sigma_r - j\omega_{dr}\right))}\right)\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\left( \frac{\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right) + j\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)}{m_r\left(s + \sigma_r - j\omega_{dr}\right)} + \frac{\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right) - j\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)}{m_r\left(s+ \sigma_r + j\omega_{dr}\right)}\right)\]</div>
<p>If we put the two terms over a common denominator, we get</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\left(
\frac{
  \left(\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right) + j\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\right)
  \left(s+ \sigma_r + j\omega_{dr}\right)
+ \left(\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right) - j\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\right)
  \left(s + \sigma_r - j\omega_{dr}\right)}
{m_r\left(s+ \sigma_r + j\omega_{dr}\right)\left(s + \sigma_r - j\omega_{dr}\right)}
\right)\]</div>
<p>We can expand and reduce this equation</p>
<div class="math notranslate nohighlight">
\[ \mathbf{H}_{ij} = 2\sum_{r=1}^N\left(
\frac{
\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right)\left(s+ \sigma_r\right) -
\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr}
}
{m_r\left(\left(s+\sigma_r\right)^2 + \omega_{dr}^2\right)
}
\right)\]</div>
</section>
<section id="What-are-Real-Modes-in-the-Complex-Mode-Framework?">
<h3>What are Real Modes in the Complex Mode Framework?<a class="headerlink" href="#What-are-Real-Modes-in-the-Complex-Mode-Framework?" title="Permalink to this heading"></a></h3>
<p>One might naively believe that a real mode is simply a complex mode where the imaginary part is zero. However, it isn’t clear whether or not that should be true, because the eigenvalue problem was posed differently. What is clear, however, is that real modes should certainly be some subset of complex modes; in other words, we should be able to represent a real mode as a complex mode. In this section, we will investigate that relationship.</p>
<p>Starting with the previous equation, we can further expand the denominator with natural frequency and damping ratio, where <span class="math notranslate nohighlight">\(\sigma_r = \zeta_r\omega_r\)</span> and <span class="math notranslate nohighlight">\(\omega_{dr} = \omega_r\sqrt{1-\zeta_r^2}\)</span>.</p>
<div class="math notranslate nohighlight">
\[ \mathbf{H}_{ij} = 2\sum_{r=1}^N\left(
\frac{
\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right)\left(s+ \sigma_r\right) -
\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr}
}
{m_r\left(\left(s+-\zeta_r\omega_r\right)^2 + \left(\omega_r\sqrt{1-\zeta_r^2}\right)^2\right)
}
\right)\]</div>
<div class="math notranslate nohighlight">
\[ \mathbf{H}_{ij} = 2\sum_{r=1}^N\left(
\frac{
\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right)\left(s+ \sigma_r\right) -
\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr}
}
{m_r\left(\left(s^2+2s\zeta_r\omega_r + \omega_r^2\zeta_r^2\right) + \left(\omega_r^2 - \omega_r^2\zeta_r^2\right)\right)
}
\right)\]</div>
<div class="math notranslate nohighlight">
\[ \mathbf{H}_{ij} = 2\sum_{r=1}^N\left(
\frac{
\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right)\left(s+ \sigma_r\right) -
\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr}
}
{m_rs^2+2\zeta_r\omega_rm_rs + m_r\omega_r^2
}
\right)\]</div>
<p>The denominator in the previous equation is identical to that from the real modes equation.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\frac{\phi_{ir}\phi_{jr}}{m_rs^2 + 2\zeta_r\omega_r m_rs + \omega_r^2m_r}\]</div>
<p>The numerators should also be equivalent.</p>
<div class="math notranslate nohighlight">
\[2\left(\left( \psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I \right)\left(s+ \sigma_r\right) -
\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr}\right) = \phi_{ir}\phi_{jr}\]</div>
<p>We note that there is no terms with <span class="math notranslate nohighlight">\(s\)</span> on the real modes side of the equation, so any term containing <span class="math notranslate nohighlight">\(s\)</span> on the complex modes side of the equation must be zero in the case of real modes.</p>
<div class="math notranslate nohighlight">
\[\psi_{ir}^R\psi_{jr}^R - \psi_{ir}^I\psi_{jr}^I = 0\]</div>
<p>This then leaves the remainder of the equation</p>
<div class="math notranslate nohighlight">
\[-2\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr} = \phi_{ir}\phi_{jr}\]</div>
<p>We must find a solution for these two equations simultaneously. Since the modeshape at location <span class="math notranslate nohighlight">\(i\)</span> and the mode shape at location <span class="math notranslate nohighlight">\(j\)</span> are generally independent of one another, we can treat them as independent. In other words, <span class="math notranslate nohighlight">\(\psi_{ir}\)</span> cannot be a function <span class="math notranslate nohighlight">\(\psi_{jr}\)</span>. This means for the first equation, there are two possibilities; <span class="math notranslate nohighlight">\(\psi_{ir}^I = -\psi_{ir}^R\)</span> or <span class="math notranslate nohighlight">\(\psi_{ir}^I = \psi_{ir}^R\)</span>.</p>
<p>To figure out which, we will look at the drive point transfer function where <span class="math notranslate nohighlight">\(i = j\)</span>, as the relationship should hold for that point as much as any other point.</p>
<div class="math notranslate nohighlight">
\[-2\left( \psi_{ir}^R\psi_{ir}^I + \psi_{ir}^I\psi_{ir}^R \right)\omega_{dr} = \phi_{ir}^2\]</div>
<div class="math notranslate nohighlight">
\[\psi_{ir}^R\psi_{ir}^I + \psi_{ir}^I\psi_{ir}^R = \frac{\phi_{ir}^2}{-2\omega_{dr}}\]</div>
<p>The since term <span class="math notranslate nohighlight">\(\phi_{ir}^2\)</span> cannot be negative and <span class="math notranslate nohighlight">\(\omega_{dr}\)</span> is also non-negative, the term <span class="math notranslate nohighlight">\(\psi_{ir}^R\psi_{ir}^I + \psi_{ir}^I\psi_{ir}^R\)</span> must be negative. This will be the case if <span class="math notranslate nohighlight">\(\psi_{ir}^I = -\psi_{ir}^R\)</span>, but will not be the case if <span class="math notranslate nohighlight">\(\psi_{ir}^I = \psi_{ir}^R\)</span>.</p>
<p>Substituting that expression,</p>
<div class="math notranslate nohighlight">
\[-{\psi_{ir}^R}^2 + -{\psi_{ir}^R}^2 = \frac{\phi_{ir}^2}{-2\omega_{dr}}\]</div>
<div class="math notranslate nohighlight">
\[-2{\psi_{ir}^R}^2 = \frac{\phi_{ir}^2}{-2\omega_{dr}}\]</div>
<div class="math notranslate nohighlight">
\[{\psi_{ir}^R}^2 = \frac{\phi_{ir}^2}{4\omega_{dr}}\]</div>
<div class="math notranslate nohighlight">
\[{\psi_{ir}^R} = \frac{\phi_{ir}}{2\sqrt{\omega_{dr}}} = -\psi_{ir}^I\]</div>
<p>To verify that this is the general expression, let’s plug it into the original equation.</p>
<div class="math notranslate nohighlight">
\[-2\left( \psi_{ir}^R\psi_{jr}^I + \psi_{ir}^I\psi_{jr}^R \right)\omega_{dr} = \phi_{ir}\phi_{jr}\]</div>
<div class="math notranslate nohighlight">
\[-2\left(
-\frac{\phi_{ir}}{2\sqrt{\omega_{dr}}}
\frac{\phi_{jr}}{2\sqrt{\omega_{dr}}} +
-\frac{\phi_{ir}}{2\sqrt{\omega_{dr}}}
\frac{\phi_{jr}}{2\sqrt{\omega_{dr}}}
\right)\omega_{dr} = \phi_{ir}\phi_{jr}\]</div>
<div class="math notranslate nohighlight">
\[-2\left(
-\frac{\phi_{ir}\phi_{jr}}{4\omega_{dr}}
-\frac{\phi_{ir}\phi_{jr}}{4\omega_{dr}}
\right)\omega_{dr} = \phi_{ir}\phi_{jr}\]</div>
<div class="math notranslate nohighlight">
\[-2\left(
-2\frac{\phi_{ir}\phi_{jr}}{4\omega_{dr}}
\right)\omega_{dr} = \phi_{ir}\phi_{jr}\]</div>
<div class="math notranslate nohighlight">
\[\phi_{ir}\phi_{jr} = \phi_{ir}\phi_{jr}\]</div>
<p>Therefore for a real mode represented in a complex mode, we should expect the imaginary part to be equal in magnitude to the real part, with phase angle of -45<span class="math notranslate nohighlight">\(^\circ\)</span> instead of zero degrees, which may have been expected.</p>
</section>
<section id="Back-to-our-Example-Problem">
<h3>Back to our Example Problem<a class="headerlink" href="#Back-to-our-Example-Problem" title="Permalink to this heading"></a></h3>
<p>Let’s return to our example problem to compute frequency response functions from the matrices as well as from modal parameters. We will start with computing the frequency response functions from dynamic stiffness matrices.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[17]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get frequency lines</span>
<span class="n">omegas</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">omega_2ndOrder</span><span class="p">)</span><span class="o">*</span><span class="mf">1.5</span><span class="p">,</span><span class="mi">1000</span><span class="p">)</span>
<span class="c1"># Set up omega for broadcasting the FRF matrix, the first dimension will be frequency line.</span>
<span class="c1"># The second two dimensions will be i,j degrees of freedom.</span>
<span class="n">omegas_bc</span> <span class="o">=</span> <span class="n">omegas</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="c1"># Construct Dynamic Stiffness</span>
<span class="n">Z_undamped</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">K</span>
<span class="n">Z_proportional</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C_proportional</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span> <span class="o">+</span> <span class="n">K</span>
<span class="n">Z_general</span> <span class="o">=</span> <span class="n">M</span><span class="o">*</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">C_general</span><span class="o">*</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span> <span class="o">+</span> <span class="n">K</span>
<span class="c1"># Invert to get frequency response functions</span>
<span class="n">H_undamped</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Z_undamped</span><span class="p">)</span>
<span class="n">H_proportional</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Z_proportional</span><span class="p">)</span>
<span class="n">H_general</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">inv</span><span class="p">(</span><span class="n">Z_general</span><span class="p">)</span>
<span class="c1"># Plot the FRFs</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">H_undamped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">H_undamped</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_u</span><span class="p">,</span><span class="n">f_p</span><span class="p">,</span><span class="n">f_g</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                          <span class="n">H_undamped</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                          <span class="n">H_proportional</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                          <span class="n">H_general</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_u</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_p</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_g</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_u</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_p</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_g</span><span class="p">))</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Undamped&#39;</span><span class="p">,</span><span class="s1">&#39;Proportional Damping&#39;</span><span class="p">,</span><span class="s1">&#39;General Damping&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_50_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_50_0.png" />
</div>
</div>
<p>Now let’s reconstruct the frequency response functions from modal parameters and see if they match those constructed from the dynamic stiffness matrices.</p>
<p>For the second-order case,</p>
<div class="math notranslate nohighlight">
\[\mathbf{H} = \sum_{r=1}^N\frac{\mathbf{\phi}_r\mathbf{\phi}_r^T}{-m_r\omega^2 + 2j\zeta_r\omega_r m_r\omega + \omega_r^2m_r}\]</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[18]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># 2nd Order Case</span>
<span class="c1"># First we need to find the modal damping ratios from the damping matrix</span>
<span class="n">zeta_2ndOrder</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ji,jk,ki-&gt;i&#39;</span><span class="p">,</span><span class="n">E_2ndOrder</span><span class="p">,</span><span class="n">C_proportional</span><span class="p">,</span><span class="n">E_2ndOrder</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">mm_2ndOrder</span><span class="o">*</span><span class="n">omega_2ndOrder</span><span class="p">)</span>

<span class="c1"># Now Construct the FRF matrix from modal parameters</span>
<span class="n">num_modes</span> <span class="o">=</span> <span class="n">omega_2ndOrder</span><span class="o">.</span><span class="n">size</span>
<span class="n">H_2ndOrder_fromModes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
    <span class="n">phi</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="nd">@phi</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">/</span> <span class="c1"># The newaxis turns the array from a 1D array back into a 2D array that can be transposed</span>
    <span class="p">(</span><span class="o">-</span><span class="n">mm_2ndOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omegas_bc</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="n">j</span><span class="o">*</span><span class="n">zeta_2ndOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_2ndOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">mm_2ndOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omegas_bc</span> <span class="o">+</span> <span class="n">omega_2ndOrder</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="o">*</span><span class="n">mm_2ndOrder</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">H_proportional</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">H_proportional</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_d</span><span class="p">,</span><span class="n">f_m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_proportional</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_2ndOrder_fromModes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_d</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_m</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_d</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_m</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;From Dynamic Stiffness&#39;</span><span class="p">,</span><span class="s1">&#39;From Modal Parameters&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_52_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_52_0.png" />
</div>
</div>
<p>We see we get identical FRFs.</p>
<p>For the complex mode cases:</p>
<div class="math notranslate nohighlight">
\[\mathbf{H} = \sum_{r=1}^N\left( \frac{\mathbf{\psi}_r\mathbf{\psi}_r^T}{m_r(s-\lambda_r)} + \frac{\mathbf{\psi}_r^*{\mathbf{\psi}_r^*}^T}{m_r(s-\lambda_r^*)}\right)\]</div>
<p>Note that for a frequency response function, which assumes a single frequency line excitation, the Laplace variable <span class="math notranslate nohighlight">\(s = j\omega\)</span>. The pole <span class="math notranslate nohighlight">\(\lambda_r = -\zeta_r\omega_r + j\omega_r\sqrt{1-\zeta_r^2}\)</span>.</p>
<p>Here is the proportional damped case:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[19]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_modes</span> <span class="o">=</span> <span class="n">omega_proportional</span><span class="o">.</span><span class="n">size</span>
<span class="c1"># Compute the laplace variables</span>
<span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span>

<span class="c1"># Compute FRFs</span>
<span class="n">H_proportional_fromModes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
    <span class="n">psi_proportional</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="nd">@psi_proportional</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">/</span>
    <span class="p">(</span><span class="n">ma_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="o">+</span> <span class="n">psi_proportional</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="nd">@psi_proportional</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">/</span>
    <span class="p">(</span><span class="n">ma_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_proportional</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">H_proportional</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">H_proportional</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_d</span><span class="p">,</span><span class="n">f_m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_proportional</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_proportional_fromModes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_d</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_m</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_d</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_m</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;From Dynamic Stiffness&#39;</span><span class="p">,</span><span class="s1">&#39;From Modal Parameters&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_54_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_54_0.png" />
</div>
</div>
<p>And here is the general damped case:</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[20]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_modes</span> <span class="o">=</span> <span class="n">omega_general</span><span class="o">.</span><span class="n">size</span>
<span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span>

<span class="n">H_general_fromModes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
    <span class="n">psi_general</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="nd">@psi_general</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">/</span>
    <span class="p">(</span><span class="n">ma_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="o">+</span> <span class="n">psi_general</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="nd">@psi_general</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">/</span>
    <span class="p">(</span><span class="n">ma_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">H_general</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">H_general</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_d</span><span class="p">,</span><span class="n">f_m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_general</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_general_fromModes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_d</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_m</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_d</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_m</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;From Dynamic Stiffness&#39;</span><span class="p">,</span><span class="s1">&#39;From Modal Parameters&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_56_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_56_0.png" />
</div>
</div>
<p>We can see that we understand the relationships between the modal parameters and the frequency response functions.</p>
</section>
</section>
<section id="Solving-for-Modal-Parameters-from-FRFs">
<h2>Solving for Modal Parameters from FRFs<a class="headerlink" href="#Solving-for-Modal-Parameters-from-FRFs" title="Permalink to this heading"></a></h2>
<p>The process of Experimental Modal Analysis involves measuring FRFs and then fitting modal parameters to those FRFs. Many mode fitting software packages utilize a two-step process. First, the poles (frequency and damping) are identified, then the shape information is found. Some curve fitters identify modal participation factors in the first step, which are essentially the mode shapes at the reference degrees of freedom.</p>
<p>This section of the document will follow the implementation of the paper <a class="reference external" href="https://content.iospress.com/articles/shock-and-vibration/sav00272">Peeters, Bart et al. ‘The PolyMAX Frequency-domain Method: a New Standard for Modal Parameter Estimation?’ 1 Jan. 2004 : 395 – 409</a>, which implements the popular PolyMax modal parameter estimator. This is the algorithm implemented in SDynPy’s <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> fitter. Other modal parameter estimators may give similar results.</p>
<section id="Setting-up-the-System-of-Equations">
<h3>Setting up the System of Equations<a class="headerlink" href="#Setting-up-the-System-of-Equations" title="Permalink to this heading"></a></h3>
<p>Let us consider the frequency response function that we may measure during a modal test. We understand that we will only measure a finite bandwidth during the test, therefore there may be contributions to the measured FRFs from modes outside the bandwidth. We will turn our typical FRF matrix equation</p>
<div class="math notranslate nohighlight">
\[\mathbf{H} = \sum_{r=1}^N\left( \frac{\mathbf{\psi}_r\mathbf{\psi}_r^T}{m_r(s-\lambda_r)} + \frac{\mathbf{\psi}_r^*{\mathbf{\psi}_r^*}^T}{m_r(s-\lambda_r^*)}\right)\]</div>
<p>into a “measured” version. We will replace the value <span class="math notranslate nohighlight">\(s\)</span> with <span class="math notranslate nohighlight">\(j\omega\)</span>. We will also introduce lower and upper “residuals” (<span class="math notranslate nohighlight">\(\mathbf{R}_l\)</span> and <span class="math notranslate nohighlight">\(\mathbf{R}_u\)</span>, respectively), to try to fit portions of the FRFs from out-of-band modes. We will explicitly add the notation to show that the frequency response function matrix is a function of frequency <span class="math notranslate nohighlight">\(\omega\)</span>. Additionally, we will call the mode shapes of the references the <em>modal participation factor</em>
<span class="math notranslate nohighlight">\(\mathbf{l}_r\)</span> and the mode shapes corresponding to the responses <span class="math notranslate nohighlight">\(\mathbf{v}\)</span>. Finally, We will remove the modal mass term, which will make the assumption that the modes we fit from the algorithm will be mass normalized. Note that the format of the residual terms implies that the frequency response functions we are investigating here are <em>admittance</em> frequency response functions, which relate the force at a location to the displacement at a location.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}(\omega) = \sum_{r=1}^N\left( \frac{\mathbf{v}_r\mathbf{l}_r^T}{j\omega-\lambda_r} + \frac{\mathbf{v}_r^*{\mathbf{l}_r^*}^T}{j\omega-\lambda_r^*}\right) + \frac{\mathbf{R}_l}{(j\omega)^2} + \mathbf{R}_u\]</div>
<p>Recall the poles <span class="math notranslate nohighlight">\(\lambda_r = -\zeta_r\omega_r + j\omega_r\sqrt{1-\zeta_r^2}\)</span> and <span class="math notranslate nohighlight">\(\lambda_r^* = -\zeta_r\omega_r - j\omega_r\sqrt{1-\zeta_r^2}\)</span>.</p>
<p>The PolyMax approach assumes that the frequency response function can be represented by a right matrix-fraction model.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}(\omega) = \mathbf{B}(\omega)\mathbf{A}(\omega)^{-1}\]</div>
<p>Note that these are not the same <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> matrices from the previous sections, which represent the state space formulation. However, this document attempts to match the notation from the referenced paper, so we will override those previous definitions and apologize for any confusion it may cause.</p>
<p>We can see similarities between the two formulations. The FRF equation has a numerator and a denominator, as well as a summation over a number of modes. Similarly, the right matrix-fraction model has a matrix that is not inverted (representing something like a numerator), a matrix that is inverted (representing something like a denominator), and a summation operation inherent in the matrix multiplication that is performed. Terms in <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> will relate to the shape information in the
numerator of the FRF equation, and terms in <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> will relate to the pole information in the denominator of the FRF equation.</p>
<p>The numerator matrix <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> will have a number of rows equal to the number of responses or outputs <span class="math notranslate nohighlight">\(N_o\)</span> and number of columns equal to the number of references or inputs <span class="math notranslate nohighlight">\(N_i\)</span>. The denominator matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> will have a number of rows and columns equal to the number of inputs <span class="math notranslate nohighlight">\(N_i\)</span>, and is therefore square.</p>
<p>We can split up the above equation and look at an individual row of the FRF matrix, which we will denote <span class="math notranslate nohighlight">\(\mathbf{H}_o\)</span> to represent a single output. This will involve selecting a single row from <span class="math notranslate nohighlight">\(\mathbf{B}_o\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_o(\omega) = \mathbf{B}_o(\omega)\mathbf{A}(\omega)^{-1}\]</div>
<p>Each entry in the <span class="math notranslate nohighlight">\(\mathbf{B}_o\)</span> and <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> matrices is represented as a set of coefficients multiplied by a set of basis functions, similar to how we represent displacements in modal analysis by a set of modal coefficients multiplied by a set of mode shapes. The basis functions <span class="math notranslate nohighlight">\(\Omega_r(\omega)\)</span> are a set of functions that depend on the frequency <span class="math notranslate nohighlight">\(\omega\)</span>. The coefficients are constant with respect to <span class="math notranslate nohighlight">\(\mathbf{\omega}\)</span>. We will call the coefficient of the
<span class="math notranslate nohighlight">\(\mathbf{B}\)</span> matrix corresponding to the <span class="math notranslate nohighlight">\(o\)</span>th row and the <span class="math notranslate nohighlight">\(r\)</span>th basis function <span class="math notranslate nohighlight">\(\beta_{or}\)</span>. Similarly, we will call the coefficient of the <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> matrix for the <span class="math notranslate nohighlight">\(r\)</span>th basis function <span class="math notranslate nohighlight">\(\alpha_r\)</span>. The number of coefficients and basis functions will be equal to the polynomial order <span class="math notranslate nohighlight">\(p+1\)</span>.</p>
<div class="math notranslate nohighlight">
\[\mathbf{B}_o = \sum_{r=0}^p \Omega_r(\omega)\beta_{or}\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{A} = \sum_{r=0}^p \Omega_r(\omega)\alpha_{r}\]</div>
<p>The secret of PolyMax is that instead of using a polynomial basis function for <span class="math notranslate nohighlight">\(\Omega_r(\omega)\)</span>, it instead transforms to the <span class="math notranslate nohighlight">\(z\)</span>-domain. For larger model orders, polynomials will have large exponents, which when applied to large frequency ranges will result in huge differences between the largest and smallest values, which is a sure-fire way to run into numerical issues. Instead, by using the <span class="math notranslate nohighlight">\(z\)</span>-domain, the PolyMax approach avoids these numerical issues and generally
achieves better results. For a test where the minimum measured frequency is <span class="math notranslate nohighlight">\(\omega_0\)</span> and the maximum measured frequency is <span class="math notranslate nohighlight">\(\omega_{end}\)</span>, this frequency range is mapped onto a half-unit circle.</p>
<div class="math notranslate nohighlight">
\[\Omega_r(\omega) = e^{-j\omega_z \Delta t_z r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\omega_z = \omega - \omega_0\)</span> and <span class="math notranslate nohighlight">\(\Delta t_z = \frac{\pi}{\omega_{end}-\omega_0}\)</span>. If instead of angular frequencies, the frequency range is represented in Hz with minimum measured frequency <span class="math notranslate nohighlight">\(f_0\)</span> and maximum measured frequency <span class="math notranslate nohighlight">\(f_{end}\)</span>, then the values are instead <span class="math notranslate nohighlight">\(\omega_z = 2\pi(f - f_0)\)</span> and <span class="math notranslate nohighlight">\(\Delta t_z = \frac{1}{2(f_{end}-f_0)}\)</span> where <span class="math notranslate nohighlight">\(f=\frac{\omega}{2\pi}\)</span>.</p>
<p>The polynomnial coefficients are stacked into matrices.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\beta_o = \begin{bmatrix}\beta_{o0}\\\beta_{o1}\\\beta_{o2}\\\vdots\\\beta_{op}\end{bmatrix}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\alpha = \begin{bmatrix}\alpha_{0}\\\alpha_{1}\\\alpha_{2}\\\vdots\\\alpha_{p}\end{bmatrix}\end{split}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\beta_o\)</span> has number of rows equal to the polynomial order <span class="math notranslate nohighlight">\(p+1\)</span> and number of columns equal to the number of references or inputs <span class="math notranslate nohighlight">\(N_i\)</span>. Each row of <span class="math notranslate nohighlight">\(\beta_o\)</span> corresponds to the coefficients of one polynomial basis function for all of the references.</p>
<p><span class="math notranslate nohighlight">\(\alpha\)</span> also has a number of columns equal to the number of references or inputs <span class="math notranslate nohighlight">\(N_i\)</span>. However, each row partition <span class="math notranslate nohighlight">\(\alpha_r\)</span> of <span class="math notranslate nohighlight">\(\alpha\)</span> has a number of rows equal to the number of inputs <span class="math notranslate nohighlight">\(N_i\)</span> as well. This means after stacking <span class="math notranslate nohighlight">\(p+1\)</span> of these matrices on top of one another, the final number of rows of <span class="math notranslate nohighlight">\(\alpha\)</span> is equal to <span class="math notranslate nohighlight">\(N_i(p+1)\)</span>.</p>
<p>We finally stack all of these coefficients into a single coefficient matrix <span class="math notranslate nohighlight">\(\theta\)</span>, recalling that there is one matrix <span class="math notranslate nohighlight">\(\beta_o\)</span> for each of the <span class="math notranslate nohighlight">\(N_o\)</span> outputs of the system.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\theta = \begin{bmatrix}\beta_{1}\\\beta_{2}\\\beta_{3}\\\vdots\\\beta_{N_o}\\\alpha\end{bmatrix}\end{split}\]</div>
<p>Each row partition in <span class="math notranslate nohighlight">\(\theta\)</span> has columns equal to the number of inputs <span class="math notranslate nohighlight">\(N_i\)</span>. Each of the <span class="math notranslate nohighlight">\(\beta_o\)</span> row partions has number of rows equal to the polynomial order <span class="math notranslate nohighlight">\(p+1\)</span>, and there are <span class="math notranslate nohighlight">\(N_o\)</span> of those partitions, resulting in the <span class="math notranslate nohighlight">\(\beta\)</span> portion of the <span class="math notranslate nohighlight">\(\theta\)</span> matrix having <span class="math notranslate nohighlight">\(N_o(p+1)\)</span> rows. Added to the <span class="math notranslate nohighlight">\(N_i(p+1)\)</span> rows of the <span class="math notranslate nohighlight">\(\alpha\)</span> partition, the final <span class="math notranslate nohighlight">\(\theta\)</span> matrix has <span class="math notranslate nohighlight">\((N_i+N_o)(p+1)\)</span> rows.</p>
<p>At this point, we can represent the FRF matrix as a function of frequency <span class="math notranslate nohighlight">\(\omega\)</span> as well as a function of the coefficients <span class="math notranslate nohighlight">\(\theta\)</span>, <span class="math notranslate nohighlight">\(\mathbf{H}(\omega,\theta)\)</span>.</p>
</section>
<section id="Selecting-Coefficients-that-Minimize-Errors">
<h3>Selecting Coefficients that Minimize Errors<a class="headerlink" href="#Selecting-Coefficients-that-Minimize-Errors" title="Permalink to this heading"></a></h3>
<p>It may be obvious, but the goal is to eventually find the parameters <span class="math notranslate nohighlight">\(\theta\)</span> that best fit some measured frequency response functions. In a real test, we will have measured frequency response functions <span class="math notranslate nohighlight">\(\hat{\mathbf{H}}\)</span> at <span class="math notranslate nohighlight">\(N_f\)</span> discrete frequency values <span class="math notranslate nohighlight">\(\omega_k\)</span>. We would like to find the coefficients <span class="math notranslate nohighlight">\(\theta\)</span> that minimize the error between the fit frequency response functions and the measured frequency response functions. These coefficients can be found by
minimizing the weighted non-linear least-squares error for the <span class="math notranslate nohighlight">\(o\)</span>th output <span class="math notranslate nohighlight">\(\varepsilon_o^{NLS}\)</span></p>
<div class="math notranslate nohighlight">
\[\varepsilon_o^{NLS}(\omega_k,\theta) = w_o(\omega_k)\left(\mathbf{H}_o(\omega_k,\theta) - \hat{\mathbf{H}}_o(\omega_k)\right)\]</div>
<div class="math notranslate nohighlight">
\[\varepsilon_o^{NLS}(\omega_k,\theta) = w_o(\omega_k)\left(\mathbf{B}_o(\omega_k,\beta_o)\mathbf{A}^{-1}(\omega_k,\alpha) - \hat{\mathbf{H}}_o(\omega_k)\right)\]</div>
<p>where <span class="math notranslate nohighlight">\(w_o(\omega_k)\)</span> is a weighting function as a function of the output degree of freedom and the frequency line that allows taking into account data quality in the least-squares solution. The previous equation is a matrix equation, and we would ideally like to transform it into a scalar equation that can be minimized which is only a function of the parameters <span class="math notranslate nohighlight">\(\theta\)</span>.</p>
<div class="math notranslate nohighlight">
\[l^{NLS}(\theta) = \sum_{o=1}^{N_o}\sum_{k=1}^{N_f}\mathrm{tr}\left(\left(\varepsilon_o^{NLS}(\omega_k,\theta)\right)^H\varepsilon_o^{NLS}(\omega_k,\theta)\right)\]</div>
<p>We multiply the value <span class="math notranslate nohighlight">\(\varepsilon_o^{NLS}(\omega_k,\theta)\)</span> complex-conjugate-transpose (<span class="math notranslate nohighlight">\(\bullet^H\)</span>) by itself, and compute the trace (<span class="math notranslate nohighlight">\(\mathrm{tr}(\bullet)\)</span>). We then sum over all frequency lines and all outputs.</p>
<p>This equation is solved by setting the derivatives of the equation with respect to the unknown modal coefficients to zero. It is reasonably clear that this leads to nonlinear equations due to the matrix inverse in the error equation. We can construct a linear set of equations that approximates the original equations by simply post-multiplying the equation by the matrix <span class="math notranslate nohighlight">\(\mathbf{A}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\varepsilon_o^{LS}(\omega_k,\theta) = w_o(\omega_k)\left(\mathbf{B}_o(\omega_k,\beta_o) - \hat{\mathbf{H}}_o(\omega_k)\mathbf{A}(\omega_k,\alpha)\right)\]</div>
<p>Substituting for the basis functions and coefficients:</p>
<div class="math notranslate nohighlight">
\[\varepsilon_o^{LS}(\omega_k,\theta) = w_o(\omega_k)\sum_{r=0}^p\left(
\Omega_r(\omega_k)\beta_{or}
- \Omega_r(\omega_k)\hat{\mathbf{H}}_o(\omega_k)\alpha_r\right)\]</div>
<p>We can stack this equation for all frequency lines (<span class="math notranslate nohighlight">\(\omega_1\)</span>, <span class="math notranslate nohighlight">\(\omega_2\)</span>, … <span class="math notranslate nohighlight">\(\omega_{N_f}\)</span>)</p>
<div class="math notranslate nohighlight">
\[\begin{split}E_o^{LS}(\theta) = \begin{bmatrix}
\varepsilon_o^{LS}(\omega_1,\theta) \\
\varepsilon_o^{LS}(\omega_2,\theta) \\
\vdots \\
\varepsilon_o^{LS}(\omega_{N_f},\theta) \\
\end{bmatrix} = \begin{bmatrix}\mathbf{X}_o &amp; \mathbf{Y}_o \end{bmatrix}\begin{bmatrix}\beta_o\\\alpha\end{bmatrix}\end{split}\]</div>
<p>This will result in <span class="math notranslate nohighlight">\(E_o^{LS}(\theta)\)</span> having a number of rows equal to the number of frequency lines in the test, and the number of columns equal to the number of references or inputs <span class="math notranslate nohighlight">\(N_i\)</span>.</p>
<p>The <span class="math notranslate nohighlight">\(\mathbf{X}_o\)</span> matrix can be constructed from pulling off the coefficients of the <span class="math notranslate nohighlight">\(\beta\)</span> terms, which are generally the basis functions <span class="math notranslate nohighlight">\(\Omega_r\)</span> evaluated at each frequency line <span class="math notranslate nohighlight">\(\omega_k\)</span>. Each row will correspond to a separate frequency line, and each column will correspond to a basis function order.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{X}_o = \begin{bmatrix}
w_o(\omega_1)\Omega_0(\omega_1) &amp; w_o(\omega_1)\Omega_1(\omega_1) &amp; \cdots &amp; w_o(\omega_1)\Omega_p(\omega_1)\\
w_o(\omega_2)\Omega_0(\omega_2) &amp; w_o(\omega_2)\Omega_1(\omega_2) &amp; \cdots &amp; w_o(\omega_2)\Omega_p(\omega_2)\\
\vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
w_o(\omega_{N_f})\Omega_0(\omega_{N_f}) &amp; w_o(\omega_{N_f})\Omega_1(\omega_{N_f}) &amp; \cdots &amp; w_o(\omega_{N_f})\Omega_p(\omega_{N_f})\\
\end{bmatrix}\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(\mathbf{Y}_o\)</span> matrix can be constructed by pulling off the coefficients of the <span class="math notranslate nohighlight">\(\alpha\)</span> terms, which are generally the basis functions somehow multiplied by the FRFs. We will explore this expression a bit more here. The relevant portion of <span class="math notranslate nohighlight">\(\varepsilon_o^{LS}(\omega_k,\theta)\)</span> containing the <span class="math notranslate nohighlight">\(\alpha\)</span> terms is</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{Y}_o \alpha = -\begin{bmatrix}
    \sum_{r=0}^pw_o(\omega_1)\Omega_r(\omega_1)\hat{\mathbf{H}}_o(\omega_1)\alpha_r \\
    \sum_{r=0}^pw_o(\omega_2)\Omega_r(\omega_2)\hat{\mathbf{H}}_o(\omega_2)\alpha_r \\
    \vdots \\
    \sum_{r=0}^pw_o(\omega_{N_f})\Omega_r(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f})\alpha_r\end{bmatrix}\end{split}\]</div>
<p>Expanding the equation out in terms of the summation can help visualize which terms go where in the <span class="math notranslate nohighlight">\(\mathbf{Y}_o\)</span> matrix.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{Y}_o \begin{bmatrix}
        \alpha_0 \\
        \alpha_1 \\
        \vdots \\
        \alpha_p
        \end{bmatrix} = -\begin{bmatrix}
    w_o(\omega_1) \left( \Omega_0(\omega_1)\hat{\mathbf{H}}_o(\omega_1)\alpha_0 + \Omega_1(\omega_1)\hat{\mathbf{H}}_o(\omega_1)\alpha_1 + \dots + \Omega_p(\omega_1)\hat{\mathbf{H}}_o(\omega_1)\alpha_p \right) \\
    w_o(\omega_2) \left( \Omega_0(\omega_2)\hat{\mathbf{H}}_o(\omega_2)\alpha_0 + \Omega_1(\omega_2)\hat{\mathbf{H}}_o(\omega_2)\alpha_1 + \dots + \Omega_p(\omega_2)\hat{\mathbf{H}}_o(\omega_2)\alpha_p \right) \\
    \vdots \\
    w_o(\omega_{N_f}) \left( \Omega_0(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f})\alpha_0 + \Omega_1(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f})\alpha_1 + \dots + \Omega_p(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f})\alpha_p \right) \\
    \end{bmatrix}\end{split}\]</div>
<p>or in matrix form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{Y}_o \begin{bmatrix}
        \alpha_0 \\
        \alpha_1 \\
        \vdots \\
        \alpha_p
        \end{bmatrix} = -\begin{bmatrix}
    w_o(\omega_1)\Omega_0(\omega_1)\hat{\mathbf{H}}_o(\omega_1) &amp; w_o(\omega_1)\Omega_1(\omega_1)\hat{\mathbf{H}}_o(\omega_1) &amp; \dots &amp; w_o(\omega_1)\Omega_p(\omega_1)\hat{\mathbf{H}}_o(\omega_1) \\
    w_o(\omega_2)\Omega_0(\omega_2)\hat{\mathbf{H}}_o(\omega_2) &amp; w_o(\omega_2)\Omega_1(\omega_2)\hat{\mathbf{H}}_o(\omega_2) &amp; \dots &amp; w_o(\omega_2)\Omega_p(\omega_2)\hat{\mathbf{H}}_o(\omega_2) \\
    \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\
    w_o(\omega_{N_f})\Omega_0(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f}) &amp; w_o(\omega_{N_f})\Omega_1(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f}) &amp; \dots &amp; w_o(\omega_{N_f})\Omega_p(\omega_{N_f})\hat{\mathbf{H}}_o(\omega_{N_f}) \\
    \end{bmatrix}\begin{bmatrix}
        \alpha_0 \\
        \alpha_1 \\
        \vdots \\
        \alpha_p
        \end{bmatrix}\end{split}\]</div>
<p>We can recognize the pattern <span class="math notranslate nohighlight">\(\begin{bmatrix}\Omega_0\hat{\mathbf{H}}_o &amp; \Omega_1\hat{\mathbf{H}}_o &amp; \dots &amp; \Omega_p\hat{\mathbf{H}}_o\end{bmatrix}\)</span> as the <a class="reference external" href="https://en.wikipedia.org/wiki/Kronecker_product">Kronecker Product</a> <span class="math notranslate nohighlight">\(\mathbf{\Omega} \otimes \hat{\mathbf{H}}_o\)</span> where the matrix <span class="math notranslate nohighlight">\(\mathbf{\Omega}\)</span> has only one row. Therefore,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{X}_o = \begin{bmatrix}
w_o(\omega_1)\mathbf{\Omega}(\omega_1)\\
w_o(\omega_2)\mathbf{\Omega}(\omega_2)\\
\vdots \\
w_o(\omega_{N_f})\mathbf{\Omega}(\omega_{N_f})\\
\end{bmatrix}\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{Y}_o = -\begin{bmatrix}
    w_o(\omega_1)\mathbf{\Omega}(\omega_1)\otimes\hat{\mathbf{H}}_o(\omega_1)\\
    w_o(\omega_2)\mathbf{\Omega}(\omega_2)\otimes\hat{\mathbf{H}}_o(\omega_2)\\
    \vdots\\
    w_o(\omega_{N_f})\mathbf{\Omega}(\omega_{N_f})\otimes\hat{\mathbf{H}}_o(\omega_{N_f})\\
    \end{bmatrix}\end{split}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf{\Omega}(\omega) = \begin{bmatrix}\Omega_0(\omega)&amp;\Omega_1(\omega)&amp;\dots&amp;\Omega_p(\omega)\end{bmatrix}\)</span></p>
<p>Similarly to the nonlinear least squares solution, we can construct an error cost function to minimize based on the linearized equation.</p>
<div class="math notranslate nohighlight">
\[l^{LS}(\theta) = \sum_{o=1}^{N_o}\sum_{k=1}^{N_f}\mathrm{tr}\left(\left(\varepsilon_o^{LS}(\omega_k,\theta)\right)^H\varepsilon_o^{LS}(\omega_k,\theta)\right)\]</div>
<p>or</p>
<div class="math notranslate nohighlight">
\[l^{LS}(\theta) = \sum_{o=1}^{N_o}\mathrm{tr}\left(\left(E_o^{LS}(\omega_k,\theta)\right)^HE_o^{LS}(\omega_k,\theta)\right)\]</div>
<p>If we substitute the matrix equations, we get</p>
<div class="math notranslate nohighlight">
\[\begin{split}l^{LS}(\theta) = \sum_{o=1}^{N_o}\mathrm{tr}\left(
\begin{bmatrix}\beta_o^T &amp; \alpha^T\end{bmatrix}\begin{bmatrix}\mathbf{X}_o^H \\ \mathbf{Y}_o^H\end{bmatrix}\begin{bmatrix}\mathbf{X}_o &amp; \mathbf{Y}_o\end{bmatrix}\begin{bmatrix}\beta_o \\ \alpha\end{bmatrix}\right)\end{split}\]</div>
<p>Ideally, we would like to remove the summation in the previous equation and end up with an equation of the form <span class="math notranslate nohighlight">\(l^{LS}(\theta) = \mathrm{tr}\left(\mathbf{\theta}^T\mathbf{J}^H\mathbf{J}\mathbf{\theta}\right)\)</span>. We recognize that we can stack the equations for <span class="math notranslate nohighlight">\(E_o^{LS}\)</span> for all outputs and arrive at an equation</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}E_1^{LS} \\ E_2^{LS} \\ \vdots \\ E_{N_o}^{LS} \end{bmatrix} =
\begin{bmatrix}
    \begin{bmatrix}\mathbf{X}_1 &amp; \mathbf{Y}_1\end{bmatrix}\begin{bmatrix}\beta_1 \\ \alpha\end{bmatrix} \\
    \begin{bmatrix}\mathbf{X}_2 &amp; \mathbf{Y}_2\end{bmatrix}\begin{bmatrix}\beta_2 \\ \alpha\end{bmatrix} \\
    \vdots \\
    \begin{bmatrix}\mathbf{X}_{N_o} &amp; \mathbf{Y}_{N_o}\end{bmatrix}\begin{bmatrix}\beta_{N_o} \\ \alpha\end{bmatrix}\end{bmatrix} =
\begin{bmatrix}\mathbf{X}_1 &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0} &amp; \mathbf{Y}_1 \\
               \mathbf{0} &amp; \mathbf{X}_2 &amp; \dots &amp; \mathbf{0} &amp; \mathbf{Y}_2 \\
               \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
               \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{X}_{N_o} &amp; \mathbf{Y}_{N_o} \end{bmatrix}\begin{bmatrix}\beta_{1}\\\beta_{2}\\\vdots\\\beta_{N_o}\\\alpha\end{bmatrix}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{J} = \begin{bmatrix}\mathbf{X}_1 &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0} &amp; \mathbf{Y}_1 \\
               \mathbf{0} &amp; \mathbf{X}_2 &amp; \dots &amp; \mathbf{0} &amp; \mathbf{Y}_2 \\
               \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
               \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{X}_{N_o} &amp; \mathbf{Y}_{N_o} \end{bmatrix}\end{split}\]</div>
<p>and as we’ve seen previously,</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\theta} = \begin{bmatrix}\beta_{1}\\\beta_{2}\\\vdots\\\beta_{N_o}\\\alpha\end{bmatrix}\end{split}\]</div>
<p>Therefore our cost function can be simplified to</p>
<div class="math notranslate nohighlight">
\[l^{LS}(\theta) = \mathrm{tr}\left(\mathbf{\theta}^T\mathbf{J}^H\mathbf{J}\mathbf{\theta}\right)\]</div>
<p>In general, the quantity <span class="math notranslate nohighlight">\(\mathbf{J}^H\mathbf{J}\)</span> will be conjugate-symmetric or <a class="reference external" href="https://en.wikipedia.org/wiki/Hermitian_matrix">Hermitian</a>. This means that its upper triangle will be equal to the complex conjugate of the lower triangle transposed, and the diagonal will be real valued. While the matrix <span class="math notranslate nohighlight">\(\mathbf{J}^H\mathbf{J}\)</span> is therefore complex, in the previous equation, because it multiplies by real valued coefficients <span class="math notranslate nohighlight">\(\mathbf{\theta}\)</span> and we take the trace, which
should only select the real-valued diagonal, we can replace the quantity <span class="math notranslate nohighlight">\(\mathbf{J}^H\mathbf{J}\)</span> with its real part <span class="math notranslate nohighlight">\(\Re\left(\mathbf{J}^H\mathbf{J}\right)\)</span></p>
<p>Computing <span class="math notranslate nohighlight">\(\Re\left(\mathbf{J}^H\mathbf{J}\right)\)</span> gives</p>
<div class="math notranslate nohighlight">
\[\begin{split}\Re\left(\mathbf{J}^H\mathbf{J}\right) = \begin{bmatrix}\mathbf{R}_1 &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0} &amp; \mathbf{S}_1 \\
                                                          \mathbf{0} &amp; \mathbf{R}_2 &amp; \dots &amp; \mathbf{0} &amp; \mathbf{S}_2 \\
                                                          \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
                                                          \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{R}_{N_o} &amp; \mathbf{S}_{N_o} \\
                                                          \mathbf{S}_1^T &amp; \mathbf{S}_2^T &amp; \dots &amp; \mathbf{S}_{N_o} &amp; \sum_{o=1}^{N_o}T_o
                                                          \end{bmatrix}\end{split}\]</div>
<p>where</p>
<div class="math notranslate nohighlight">
\[\mathbf{R}_o = \Re\left(\mathbf{X}_o^H\mathbf{X}_o\right)\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{S}_o = \Re\left(\mathbf{X}_o^H\mathbf{Y}_o\right)\]</div>
<div class="math notranslate nohighlight">
\[\mathbf{T}_o = \Re\left(\mathbf{Y}_o^H\mathbf{Y}_o\right)\]</div>
<p>We minimize the cost function by setting the derivatives of the cost function with respect to the coefficients <span class="math notranslate nohighlight">\(\mathbf{\theta}\)</span> to zero.</p>
<div class="math notranslate nohighlight">
\[\begin{split}l^{LS}(\theta) = \mathrm{tr}\left(\begin{bmatrix}\beta_{1}\\\beta_{2}\\\vdots\\\beta_{N_o}\\\alpha\end{bmatrix}^T\begin{bmatrix}\mathbf{R}_1 &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0} &amp; \mathbf{S}_1 \\
                                                          \mathbf{0} &amp; \mathbf{R}_2 &amp; \dots &amp; \mathbf{0} &amp; \mathbf{S}_2 \\
                                                          \vdots &amp; \vdots &amp; \ddots &amp; \vdots &amp; \vdots \\
                                                          \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{R}_{N_o} &amp; \mathbf{S}_{N_o} \\
                                                          \mathbf{S}_1^T &amp; \mathbf{S}_2^T &amp; \dots &amp; \mathbf{S}_{N_o} &amp; \sum_{o=1}^{N_o}T_o
                                                          \end{bmatrix}\begin{bmatrix}\beta_{1}\\\beta_{2}\\\vdots\\\beta_{N_o}\\\alpha\end{bmatrix}\right)\end{split}\]</div>
<p>Expanding the multiplication gives</p>
<div class="math notranslate nohighlight">
\[l^{LS}(\theta) = \mathrm{tr}\left(
    \sum_{o=1}^{N_o}\left(\beta_o^T\mathbf{R}_o\beta_o\right) +
    \sum_{o=1}^{N_o}\left(\alpha^T\mathbf{S}_o^T\beta_o\right) +
    \sum_{o=1}^{N_o}\left(\beta_o^T\mathbf{S}_o\alpha\right) +
    \sum_{o=1}^{N_o}\left(\alpha^T\mathbf{T}_o\alpha\right)\right)\]</div>
<div class="math notranslate nohighlight">
\[l^{LS}(\theta) = \mathrm{tr}\sum_{o=1}^{N_o}\left(
    \beta_o^T\mathbf{R}_o\beta_o +
    \alpha^T\mathbf{S}_o^T\beta_o +
    \beta_o^T\mathbf{S}_o\alpha +
    \alpha^T\mathbf{T}_o\alpha\right)\]</div>
<p>We can therefore compute the partial derivatives with respect to the unknown coefficients and set them to zero.</p>
<div class="math notranslate nohighlight">
\[\frac{\partial l^{LS}(\theta)}{\partial \beta_o} =
    2\mathbf{R}_o\beta_o +
    2\mathbf{S}_o\alpha = \mathbf{0}\]</div>
<div class="math notranslate nohighlight">
\[\frac{\partial l^{LS}(\theta)}{\partial \alpha} =
    \sum_{o=1}^{N_o}\left(
    2\mathbf{S}_o^T\beta_o +
    2\mathbf{T}_o\alpha\right) =\mathbf{0}\]</div>
<p>As a first pass, we only care about the poles, which come from the denominator terms <span class="math notranslate nohighlight">\(\alpha\)</span>. We can eliminate the <span class="math notranslate nohighlight">\(\beta_o\)</span> terms using the first of these constraints</p>
<div class="math notranslate nohighlight">
\[\beta_o = -\mathbf{R}_o^{-1}\mathbf{S}_o\alpha\]</div>
<p>We can then plug this into the second constraint to get an equation for <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\left[2\sum_{o=1}^{N_o}\left(
    \mathbf{T}_o - \mathbf{S}_o^T\mathbf{R}_o^{-1}\mathbf{S}_o\right)\right]\alpha= \mathbf{M}\alpha= \mathbf{0}\]</div>
<p>This matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is a square matrix with number of rows and columns equal to the number of inputs times the polynomial order <span class="math notranslate nohighlight">\(N_i(p+1) \times N_i(p+1)\)</span>, and depends only on the measured FRFs from the test. Note, however, that this equation is not unique. For example, the trival solution <span class="math notranslate nohighlight">\(\alpha = \mathbf{0}\)</span> satisfies this equation. Additionally, one may see that in the right matrix-fraction formulation $ <span class="math">\mathbf{H}`(:nbsphinx-math:</span>omega`) =
<span class="math">\mathbf{B}`(:nbsphinx-math:</span>omega`):nbsphinx-math:<cite>mathbf{A}`(:nbsphinx-math:</cite>omega`)^{-1}$, one could multiply both <span class="math notranslate nohighlight">\(\mathbf{A}\)</span> and <span class="math notranslate nohighlight">\(\mathbf{B}\)</span> by the same matrix, and the equation would still be satisfied. Therefore, there is not a unique value for <span class="math notranslate nohighlight">\(\alpha\)</span>.</p>
</section>
<section id="Solving-the-Constrained-Problem">
<h3>Solving the Constrained Problem<a class="headerlink" href="#Solving-the-Constrained-Problem" title="Permalink to this heading"></a></h3>
<p>To solve a problem of the form <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{x} = \mathbf{0}\)</span> for the non-trivial <span class="math notranslate nohighlight">\(\mathbf{x}\)</span>, we must apply some constraint to the problem.</p>
<p>To solve the problem, we will partition the matrix <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> as follows</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{M} = \begin{bmatrix}\mathbf{M}_{aa} &amp; \mathbf{M}_{ab} \\
                              \mathbf{M}_{ba} &amp; \mathbf{M}_{bb}\end{bmatrix}\end{split}\]</div>
<p>where the <span class="math notranslate nohighlight">\(a\)</span> indices are the first <span class="math notranslate nohighlight">\(N_ip\)</span> rows or columns and the <span class="math notranslate nohighlight">\(b\)</span> indices are the last <span class="math notranslate nohighlight">\(p\)</span> columns, recalling the size of <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> is <span class="math notranslate nohighlight">\(N_i(p+1)\)</span>. Therefore the matrix <span class="math notranslate nohighlight">\(\mathbf{M}_{aa}\)</span> matrix will have size <span class="math notranslate nohighlight">\(N_ip\times N_ip\)</span>, the <span class="math notranslate nohighlight">\(\mathbf{M}_{ab}\)</span> matrix will have size <span class="math notranslate nohighlight">\(N_ip\times p\)</span>, the <span class="math notranslate nohighlight">\(\mathbf{M}_{ba}\)</span> matrix will have size <span class="math notranslate nohighlight">\(p\times N_ip\)</span>, and the <span class="math notranslate nohighlight">\(\mathbf{M}_{bb}\)</span> matrix will have size <span class="math notranslate nohighlight">\(p\times p\)</span>.</p>
<p>Because we must apply constraints to our problem, we will make the assumption that our solution matrix <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span> will have the form</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{\alpha} = \begin{bmatrix}\hat{\mathbf{\alpha}}  \\
                                   \mathbf{I}\end{bmatrix}\end{split}\]</div>
<p>We can see that if we plug this version of <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span> into the equation, we get an expression for the portion of <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span> that was not constrained.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{M}_{aa} &amp; \mathbf{M}_{ab} \\
                 \mathbf{M}_{ba} &amp; \mathbf{M}_{bb}\end{bmatrix}
  \begin{bmatrix}\hat{\mathbf{\alpha}}  \\
                 \mathbf{I}\end{bmatrix} =
  \begin{bmatrix}\mathbf{M}_{aa}\hat{\alpha} + \mathbf{M}_{ab}\\
                 \mathbf{M}_{ba}\hat{\alpha} + \mathbf{M}_{bb}\end{bmatrix} =
   \begin{bmatrix}\mathbf{0} \\
                  \mathbf{0}\end{bmatrix}\end{split}\]</div>
<p>We can then simply take the top partition to solve for <span class="math notranslate nohighlight">\(\hat{\alpha}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\hat{\alpha} = -\mathbf{M}_{aa}^{-1}\mathbf{M}_{ab}\]</div>
</section>
<section id="Extracting-Poles-and-Participation-Factors">
<h3>Extracting Poles and Participation Factors<a class="headerlink" href="#Extracting-Poles-and-Participation-Factors" title="Permalink to this heading"></a></h3>
<p>Now that we have the polynomial coefficients <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span> for the right matrix-fraction model, we would like to extract the roots from it. The roots of this polynomial are the poles of the frequency response function. We will do this by setting up a <a class="reference external" href="https://en.wikipedia.org/wiki/Companion_matrix">Companion Matrix</a>. A Companion matrix of a polynomial is a matrix whose characteristic equation is equal to that polynomial. Then the eigenvalues of the matrix (which are the roots of the
characteristic equation) are also the roots of the polynomial. In our case, the eigenvectors are also useful, as they are related to the participation factors.</p>
<p>For a polynomial <span class="math notranslate nohighlight">\(p(x) = \alpha_p x^p + \alpha_{p-1} x^{p-1} + \dots + \alpha_2 x^2 + \alpha_1 x + \alpha_0\)</span>, the companion matrix will be</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{C} = \begin{bmatrix} 0 &amp; 1 &amp; 0 &amp; \dots &amp; 0\\
                               0 &amp; 0 &amp; 1 &amp; \dots &amp; 0\\
                               \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
                               0 &amp; 0 &amp; 0 &amp; \dots &amp; 1\\
                               -\frac{\alpha_0}{\alpha_p} &amp; -\frac{\alpha_1}{\alpha_p} &amp; -\frac{\alpha_2}{\alpha_p} &amp; \dots &amp; -\frac{\alpha_{p-1}}{\alpha_p}
                               \end{bmatrix}\end{split}\]</div>
<p>Readers can verify that <span class="math notranslate nohighlight">\(\mathrm{det}(\mathbf{I}x - \mathbf{C}) = p(x)\)</span>.</p>
<p>Our present case is slightly different, because our coefficients are matrices rather than scalars.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{C} = \begin{bmatrix} \mathbf{0} &amp; \mathbf{I} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0}\\
                               \mathbf{0} &amp; \mathbf{0} &amp; \mathbf{I} &amp; \dots &amp; \mathbf{0}\\
                               \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
                               \mathbf{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{I}\\
                               -\alpha_0^T{\alpha_p^T}^{-1} &amp; -\alpha_1^T{\alpha_p^T}^{-1} &amp; -\alpha_2^T{\alpha_p^T}^{-1} &amp; \dots &amp; -\alpha_{p-1}^T{\alpha_p^T}^{-1}
                               \end{bmatrix}\end{split}\]</div>
<p>However, because we applied the constraint such that <span class="math notranslate nohighlight">\(\alpha_p = \mathbf{I}\)</span> when solving for <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span>, the quantity <span class="math notranslate nohighlight">\(\alpha_p^{-1} = \mathbf{I}\)</span>, and the remaining terms are those in <span class="math notranslate nohighlight">\(\hat{\mathbf{\alpha}}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{C} = \begin{bmatrix} \mathbf{0} &amp; \mathbf{I} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0}\\
                               \mathbf{0} &amp; \mathbf{0} &amp; \mathbf{I} &amp; \dots &amp; \mathbf{0}\\
                               \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
                               \mathbf{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{I}\\
                               -\hat{\alpha_0}^T &amp; -\hat{\alpha_1}^T &amp; -\hat{\alpha_2}^T &amp; \dots &amp; -\hat{\alpha}_{p-1}^T
                               \end{bmatrix}\end{split}\]</div>
<p>The <span class="math notranslate nohighlight">\(\mathbf{C}\)</span> matrix will be a square matrix with size <span class="math notranslate nohighlight">\(N_ip \times N_ip\)</span> where <span class="math notranslate nohighlight">\(N_i\)</span> is the number of inputs or references, and <span class="math notranslate nohighlight">\(p\)</span> is the order of the polynomial.</p>
<p>We can therefore notate the companion matrix compactly as</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{C} = \begin{bmatrix} \begin{matrix}\mathbf{0} &amp; \mathbf{I}\end{matrix} \\ \begin{matrix}-\hat{\alpha}^T\end{matrix}\end{bmatrix}\end{split}\]</div>
<p>We can then solve for the eigenvalues and eigenvectors of this matrix. The companion matrix is set up such that its characteristic polynomial is identical to the polynomial it represents. Therefore, its eigenvalues, which are roots of the characteristic polynomial, will be roots of the polynomial it represents.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{C}\mathbf{V} = \begin{bmatrix} \mathbf{0} &amp; \mathbf{I} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{0}\\
                                \mathbf{0} &amp; \mathbf{0} &amp; \mathbf{I} &amp; \dots &amp; \mathbf{0}\\
                                \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots\\
                                \mathbf{0} &amp; \mathbf{0} &amp; \mathbf{0} &amp; \dots &amp; \mathbf{I}\\
                                -\hat{\alpha_0}^T &amp; -\hat{\alpha_1}^T &amp; -\hat{\alpha_2}^T &amp; \dots &amp; -\hat{\alpha}_{p-1}^T
                                \end{bmatrix}\mathbf{V}= \mathbf{\Lambda}\mathbf{V}\end{split}\]</div>
<p>The diagonals of the eigenvector matrix <span class="math notranslate nohighlight">\(\bar{\lambda}_r = \mathbf{\Lambda}_{rr}\)</span> are the eigenvalues of the companion matrix. These are the poles of the system; however, we must remember they are represented in the <span class="math notranslate nohighlight">\(z\)</span>-domain, so we must return to the <span class="math notranslate nohighlight">\(s\)</span>-domain <span class="math notranslate nohighlight">\(\lambda_r\)</span> in order to solve for the natural frequency and damping ratio.</p>
<div class="math notranslate nohighlight">
\[\bar{\lambda}_r = e^{-\lambda_r \Delta t_z}\]</div>
<div class="math notranslate nohighlight">
\[\lambda_r = -\frac{\log{\lambda_r}}{\Delta t_z}\]</div>
<p>where <span class="math notranslate nohighlight">\(\Delta t_z = \frac{\pi}{\omega_{end}-\omega_0}\)</span>.</p>
<p>We can then solve for the natural frequency and damping ratio from the poles. Recall that the frequency was shifted by <span class="math notranslate nohighlight">\(\omega_0\)</span> during the mapping, so we will need to take that into account.</p>
<div class="math notranslate nohighlight">
\[{\omega_z}_r = \left|\lambda_r\right|\]</div>
<div class="math notranslate nohighlight">
\[{\omega_r} = {\omega_z}_r + \omega_0\]</div>
<div class="math notranslate nohighlight">
\[\zeta_r = -\frac{\Re\left({\lambda_r}\right)}{\omega_r}\]</div>
<p>Note that there will be in general <span class="math notranslate nohighlight">\(N_ip\)</span> eigenvalues. Half of them will be complex conjugates of the other half, so we can ignore those. Similarly, we can ignore non-physical eigenvalues. A criteria that is successfully used is to only keep poles where the real part is less than zero and the imaginary part is greater than zero.</p>
<p>The modal participation factors <span class="math notranslate nohighlight">\(\mathbf{l}_r\)</span> can be determined from the eigenvectors of the companion matrix. They will be the last <span class="math notranslate nohighlight">\(N_i\)</span> rows of the eigenvector matrix. One must also be sure that for each eigenvalue discarded for being non-physical or complex conjugate, the corresponding eigenvector should also be discarded.</p>
</section>
<section id="Stabilization-Diagrams">
<h3>Stabilization Diagrams<a class="headerlink" href="#Stabilization-Diagrams" title="Permalink to this heading"></a></h3>
<p>Solving for a polynomial of a particular order will in general result in a large number of poles. For a typical problem, only a subset of these poles will correspond to true modes of the structure. For a typical modal test, it may not be obvious how many modes are in a given bandwidth anyways. Therefore, we need some kind of metric to determine if a pole is valid or not, and for this we utilize the stabilization diagram.</p>
<p>A stabilization diagram is constructed by computing the poles over a large number of polynomial orders. As we increase the polynomial orders, more poles may be found in the system. We declare a <em>stable pole</em> to be one which does not change significantly as the polynomial order changes. Computational poles may bounce around the measurement bandwidth. Real poles of the system, on the other hand, will generally result in a similar frequency, damping ratio, and set of participation factors
regardless of the polynomial order. We then construct a final set of poles by selecting from the stable poles in the stabilization diagram.</p>
</section>
<section id="Back-to-the-Example-Problem">
<h3>Back to the Example Problem<a class="headerlink" href="#Back-to-the-Example-Problem" title="Permalink to this heading"></a></h3>
<p>To demonstrate the equations shown here, we will implement the previous equations in code. We will demonstrate solution of one polynomial order to demonstrate the process, and then rely on the implementation in SDynPy to perform the rest of the analysis. We will initially focus only on the general damping case rather than repeating the analysis for all the damping matrices.</p>
<p>To start, we will pull in the measured frequency response functions and corresponding frequency values. We will shape the frequency response function such that it is a 3D array with shape <span class="math notranslate nohighlight">\(N_o \times N_i \times N_f\)</span>. We will also assume that we only peformed measurements with inputs at the first and second degrees of freedom.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[21]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">H</span> <span class="o">=</span> <span class="n">H_general</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)[:,:</span><span class="mi">2</span><span class="p">,:]</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">H</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[22]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(3, 2, 1000)
</pre></div></div>
</div>
<p>We will also assume that we only performed measurements over a limited bandwidth from 10 rad/s to 80 rad/s.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[23]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">frequency_lines_to_keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">omegas</span> <span class="o">&gt;</span> <span class="mi">10</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">omegas</span> <span class="o">&lt;</span> <span class="mi">80</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="p">[:,:,</span><span class="n">frequency_lines_to_keep</span><span class="p">]</span>
<span class="n">omegas</span> <span class="o">=</span> <span class="n">omegas</span><span class="p">[</span><span class="n">frequency_lines_to_keep</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Now that we have truncated the frequency domain, we will define some helper variables to make the code a bit more intuitive.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[24]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_output</span><span class="p">,</span> <span class="n">num_input</span><span class="p">,</span> <span class="n">num_freq</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">shape</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Num Outputs: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">Num Inputs: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">Num Frequencies: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">num_output</span><span class="p">,</span> <span class="n">num_input</span><span class="p">,</span> <span class="n">num_freq</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Num Outputs: 3
Num Inputs: 2
Num Frequencies: 778
</pre></div></div>
</div>
<p>We will also set our polynomial order. In this case, we know that there are 3 modes of the structure in the bandwidth. However, let’s select 5 as the polynomial order, as we generally would like to overfit the model. Keep in mind that this will result in 6 polynomial coefficients: 0, 1, 2, 3, 4, and 5. Therefore, you shouldn’t be confused when dimensions of arrays associated with the polynomial order have length 6 instead of length 5.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[25]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">order</span> <span class="o">=</span> <span class="mi">5</span>
</pre></div>
</div>
</div>
<p>We will assume no weighting, or rather the weighting is identically 1 across all outputs and across all frequencies.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[26]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">weighting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">num_freq</span><span class="p">,</span><span class="n">num_output</span><span class="p">))</span>
</pre></div>
</div>
</div>
<p>The first thing we will do is to set up our <span class="math notranslate nohighlight">\(\mathbf{\Omega}_r(\omega) = e^{-j\omega_z\Delta t_z r}\)</span> vectors. We will set this up as an array with number of rows equal to number of frequency lines and number of columns equal to the number of polynomial coefficients.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">omega_z</span> <span class="o">=</span> <span class="n">omegas</span> <span class="o">-</span> <span class="n">omegas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="c1"># Perform the shift</span>
<span class="n">deltat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">omegas</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># Compute the scale factor</span>
<span class="n">Omega</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">omega_z</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">deltat</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">order</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span> <span class="c1"># Compute Omega</span>
<span class="n">Omega</span><span class="o">.</span><span class="n">shape</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[27]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(778, 6)
</pre></div></div>
</div>
<p>In the previous code, we use broadcasting to set up our <span class="math notranslate nohighlight">\(\mathbf{\Omega}_r\)</span> array. We add a <code class="docutils literal notranslate"><span class="pre">newaxis</span></code> to our shifted frequency vector <span class="math notranslate nohighlight">\(\omega_z\)</span> to make it a <code class="docutils literal notranslate"><span class="pre">num_freq</span></code> <span class="math notranslate nohighlight">\(\times\)</span> 1 array. This is then multiplied by an array <code class="docutils literal notranslate"><span class="pre">[0,1,2,3,4,5]</span></code> constructed from the <code class="docutils literal notranslate"><span class="pre">arange</span></code> function. Per <a class="reference external" href="https://numpy.org/doc/stable/user/basics.broadcasting.html">Numpy’s Broadcasting Rules</a>, a <code class="docutils literal notranslate"><span class="pre">num_freq</span></code> <span class="math notranslate nohighlight">\(\times\)</span> 1 array and a <code class="docutils literal notranslate"><span class="pre">order+1</span></code> array will be broadcast to a <code class="docutils literal notranslate"><span class="pre">num_freq</span></code>
<span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">order+1</span></code> array. Multiplying by scalars <code class="docutils literal notranslate"><span class="pre">deltat</span></code> and <code class="docutils literal notranslate"><span class="pre">-1j</span></code> get performed elementwise, as does the exponential function <code class="docutils literal notranslate"><span class="pre">exp</span></code>.</p>
<p>The next step will be to assemble the <span class="math notranslate nohighlight">\(\mathbf{R}_o\)</span>, <span class="math notranslate nohighlight">\(\mathbf{S}_o\)</span>, and <span class="math notranslate nohighlight">\(\mathbf{T}_o\)</span> matrices. These are built from the <span class="math notranslate nohighlight">\(\mathbf{X}_o\)</span> and <span class="math notranslate nohighlight">\(\mathbf{Y}_o\)</span> matrices.</p>
<p>Before we do this let’s think about the dimensions of the arrays. The matrix <span class="math notranslate nohighlight">\(\mathbf{R}_o\)</span> for each output will have dimension <code class="docutils literal notranslate"><span class="pre">order+1</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">order+1</span></code>. The matrix <span class="math notranslate nohighlight">\(\mathbf{S}_o\)</span> for each output will have dimension <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">+</span> <span class="pre">1</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">num_input*(order+1)</span></code>. The <span class="math notranslate nohighlight">\(\mathbf{T}_o\)</span> matrix for each output will have dimension <code class="docutils literal notranslate"><span class="pre">num_input*(order+1)</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">num_input*(order+1)</span></code>. Because we will have <code class="docutils literal notranslate"><span class="pre">num_output</span></code> of each of these matrices, we will
consider assembling them into a 3D array with dimension <code class="docutils literal notranslate"><span class="pre">num_output</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">...</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">...</span></code> .</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[28]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_output</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
<span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_output</span><span class="p">,</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num_input</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
<span class="n">T</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="n">num_output</span><span class="p">,</span> <span class="n">num_input</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">num_input</span> <span class="o">*</span> <span class="p">(</span><span class="n">order</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  R: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  S: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  T: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">S</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">T</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  R: (3, 6, 6)
  S: (3, 6, 12)
  T: (3, 12, 12)
</pre></div></div>
</div>
<p>We will then loop through each of the outputs and assemble the corresponding portions of the matrices.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[29]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_output</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Accumulating Data: Progress = </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">o</span> <span class="o">/</span> <span class="n">num_output</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
    <span class="c1"># The Xo matrix depends only on the weighting and Omega.  We use</span>
    <span class="c1"># broadcasting to extend the weighting across all polynomial coefficients</span>
    <span class="n">Xo</span> <span class="o">=</span> <span class="n">weighting</span><span class="p">[:,</span> <span class="n">o</span><span class="p">][</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">Omega</span>
    <span class="c1"># The Yo matrix will need the measured frequency response functions</span>
    <span class="c1"># at the output o.</span>
    <span class="n">Ho</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="c1"># We note that rather than re-multiplying the weighting by Omega in the</span>
    <span class="c1"># Yo matrix, we can simply use Xo.  Here we must loop over all frequency</span>
    <span class="c1"># lines to perform the kronecker product.  The frequency lines are the</span>
    <span class="c1"># rows of X, and the columns of Ho, so we transpose Ho.</span>
    <span class="c1"># Xk is then the polynomial coefficients at the k frequency line and</span>
    <span class="c1"># Hk is the FRF for each input at that frequency line.</span>
    <span class="n">Yo</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">Xk</span><span class="p">,</span> <span class="n">Hk</span><span class="p">)</span> <span class="k">for</span> <span class="n">Xk</span><span class="p">,</span> <span class="n">Hk</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">Xo</span><span class="p">,</span> <span class="n">Ho</span><span class="o">.</span><span class="n">transpose</span><span class="p">())])</span>
    <span class="c1"># We then construct the R, S, and T matrices for that output from their</span>
    <span class="c1"># definitions</span>
    <span class="n">Ro</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Xo</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">Xo</span><span class="p">)</span>
    <span class="n">So</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Xo</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">Yo</span><span class="p">)</span>
    <span class="n">To</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">Yo</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">@</span> <span class="n">Yo</span><span class="p">)</span>
    <span class="c1"># We stick the matrices into the 3D arrays for future usage.</span>
    <span class="n">R</span><span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Ro</span>
    <span class="n">S</span><span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">So</span>
    <span class="n">T</span><span class="p">[</span><span class="n">o</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">To</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Accumulating Data: Progress = </span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">o</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">num_output</span> <span class="o">*</span> <span class="mf">100.0</span><span class="p">))</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  Xo: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  Yo: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  Ro: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  So: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  To: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">Xo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">Yo</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">Ro</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">So</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">To</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Accumulating Data: Progress = 0.00%
Accumulating Data: Progress = 33.33%
Accumulating Data: Progress = 66.67%
Accumulating Data: Progress = 100.00%
Shapes:
  Xo: (778, 6)
  Yo: (778, 12)
  Ro: (6, 6)
  So: (6, 12)
  To: (12, 12)
</pre></div></div>
</div>
<p>We will now compute the <span class="math notranslate nohighlight">\(\mathbf{M}\)</span> matrix, which is equal to <span class="math notranslate nohighlight">\(\sum_{o=1}^{N_o}\left(\mathbf{T}_o - \mathbf{S}_o^T\mathbf{R}_o^{-1}\mathbf{S}_o\right)\)</span>. Note that we dropped the factor of 2 in front of the expression because the final answer <span class="math notranslate nohighlight">\(\alpha\)</span> is only defined up to a matrix product. Multiplying the answer by 2 will not result in any meaningful change.</p>
<p>We will compute the contribution <span class="math notranslate nohighlight">\(\mathbf{M}_o = \mathbf{T}_o - \mathbf{S}_o^T\mathbf{R}_o^{-1}\mathbf{S}_o\)</span> for each output and then sum them together to construct <span class="math notranslate nohighlight">\(\mathbf{M}\)</span>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[30]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Because S is a 3D array, to transpose it, we will only want to</span>
<span class="c1"># swap the last two dimensions and leave the first output dimension</span>
<span class="c1"># out front.</span>
<span class="c1"># We compute R^-1 using np.linalg.solve, which solves a problem.</span>
<span class="c1"># np.linalg.solve(R,S) is equivalent to R^-1@S, but is faster and</span>
<span class="c1"># better conditioned.</span>
<span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="o">-</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">S</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  M: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  M: (12, 12)
</pre></div></div>
</div>
<p>Now we will solve for the parameters <span class="math notranslate nohighlight">\(\mathbf{\alpha}\)</span> and construct the companion matrix. Recall that in our solution we will assume <span class="math notranslate nohighlight">\(\mathbf{\alpha}_p\)</span> is equal to the identity matrix and drops out of the companion matrix computation, so we really only need to compute <span class="math notranslate nohighlight">\(\hat{\alpha} = -\mathbf{M}_{aa}^{-1}\mathbf{M}_{ab}\)</span>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[31]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">Maa</span> <span class="o">=</span> <span class="n">M</span><span class="p">[:</span><span class="n">order</span> <span class="o">*</span> <span class="n">num_input</span><span class="p">,</span> <span class="p">:</span><span class="n">order</span> <span class="o">*</span> <span class="n">num_input</span><span class="p">]</span>
<span class="n">Mbb</span> <span class="o">=</span> <span class="o">-</span><span class="n">M</span><span class="p">[:</span><span class="n">order</span> <span class="o">*</span> <span class="n">num_input</span><span class="p">,</span> <span class="n">order</span> <span class="o">*</span> <span class="n">num_input</span><span class="p">:]</span>
<span class="n">alpha</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">Maa</span><span class="p">,</span> <span class="n">Mbb</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  Maa: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  Mbb: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  alpha: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">Maa</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">Mbb</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">alpha</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  Maa: (10, 10)
  Mbb: (10, 2)
  alpha: (10, 2)
</pre></div></div>
</div>
<p>We will then construct the companion matrix <span class="math notranslate nohighlight">\(\mathbf{C} = \begin{bmatrix} \begin{matrix}\mathbf{0} &amp; \mathbf{1}\end{matrix} \\ \begin{matrix}-\hat{\alpha}^T\end{matrix}\end{bmatrix}\)</span>. The partition <span class="math notranslate nohighlight">\(\mathbf{0}\)</span> will have shape <code class="docutils literal notranslate"><span class="pre">(order-1)*num_input</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">num_input</span></code>, and the partition <span class="math notranslate nohighlight">\(\mathbf{I}\)</span> will have shape <code class="docutils literal notranslate"><span class="pre">(order-1)*num_input</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">(order-1)*num_input</span></code>.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[32]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">C_top_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([(</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_input</span><span class="p">,</span> <span class="n">num_input</span><span class="p">])</span>
<span class="n">C_top_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">((</span><span class="n">order</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">num_input</span><span class="p">)</span>
<span class="n">C_bottom</span> <span class="o">=</span> <span class="o">-</span><span class="n">alpha</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
<span class="n">C</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
    <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">C_top_left</span><span class="p">,</span> <span class="n">C_top_right</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span>
     <span class="n">C_bottom</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  C: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">C</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  C: (10, 10)
</pre></div></div>
</div>
<p>Finally, we can compute the eigenvalues and eigenvectors from this matrix, which should be the solutions to the polynomial. Remember that the eigenvalues will be in the <span class="math notranslate nohighlight">\(z\)</span>-domain, and must be transformed back to the <span class="math notranslate nohighlight">\(s\)</span> domain for us to extract natural frequency and damping ratio: <span class="math notranslate nohighlight">\(\lambda_r = -\frac{\log{\lambda_r}}{\Delta t_z}\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[33]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">zpoles</span><span class="p">,</span> <span class="n">V</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">C</span><span class="p">)</span>
<span class="n">spoles</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">zpoles</span><span class="p">)</span><span class="o">/</span><span class="n">deltat</span>
</pre></div>
</div>
</div>
<p>We will immediately discard any poles where the imaginary part is less than zero or the real part is greater than zero, ensuring that we also discard the corresponding eigenvectors.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[34]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">keep_poles</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">spoles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">spoles</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">spoles</span> <span class="o">=</span> <span class="n">spoles</span><span class="p">[</span><span class="n">keep_poles</span><span class="p">]</span>
<span class="n">V</span> <span class="o">=</span> <span class="n">V</span><span class="p">[:,</span><span class="n">keep_poles</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>We can then extract the (shifted) natural frequency and damping ratios from the poles. We unshift the natural frequency from the pole to recover the natural frequency of the structure.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[35]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">omega_general_fit</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">spoles</span><span class="p">)</span> <span class="o">+</span> <span class="n">omegas</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="n">zeta_general_fit</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">spoles</span><span class="p">)</span><span class="o">/</span><span class="n">omega_general_fit</span>
</pre></div>
</div>
</div>
<p>The modal participation factors <span class="math notranslate nohighlight">\(\mathbf{l}_r\)</span> are then the last <code class="docutils literal notranslate"><span class="pre">num_input</span></code> rows of the eigenvectors.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[36]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lr</span> <span class="o">=</span> <span class="n">V</span><span class="p">[</span><span class="o">-</span><span class="n">num_input</span><span class="p">:]</span>
</pre></div>
</div>
</div>
<p>Let’s compare the fit natural frequencies to those from the test problem. We will sort them ascending so they match those computed directly from the eigenvalues of the state space formulation. Make sure that we also sort the damping and participation factors identically.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[37]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">sort_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">omega_general_fit</span><span class="p">)</span>
<span class="n">omega_general_fit</span> <span class="o">=</span> <span class="n">omega_general_fit</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>
<span class="n">zeta_general_fit</span> <span class="o">=</span> <span class="n">zeta_general_fit</span><span class="p">[</span><span class="n">sort_indices</span><span class="p">]</span>
<span class="n">lr</span> <span class="o">=</span> <span class="n">lr</span><span class="p">[:,</span><span class="n">sort_indices</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Let’s now set up a table to show the differences. We will compare the participation factors against the same degrees of freedom from the corresponding mode shapes. Note that the participation factors may be scaled differently and rotated differently than the mode shapes, so we must rescale and rotate them to judge how well they fit.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[38]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency From System Matrices&#39;</span><span class="p">,</span><span class="s1">&#39;Frequency From FRF Fits&#39;</span><span class="p">,</span><span class="s1">&#39;Frequency Error&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Damping From System Matrices&#39;</span><span class="p">,</span><span class="s1">&#39;Damping From FRF Fits&#39;</span><span class="p">,</span><span class="s1">&#39;Damping Error&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Participation From System Matrices&#39;</span><span class="p">,</span><span class="s1">&#39;Participation From FRF Fits&#39;</span><span class="p">],</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">wm</span><span class="p">,</span><span class="n">wf</span><span class="p">,</span><span class="n">zm</span><span class="p">,</span><span class="n">zf</span><span class="p">,</span><span class="n">lm</span><span class="p">,</span><span class="n">lf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
    <span class="n">omega_general</span><span class="p">,</span><span class="n">omega_general_fit</span><span class="p">,</span>
    <span class="n">zeta_general</span><span class="p">,</span> <span class="n">zeta_general_fit</span><span class="p">,</span>
    <span class="n">psi_general</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lr</span><span class="o">.</span><span class="n">T</span><span class="p">)):</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Frequency From System Matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wm</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Frequency From FRF Fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wf</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Frequency Error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">wf</span><span class="o">-</span><span class="n">wm</span><span class="p">)</span><span class="o">/</span><span class="n">wm</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Damping From System Matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zm</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Damping From FRF Fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zf</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Damping Error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">zf</span><span class="o">-</span><span class="n">zm</span><span class="p">)</span><span class="o">/</span><span class="n">zm</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1"># Find the maximum participation degree of freedom from the</span>
    <span class="c1"># system matrices</span>
    <span class="n">check_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lm</span><span class="p">))</span>
    <span class="c1"># Compute the angle of that index</span>
    <span class="n">check_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">lm</span><span class="p">[</span><span class="n">check_index</span><span class="p">])</span>
    <span class="c1"># Compute the same angle from the fit</span>
    <span class="n">this_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">lf</span><span class="p">[</span><span class="n">check_index</span><span class="p">])</span>
    <span class="n">rotation</span> <span class="o">=</span> <span class="n">check_angle</span> <span class="o">-</span> <span class="n">this_angle</span>
    <span class="c1"># Compute the magnitudes of the vectors</span>
    <span class="n">check_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lm</span><span class="p">))</span>
    <span class="n">this_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lf</span><span class="p">))</span>
    <span class="c1"># Correct rotation and scaling</span>
    <span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">rotation</span><span class="p">)</span><span class="o">*</span><span class="n">check_magnitude</span><span class="o">/</span><span class="n">this_magnitude</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Participation From System Matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Participation From FRF Fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span>

<span class="n">pretty_print_table</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Frequency From System Matrices</th>
      <th>Frequency From FRF Fits</th>
      <th>Frequency Error</th>
      <th>Damping From System Matrices</th>
      <th>Damping From FRF Fits</th>
      <th>Damping Error</th>
      <th>Participation From System Matrices</th>
      <th>Participation From FRF Fits</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>27.25</td>
      <td>27.30</td>
      <td>0.19%</td>
      <td>2.71%</td>
      <td>2.60%</td>
      <td>-3.90%</td>
      <td>[-0.04320045+0.04405838j -0.09857882+0.09838338j]</td>
      <td>[-0.04318693+0.04408044j -0.09857685+0.09838141j]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>54.78</td>
      <td>54.86</td>
      <td>0.15%</td>
      <td>2.74%</td>
      <td>2.76%</td>
      <td>0.67%</td>
      <td>[0.06535574-0.06999465j 0.00185538+0.00185558j]</td>
      <td>[0.06534612-0.06998435j 0.00118367+0.00286075j]</td>
    </tr>
    <tr>
      <th>2</th>
      <td>59.91</td>
      <td>59.88</td>
      <td>-0.06%</td>
      <td>2.66%</td>
      <td>2.69%</td>
      <td>1.02%</td>
      <td>[-0.06059005+0.05448316j  0.03373321-0.03429903j]</td>
      <td>[-0.06070207+0.05458388j  0.03320861-0.0344524j ]</td>
    </tr>
  </tbody>
</table></div>
</div>
<p>We can verify that we get very good agreement between the quantities derived from the system matrices and those fit by the FRFs. However, we may have simply been lucky: our system of equations actually solved for <code class="docutils literal notranslate"><span class="pre">order*num_inputs</span></code> or 10 poles, and it just so happened that 3 of them ended up being physically realizable with positive damping and frequency. It is possible that more of them would have been physically realizable, in which case we would have had to go through and try to figure out
which poles are “real” and which are “computational”, and without <em>a priori</em> knowledge of the true pole information, it could be very difficult to do this.</p>
<p>Instead, we use a stabilization diagram. We solve for a range of different polynomial orders and we plot the resulting frequencies on a figure. We then identify poles that appear in many different model orders to be “stable” and we accept these as real poles.</p>
<p>Rather than code all this from scratch, we will simply rely on SDynPy’s <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> implementation to help us out. <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> relies on the FRF being structured as a <code class="docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code>, so we must first create one from our data. Note that <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> works with frequencies in Hz rather than in radians per second, so we must convert our <code class="docutils literal notranslate"><span class="pre">omegas</span></code> variable by dividing by <span class="math notranslate nohighlight">\(2\pi\)</span>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[39]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">sdynpy</span> <span class="k">as</span> <span class="nn">sdpy</span>
<span class="n">tfarray</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span><span class="n">sdpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">,</span>
                          <span class="n">abscissa</span> <span class="o">=</span> <span class="n">omegas</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">ordinate</span> <span class="o">=</span> <span class="n">H</span><span class="p">,</span>
                          <span class="n">coordinate</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">outer_product</span><span class="p">(</span>
                              <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">],</span><span class="s1">&#39;X+&#39;</span><span class="p">),</span>
                              <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">],</span><span class="s1">&#39;X+&#39;</span><span class="p">)))</span>
<span class="n">pp</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">PolyPy</span><span class="p">(</span><span class="n">tfarray</span><span class="p">,</span> <span class="n">displacement_derivative</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="c1"># We tell PolyPy these are displacement FRFs.</span>
</pre></div>
</div>
</div>
<p>We can then tell <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> which polynomial orders to solve for.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[40]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pp</span><span class="o">.</span><span class="n">compute_poles</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span><span class="mi">30</span><span class="p">,</span><span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Accumulating Data: Progress = 0.00%
Accumulating Data: Progress = 33.33%
Accumulating Data: Progress = 66.67%
Solving for 29 roots (1 of 13)
Solving for 27 roots (2 of 13)
Solving for 25 roots (3 of 13)
Solving for 23 roots (4 of 13)
Solving for 21 roots (5 of 13)
Solving for 19 roots (6 of 13)
Solving for 17 roots (7 of 13)
Solving for 15 roots (8 of 13)
Solving for 13 roots (9 of 13)
Solving for 11 roots (10 of 13)
Solving for 9 roots (11 of 13)
Solving for 7 roots (12 of 13)
Solving for 5 roots (13 of 13)
</pre></div></div>
</div>
<p>We can then plot the stabilization diagram. The stabilization diagram will have different markers to denote the stability of a given pole. We generally overlay these poles with a mode indicator function to help us figure out which poles are “real”. In this case, a red X denotes an unstable pole, a blue triangle denotes that the frequency has stablized, a blue square means that the frequency and damping have stabilized, and a green circle means that the frequency, damping, and participation
factor have stabilized.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cmif_axis</span><span class="p">,</span> <span class="n">order_axis</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">plot_stability</span><span class="p">()</span>
<span class="n">cmif_axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;CMIF&#39;</span><span class="p">)</span>
<span class="n">cmif_axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">order_axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Polynomial Order&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[41]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0, 0.5, &#39;Polynomial Order&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_109_1.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_109_1.png" />
</div>
</div>
<p>We can see that as we move up to a higher model order, we start to see more computational poles appear, as shown by the red Xs throughout the frequency band. However we see the three main columns of green circles denoting three stable poles in our fits. We would then select these three stable poles.</p>
<p>In <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> we can select them by index, and we can determine the indices by plotting the stabilization diagram with labels.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[42]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">cmif_axis</span><span class="p">,</span> <span class="n">order_axis</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">plot_stability</span><span class="p">(</span><span class="n">label_poles</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">cmif_axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;CMIF&#39;</span><span class="p">)</span>
<span class="n">cmif_axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">order_axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Polynomial Order&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[42]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Text(0, 0.5, &#39;Polynomial Order&#39;)
</pre></div></div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_111_1.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_111_1.png" />
</div>
</div>
<p>We can then extract a final pole list from those indices. For example we may wish to select poles <code class="docutils literal notranslate"><span class="pre">(4,0)</span></code>, <code class="docutils literal notranslate"><span class="pre">(4,1)</span></code>, and <code class="docutils literal notranslate"><span class="pre">(4,2)</span></code>.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[43]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">pole_indices</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">4</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">2</span><span class="p">)]</span>
<span class="n">pole_list</span> <span class="o">=</span> <span class="n">pp</span><span class="o">.</span><span class="n">pole_list_from_indices</span><span class="p">(</span><span class="n">pole_indices</span><span class="p">)</span>
<span class="n">omega_general_stab</span> <span class="o">=</span> <span class="n">pole_list</span><span class="p">[</span><span class="s1">&#39;omega&#39;</span><span class="p">]</span>
<span class="n">zeta_general_stab</span> <span class="o">=</span> <span class="n">pole_list</span><span class="p">[</span><span class="s1">&#39;zeta&#39;</span><span class="p">]</span>
<span class="n">lr_stab</span> <span class="o">=</span> <span class="n">pole_list</span><span class="p">[</span><span class="s1">&#39;Lr_complex&#39;</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>The stabilization diagram actually reveals that for our test case of <code class="docutils literal notranslate"><span class="pre">order=5</span></code>, our poles may not have yet stabilized, and therefore our results may be inaccurate! Let’s compare the same quantities extracted from the stabilization diagram with those computed from the system matrices.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[44]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">columns</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Frequency From System Matrices&#39;</span><span class="p">,</span><span class="s1">&#39;Frequency From FRF Fits&#39;</span><span class="p">,</span><span class="s1">&#39;Frequency Error&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Damping From System Matrices&#39;</span><span class="p">,</span><span class="s1">&#39;Damping From FRF Fits&#39;</span><span class="p">,</span><span class="s1">&#39;Damping Error&#39;</span><span class="p">,</span>
                             <span class="s1">&#39;Participation From System Matrices&#39;</span><span class="p">,</span><span class="s1">&#39;Participation From FRF Fits&#39;</span><span class="p">],</span>
                  <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,(</span><span class="n">wm</span><span class="p">,</span><span class="n">wf</span><span class="p">,</span><span class="n">zm</span><span class="p">,</span><span class="n">zf</span><span class="p">,</span><span class="n">lm</span><span class="p">,</span><span class="n">lf</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span>
    <span class="n">omega_general</span><span class="p">,</span><span class="n">omega_general_stab</span><span class="p">,</span>
    <span class="n">zeta_general</span><span class="p">,</span> <span class="n">zeta_general_stab</span><span class="p">,</span>
    <span class="n">psi_general</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">lr_stab</span><span class="p">)):</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Frequency From System Matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wm</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Frequency From FRF Fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">wf</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Frequency Error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">wf</span><span class="o">-</span><span class="n">wm</span><span class="p">)</span><span class="o">/</span><span class="n">wm</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Damping From System Matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zm</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Damping From FRF Fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">zf</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Damping Error&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:0.2f}</span><span class="s1">%&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">((</span><span class="n">zf</span><span class="o">-</span><span class="n">zm</span><span class="p">)</span><span class="o">/</span><span class="n">zm</span><span class="o">*</span><span class="mi">100</span><span class="p">)</span>
    <span class="c1"># Find the maximum participation degree of freedom from the</span>
    <span class="c1"># system matrices</span>
    <span class="n">check_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lm</span><span class="p">))</span>
    <span class="c1"># Compute the angle of that index</span>
    <span class="n">check_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">lm</span><span class="p">[</span><span class="n">check_index</span><span class="p">])</span>
    <span class="c1"># Compute the same angle from the fit</span>
    <span class="n">this_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">lf</span><span class="p">[</span><span class="n">check_index</span><span class="p">])</span>
    <span class="n">rotation</span> <span class="o">=</span> <span class="n">check_angle</span> <span class="o">-</span> <span class="n">this_angle</span>
    <span class="c1"># Compute the magnitudes of the vectors</span>
    <span class="n">check_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lm</span><span class="p">))</span>
    <span class="n">this_magnitude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">lf</span><span class="p">))</span>
    <span class="c1"># Correct rotation and scaling</span>
    <span class="n">lf</span> <span class="o">=</span> <span class="n">lf</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">rotation</span><span class="p">)</span><span class="o">*</span><span class="n">check_magnitude</span><span class="o">/</span><span class="n">this_magnitude</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Participation From System Matrices&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
    <span class="n">df</span><span class="o">.</span><span class="n">at</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="s1">&#39;Participation From FRF Fits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">lf</span><span class="p">)</span>

<span class="n">pretty_print_table</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area rendered_html docutils container">
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>Frequency From System Matrices</th>
      <th>Frequency From FRF Fits</th>
      <th>Frequency Error</th>
      <th>Damping From System Matrices</th>
      <th>Damping From FRF Fits</th>
      <th>Damping Error</th>
      <th>Participation From System Matrices</th>
      <th>Participation From FRF Fits</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>27.25</td>
      <td>27.26</td>
      <td>0.02%</td>
      <td>2.71%</td>
      <td>2.71%</td>
      <td>-0.02%</td>
      <td>[-0.04320045+0.04405838j -0.09857882+0.09838338j]</td>
      <td>[-0.04320045+0.04405838j -0.09857882+0.09838338j]</td>
    </tr>
    <tr>
      <th>1</th>
      <td>54.78</td>
      <td>54.79</td>
      <td>0.01%</td>
      <td>2.74%</td>
      <td>2.74%</td>
      <td>-0.01%</td>
      <td>[0.06535574-0.06999465j 0.00185538+0.00185558j]</td>
      <td>[0.06535574-0.06999465j 0.00185538+0.00185558j]</td>
    </tr>
    <tr>
      <th>2</th>
      <td>59.91</td>
      <td>59.92</td>
      <td>0.01%</td>
      <td>2.66%</td>
      <td>2.66%</td>
      <td>-0.01%</td>
      <td>[-0.06059005+0.05448316j  0.03373321-0.03429903j]</td>
      <td>[-0.06059006+0.05448316j  0.03373322-0.03429902j]</td>
    </tr>
  </tbody>
</table></div>
</div>
<p>We now see that we have extracted nearly identical modes to those that were computed directly from the system matrices, meaning the fit has significantly improved by using a higher-order polynomial.</p>
<p>Note that this section has used the code-based <code class="docutils literal notranslate"><span class="pre">PolyPy</span></code> implementation. However, in SDynPy there is also a <code class="docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code> which can be used to interactively select poles.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ppgui</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">PolyPy_GUI</span><span class="p">(</span><span class="n">tfarray</span><span class="p">)</span>
</pre></div>
</div>
<p><img alt="image.png" src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAABE4AAAKUCAYAAAAaSX3/AAAgAElEQVR4XuydDXwV1Zn/nxAgBQFBqFQXi7AFTQJodrds7a5dpbVVUbsQXmrolvq2vlRXSdB/teElIdZdEVdrPx/9aG21W0JJCLr/9l91t1JfutaXulEkSUVXyorUF8RWEQ0Q7v+cmTs3c+fOzDln5szcuXd+048luXPmOc/zfc7MnfnlOWcqvv3tCzNPP/gC/Z74lqFhQ4fSqFEjqWrYMKqqGk6VlUOMPYG2jPiog4cOiRuhhQYC46nuz8+hI/fcR7/6U7658Z+cT2dXbaV/2/WqZD81tPi6afS7m/+dXuRHzPgqNZ9N9DP++8S/pSuWfoa2338f/fItts/5u9HD0fSli5fQ+Kf/lTZus7rkNr9C9Av7Z3Z3+DG8k6xdGU9PmELz/+Jj+tWGP9B7rP3ks06mvxz7lvE7fe5EOn3Kn8x9vN2cI4n+aO57j8bRKZePpd137qCdrv3w/RPpg02/o23vyDji0sbhGxl9Ftoc5+cntzH1j7T5IR5dNj7msfW7cey4t7K/M/vnf4J+l4uX6HnP+CRi4nk9l+jBH/yadtub155H3zl7Kr36i9toY4+EHTQBARAAgRIiMHXycfTaztdLyGO4CgIgAAIgECWBiiiN52zH00ssoSS4k0MDA/Txx/3Uf+AgfbDvQzqQ1SlM+hVU8dXP/UXmxT+aCseY0aPo6E8eRefPP4c+M2UyfWbq8TThqHG28JA0fbmOm2V+fxKalnyohmn3eDL2jmIK2RmbNdjdA8owudDaYnJQnqyjpdasKXrh3bc+alHF52/X3/+gPrkfp84qaP/O9PKeZW3ZvRQd4xWR13F+BER9ucVk/0z2eFWf3U4Vpw2/vq22sv6J4vQ6dWXtJ80fxUuRVHP1M03KrHQj2VyUynePdOBomEoCjvPNbfjHfEqG+daPJoXBAaheTQr9d/v+D+5PED5mDFH06X6/komkL7/IXWKTDFecX0lDvolRtyH2y5nTOB745OKQ890d2Lvv7qVX/+c19t//0MZNXfTm23vovT99MPikePyJdYb9T044ir546ufo0qXn07HHTLRZk3MyyImU3mPiZRqZMJAXRrGFk8EvhvxTV/RYHMWJzm1GkeMwl4KwZ1t5CifiLAVhrvOWLUj/YXOt8mAdREBw+hd1jKJ4RPtlhYyo4hCPUtNDmf7dbzKDjxidQlhwLwaPlGWloy/YUCcQxfetuhc4ImoCtvPQSnmRTk2d38b6qOmBIXPF9/dZjx8yXCJ7DvHpvOjiiQJecS4VjCkJKOLnFbFvXh3q8ln2Hiy/XXC/uR3T991/2E1333sfPfYEq65/823jLquCCye80uTsL32BWr59ja3XqAKWOcXKvU28bLVfsFzdL6Zwkv8wMPg97cXZXmViH2uihwCZvEV5YxjuMhDurIpaOIkyNnfbMtmUexh1khXHIte37MOwKLODoqLaTZRfHN7nVmEfovNKxv+gLMpFKBCNGPGYcxdzZY4T5WfwJmOwpS67Mn1bbUSMVGyhrXouZfhH+f2InCWPgMyYKI7X2u+LtYchZqf3KivuT0eI+WJG9NcDswf32JyfBuaZd4vl0pci2mjvti1nnL34OxmYTSR/RPbOqfrduN+oHmSyes2N9ItHfknvvf8BVXxmxmczx3/6WLrn1htRaaLjqiBlQ/EskrLp3qhwsGvoO1HCSaEzlizCZqK5QvGSTbyrRFT+ZKJ2MVJLbfBLl1o/bq2jvZQHEyhkowp6FgTlLXec3JkoZ0ssVugSQfy+sNz6EEUpii+M8KHttiiLVxRLUHFHdhyHbefmv4h/2D7jPF4mP3H6Uw59qY4PFZEU+Qo/QlTuTcL3FsxCKeS5QqpeL1j8YY4Ss1M9Q4N5I/ZD1W6YP2ep9OXFR/x8oBBznnDi4V2Fgj1mIuo7bncvoxJP/O4bVbLpbCtmquf8qDAqTy678mr6nx2vU0Xd5/4uc+XFX6evL/x7h0dih8KEi2PVB0BQZvkDR0NeJYWTvPVNojpvXMUR/5uJfOFEhofKzUk5CifiS48MRf/xK+4j6Ph3+woS+xvGH11feWF8kPkmt4iqiBNe5LxvT7zzJhOfim+ia6qKeKTS1upXJh6/C6Hs8cHPhHxxOI7+RDkJEwuOjYeA7DgRXVWj/G6MhwR6CUJANC6C2NR/jPb7ZG0uqvOTPWPVXFT3w8++rrsktRjcWnvdY2gW03LdyHEU8zFb5N/pydn2ZxaVeKLDNy/P1W0HOUfWb9hI37vzbqr461O/lLl59XX0ub+qs3mk7kT4wVvKFvweUlRv/KNhPzhINNt3uRgUCCZuz2fa0u2MR3xzNiicyLJIs3Cidnnxy0ZUl2PxUCqMQZx5tbgHfQjSl1sEQfsX0yhsYdGQ6VN0vtmtq4osfscGETKckaqKO6o8VNvL+hckp0k8RnzWJdFr+BSWgI5z1+6DyvdxWN9xfHgCtvPePhQSejmQuYqbTOIMQE9f8rHJZD28T+7+eAsZMl7pa1MYX2B+Babk2Ln1ZxzJdzhM6HvGk/PN4qzGRM12sFzK96HmO9Ezzz5H192wkir+7ktnZ9rvuc329hz5ToMFVS5HuXHyHOa2oFVSpTcXg/qk5hzYStA8RZPIvmdED3JuFz/VGy+V9mLhJjh9lbETvJf8I9X79HsM9x7RLt8EOUfUfRDFEJ2Ik+9rsDM4bLyquZcRTlREEL+oZWLzunFyi0uGcNAHNxlfVViH9VWlr6S1lYk9aT7Dn/AEROeQ6rgogSfv8NDKyILn050+7UHmtluRqGjUDppTHb+Kjig1F/siH5dKx+J+ZawVPvhHkFgZR/LaaBJPCm5pHHZlEQoeL1zFE5XHFyN2r/svHXfNfs9rshBkkyhnT+WcePfdd6lh6YVUMefL52Qe6rzP15NfPvYkvfnWW7Le5tod/clP0pdOO5WGDBmifGyyD5B9MJAVV/yilUu+LK9oVplmPnI32Qj0HYRKoWQNCgPzOxGdFwHTWGlWnKic3kJoCg0K+xU9Zvvtdx8Coit7mNjdj/UeikH7Uu3HKwVB+1dIqWtTv/PNi1aQGxtRfKLz2em8zEXFq88wxwbhHXd/QXyM6hiZ2KPqG3aLR0D1fBd5CuFERCjcftF3sax1j/M9yFdG0K9KDZcc0eiNt+pEhr04aHFMMv2I2oj9EFnw9jO8bVHfg/sL+1J/fmDWZB5njK58YlO6jWHTjAQiizwDe8vw4om1toz7WpO6cyu2p3o+zP1qvSWc/MjBML+zn235DR0/ZYov54ps1cEbb+7JJezD99+l02fPpKPGjQuWo7I4ys5SNUWCEykAn2iEk3w/86IUj9sAUfidyOIbq0AXvpBeBj88yJgJ3lvhkcGFE25LfO0WtQgTf5Cv3qD9lbpw4jdm3E5ipW/xrHEZtkGul34XGdU+7RxkjvW7Rgd5SpDtU+c5HoR50P4j/0II6hiO005ANJaDjAXx97v2MGBQE4Gw+Xa6kbUX5KtIMSLRSB40FyRGRWeEzeV8kI9J2KFHAzk/vKwHuXsL6mmQ4yJ7lvISUJTHuUM8CZcOG6Jw4on4bkObo1mfg9nzwj33q/Op4nRWcfJwp79w8uv/7qXPn/LXymPr1089TdP/bAJ96lMTlY/FARaBYEl352faiuaCOehnzr5O1wsC8pNwRSe25WGkDmoYwtFkSs2xcMKJNd68Sfs9XIaJ3/9YNX9ExIL25bQbJl6Rj2H2i7/qTOteVEXimJtvfiysfkR3EkF4ysYqc30W9a8iSIXJn9+xTh9EPuv0I+nXX52xps2WaByFyT23HfZ4v+tV2nJVrHhFORSNIbvfNlthh4cPDhWPCs2I4tWZB7m+wsUj46+cH16W1PwL15dMNIV3bFH2mbXt96jjcQoMfmwTTwSuNi1fTvfc8wM6fPiwKwo+c+SSSy6mdbfcInX99buzt3cgl2Nv52eddBJ9//vfpy+ceqqr3088+SRdddVV9OILLyqn2M03H+Ek/0vlNy/+jokfk+nBJ1+hiiFMZ+P/VfL/DtPZJ32GPjXxSNq370PDqSOOOIK6/muH8fOU0ft9hZPqk/+KXtvx+1wwWx7+Of3NKZ/zDe6c+Yvo+msbfdsFsatM1HbAjt/vpBNP+kv6tx/eQ4vq5xWYqjpyAn23ZRU1XXNVgNjMAcNjuvib32A2/imgq4MD75z5C+g/H91CP/7hD5i/8wPaczvMIZ6EuKbs+P3vqWaWfcFioo/efy/bqffDTe1Jf0E///cHaMrxx3vGFWXFCfe7dtbJ9MtHHmZio/dYHjlmLO1//4+uPlo2rJ1traup8ZqrNeZJbGrkmPwqsV8+8gt6443dtPTCi1ke9hoGRI+t4l7kLpliO24tgooZQXwSHyOS8oLFGNdRIjHBLzpV0UTEUuRLXEx4PzIXOFE8djsybXXGlwThRpajzrjTaMsaWzJj1uITxXhU6T+KPNljKrYvOuIrh3h0Xoeiz6m+syJ6X2VGWGSVE7nOw8cpz9zZV/Tnh9lD+Bjdc6Vo17W53NuBxhw5lp55+jd07LHHurrC1/c4ue4v6P0/Wc8tYt9U7v7EOXbvjwsjF154Af3whz8qEE/89snmzOmXvHDyQh8dc+yf060/+y0NGXqYhgw7TJXD+b8DdAF7UJ30Z0w4+XC/AXvUEaMM4aRy+AB9uqpfKJz84sEu9pA7mf7rN0/TnDPPof4/7fE912WFE1W7MhcYrzaWcDJ1yvHU98Jv85p1dD1A/3DhJQ7hxH0AnDN/YU4UWnfbHYad4EKJ3Y3B/jjnm9beQj/fvCmCyhO9wsk5rCSq58X/NgK59bbb6bHHn6T/+0CXIw35w7rYwonsOPISTp5i+fnSV86knq0vGOcF365ubKLbb11nM21xFl9qZP1xtuPCyX5DqCrsg/fOxZ1z2Fy/bS8+nzt05Jij2DF7Fb5CovJfbNf7ki8+tpCp3DHufcodGzSPeo7zG2+iL0+Vr07urR8Pv5siPZGqWRHFLorH/RptfhrHuND5wKJGTr21DGt1q9EdESR/UcUYxJeoyEQVo6y/0T9IyXoSvp3qtTV8j9FZ0Hkt0jTGPIaK3rNJk68hE+MeU9S+qdmX5y66P1brV4TW2y+vfoKI2E4vPGxLhuYmlo0aPYbe2PU6HXnkkZ4h8zb7Pnjftt+/Q9UrlDjH8uKJv2hihSAGJimcFBp6/LmXaPLkE+jfnnqJ9n70Ab1/cB8NDOknGnqQvv25r9Bxxx5JH+wfFE7+X28fDRtxkCZ8UCktnPAwZEQRmTa8OsMSTmTtik4Ov/1cODn77+vpz6dOLaiG4f5OZQ/Akz/9aVvFiZ9w0mRU06y77XtGl7qFk46uzfTr/3qKvnfrLRHcmtuEE/F49EVuPpgPCie88Qj2MG9WnXhfGEXCifjEDDMS5I/1Ek5mnFRHP8tVzHh5K/pikPfDq6UpnJiVJW4bz8+5HsIJby+f/igy4m9T7VIvwzLu/mR8iquNH03dX5vFEE7sfbrlWTTSZca3CkPdeS0GU5kYRFxlbKBNcAIy41bVOnKqSkyuvY4HMbmeomsleshU6Vl0zZa1xewoog1+1iT13NB/t1RI3y1f3v0GZ2z1HB1rLwHK7DF/b/hKn+DiyaAngzaCCSfiu32VU0gut2LxhHvlVYXiP/7E14azB9c4uc+39WNMODmeCSc3PPAQ7T+8nyqrDtFQVlFSOewQrfzr+lzFCV8tl0/VeWz3czR02EEa+YcjlYWTO25dS/wv7Xx6i7VdetEF7EF/rfGrJZxs7DQrD6zPLfGCV3y4CSfXNV5DZ8w9j37H/kJu/SX/nxqvpb/9m8+7Tq8R4xtsYfXdsuI7WVHC9NWs7riVTv+COfeKT9X5p8brWJ+n5KbImD6Yv5sVJ0309DPP0g2rWnIdcJ+vYu34Pq+pTFVHjjeqWvhxvD3f+PQha/sdq9x47vn/ZtUvF+c+68tWc1SzqiFr45/xaS6WcPOdVavpHy+60BBa/qlxOd197w+NptZn/AF6LhONLvrmUuJt+bbl4YfolM+b01R4pch3Vpqfn/HFL7KKkU3Gz1wEsbZHH3moYFqLm3DCRRFegcKrMr74lbNyx//4h/fSwgXmlCNLODnnq/No9Ypm9nm98Xnnpi568qmnaPHChfTPN7MxNuV4uucH9xr7zOqO442feXWH9Tn/3ZpOw4//NTt+B5ta9stHH6VLLr7IsMWrQ/h2v+GD2ZddFOE/Wxs/xqoccRNOeFzct8GqmvzLCGfJt8ZrrjH+vfW227K/X234zcW5ZsZ68cIF9O7e93KsTZ/GsTi7jTjt03B+6cKeX+Ct6pGc8+wH079b6PZ/vYVNRxocM3wqEe93MM4LWZy30L8y8W8w93NsuT+KbmTH8H29W/l4m2zvRsPP6n8DGOxU7tIt2178Fa3anwY8Wk24RagqmHCH/Dio3lRb7cOyVRUVZFg44YtGSNgYtCY7QmMiDhF2DdM+BGTGH3KHIRSWgG0MeT5pyYxF7oeu63/WFu9W8xCXjSSfqmYnpFMm32+wuPwcEfetr09xXzLI1ISCsH36HC8w7RRPggsnXlSCxybOqb94wj1ym7rjnT95X6WFE6viZNmDnaZgMvyQIZoMZf9df/L5NIlVnHy4/yPDJy6cvHnwTePn3X3vSgsnfErLqjU3GlNduPDBRQhrvRAulnDxgQsPlnBy7DHHGFUe1tQYPrXluOMmGcfYhRO7XadQwts5p9bInBjONnbRhgs+1nQj3t/ihfVMCHnOOERWOHGrOLFEFZFwYlWocCGl/0/vGld8LkJcxUQPPj3HWXHyiSOPoo//ZFYW8HZcHPkZa8eFEy6EWPucFTC83dfYA/oxx3yKuPByY8tqalp2NXVs2kz/tr6dfsYEknW56TWmWGJtprixOSdWWIKIvY1TOOHCAN+u+aerjLVPerMiAP+MizCW+GIJJ7/97fOG0GEJFefOq2cP/OvoD3940xA7LKGDixE7//d/jXbmdKAncsIFF0ta1rSx6SjdhvCy9MKLcmuXcOHjS4YQ1GUICv942eVGO77JVJN4CScbOztt03LUhJNHH/0V88Gc2jSDMf5ZlnEny8mvn/ovw679c6uddYzJ3+yTCyf2jVefWMIJF79EFSdmn2ZlE99uZePpuEmTDIFrBLPNhZNGz/V6xJfNPOcKfvHS/f2Psscv01LUXu5SHDZWeU/VWnLvZXwTiQsyFFRFE9n2Mv77UQkihHB7sjfuYdmoZTS5rWU4JNf78vdM9nyTJRH0vMQ4kSVceu2yuZUaajKNgo4xN3LJGXfhqxSiGhmFjPRlIDx/eV/C92XeP8u9SZZPhzd9U+w37/ZMj3iiXzgJEJfP8CzMYWHc1vQcbkZNOJE/7w3hZPny5ZkbV3zb92yyhJPrHm431i7hgkklqyjh/y6vXpqtOPnISD0XTkaNOsKw98RTzwqFE/visFxwsIsQllNW5cbPN3fkTeexT9uxiyDOxWEtIcNuhwsqr7++q2DBVmutFatvfiwXZawKkDO+OIcJEB15vEyfFxgijCUwzP/783LCjn29EnuFCTfiVnEiEk64KGJtWx7+f0YVyqBQYla6zDlzbkFO+5lAYhdOzHZnF7TjYolTKDk3u6CsvTEXS3icvOKkN/vAblSgsIHFfz933gL69rXLB6tJ2ABxW/SV27QLIfx3ZzurWsUuAli+DFZiXJ2rOOGVFSOYuPERW4D1td/voKuXLc+JHPaqDnuVx3lMXPn2ddfmVb9YU2ecQoyzrbPKxKpU4b41r1yVw2ZVt0RRcfK3n/+bXOWNncl5PA/XLTdErlrHgrvcMasSxXRyUDhxTtVREU6uZsLaPT8wq5Os7R8vNitRuHBiLTBbMPhyH8h/1RXakLnEuvWs2qd/e7mvQtU+vYnp2yP74G/1aI/UGY+IgsxNsDMyr2NEIo4qoaDCiUw/Ii6WDdnxIbIna0eUU1E/MrGjTWkRCHKO+kWoOhbttjD+SmvsyHorIZxwU9LpDzPG3HyW6FjUpYQJWVoyIETuyPel0jJKAcXphxpQeR5e9zNq/clSG/RLwX6ecOJzYkia5IJc0oUTHqXfnb19TRPeVn6qjl+mCgFmK07mstcR3++bY0s4ueGx+w2xxPzvIFUOPURX//kl9GfHjjEqTsypOiNpeFUVDRwaoOe6twqFE/taJNwJL+GET83h03LsYgl/8Oef86oOaz+34ZyqYw+OH8+nA/GpL9a0INkB7tXO7rP188Vs6grfeJXJoHDCp+pY04PMqSVBhBM3P5zCyU1r1zGBp9PW1BwAlnDCH2D5gzBfKJZXmDg3N+HkersIkj3AmqqjIpw41y5xi8dtqg5v5yWcHDfpOGOqTC1bI8R6qw4XD3iVw//u2pWtdqjPVk0MToeREU6sihN7BYuMcGKvZuG+29cv8apK4Z8PTh3Kv0yIpurYhROzImS+UXViikZWlcj8XFWK+3jWJ5z87efZNLjsFCp7X8kUTuS/VgdjKVfhRPWK6CW0SH5rK72fSVY04TEEyalb7KpCkgy/sGycfRTcSck44dNGt70g7sgyCmIbx8gRkD2HVHMla9fupWofchGWZys3vqXAT8XHIGMoymwLxB+V0DS4WbzqFPdAo8mWGtRwPqj1pZrC8Pny8E/Cbc5l1OgjAywOKxOlhAMyZjzv6CrIbSFYucVhZTrO9/8sc40TCeHkty+xVw5/mh5+5Xn2KmL2Np0hA+y/w8bPnx9fR1OnTKT9+z82PBg5ciQNGz6MDjHh5L9f3KYsnHAbblN1vrHkfGMajnNxWN72jDmnG+KJNY3FTzjhlSZ8cdTXWJWIs3JEBqFbG6fYw33kr/u1Kl3swgn/mU8NsdZm4VN7zNcYD65xwuMwBY7f2NZ2Mdc/8ZuqY07NMTcupFjVKIM+Vxh2n8wuDss/51N1tjz8i4I1RpzCCf/9sSeeKBBZeOxz/96sMOGbVXHS88J/m1NfnmBvwrELM2wM8uk05voj3q9C9hJOrEoU51Sd3uw6JXbhhLe9elkT/c9rr+Wm0TjXEbH/7jZVh0874tNxrDVOrKk/ssIJZ8JfJZz/thy+zoj764itChWzYsW8zFtv1eGikeUP/5wLMRdesNSwz9vYhRO+n1ea8O0fljTkWPOpOqt82csJJ8a5nn2LjjW+ZrA1dX727/wtWccbAlcLm3rXY3vrjtUOwolFItzXuNu1KBmf6fuizI9H5mEgKUxlGOjyVbewkwTRRDSSZfiKbGC/P4Gw4xM5Ks4IE+Wt1PNSYtcnno4iIQ//MB50BEM8CUIufL5cuHvdHjiajj5yHL3Q/TxNnfrnrq7v3r2bTqyusb2OWDVCfSeB/QpnCiQXsqk5P7S9jtjsKwrxRFo4+dWzL9EXT/sb2v/hvtz5XzGk0niwy2QO09Chw5mQMoQODQzQAPvv8OHDhtO/7X4pkHDCj7UvDssXPeWVG3xzCidciPjBfffnrVXiJ5xYtk2xYp5q5l3bO4UTqxLGEkfswokzNr7wrblArSWcNBriiPWKY95ednFYu3DinK5zqbHA61ramBWOrLUn+AO9fbqOteir21t9nNN1+tg6I3yzpubwn/nUq3OYkMKFE77xB3prQVljug0TUQzxgz30W5t90VjrMy/hhO93Lg776CMP54Qfu3DC23KB4/gpx+fWDfETTix/rcVhp06ZkhNcgggnPIbaWScbIfH1UF5jAo71xhwv4YS3tdZTsViY67FwkanCEEte27HD2HUJm/rCF4T1Ek64eMHXZTFfK2xupk+D7M11WuwVR/LCCRdmfskEQr44LF+vxJqew/3iFU3O6TqPPmIKdMkTTkQ3mjl8jh+CVpwE7c/Lj7g/93tQl/lytOKXactjK0aVSVimoth0jgHdDxK67YVlKTpexFp0PPYXEtA1PqPITRDfovAjieMmCBsrjrQwijNvAZjK/H1AKYQKn9pLe2cBfFXyw2wcXhxw6zSc7/JnjbMf/fxMi2HiUTjW1rRp+bV09z0/yD2/OynzZ/xLLrmY1t1irlsYfFPwT9BJJpOhk+r+gr5/x/fo1FPNl7AMboPiyZVXXklbX3wxuMu2I89ibxOVqjh54JHHaPyET3p2yoHy/7howgOxtrfefJO+8FczaeLEo7U47GbEviisbCe6FoWV7U/cLuyDiLgHq4W2i1aFy+BnqZe/AKleG7xu5v1PQmtRWOutOfKkkt5SibRCMOp29Y9edR/yAyw83nuUhOmrXIQTvww6h47fjQNvK/pSdDITtec2ZYWTMLlUOEWkmoriUvVVtz2/ICCcSKU4VCPV/IfqrIgHi8atqmthuOn2RdX3qNuHYSNz7Y7a/2LY9xoTYVmKvjddYhV1GWr4Fn5vu3cXqhPpBMbTt1osIvyDwYnul9T6dULz9iOMXY9jJU1qe27MBSvZscSI4ppDRfZ5VOXOX8K0axNp4eSjjz6m999/P08UkemUBzNmzBgaMeITMs0DtbG/xUbGgLP6Q+aYaNvoG0BiP/2UZ/HRhS3cfS8YvJGF6G/YWMMl7/W+QWJM2jHyl/dgnqvb1/s1ot6/e5yql9Cg/Qb9mgvaX7Cs6jsqrHDCPVERT2Q4iUagvuiDWXK7TsnEFay3dB0V2ZdLujC6RqtrjOrMUVCfdPqQ9KEBRknPkLt/2TEq+3eCkEEGvXMJ2a3n4fofznlXaud90DPHm4la/35sw/MJLp4MctEXj+zzpMp4i0OQkxZOVByPq631phuVKTdcZJk65XgtryAOH2eUA9DLO7NPfRcHCeEksjD9DfMpOv/56KO2hVYHmST9Mct7bOnLnHj8yvcl4qk2BOT79Y8hyCU0aN9Bb0GC9ifOXnQtvLKpIoZY3onuEJPKhzNQ9U1WPLG3U+0juqwn07LalSWZMZSCV2HHoa48ia4XSWHJ/dQVcxQxlQrHKGIvFZu28RPxcJI7u+Maz7r/uGsXT+TvUeSYqBAFB7MAACAASURBVI6l8AwjE0/smDzCikc8cXNE/QQQ5y94LkpaOFEdsv7tRY9+zqNFf3W1tw+eoHAxqvUrHmhu3nj3YdhTc0EyXLFRv1hUMifpUIzNgmUpnIPiPkVnjzhjogfpoBEkQzzxPxXEfINGH81xomzK35yoiw/RRCRvVVb8kL1WyrAqtfEhTzNcS9E4DGcdR3sRCDoeoxIEkzYO7HyS5htGdekRiG8Mic/seHwJLw6oZFlPTGJ2lk/h+zP7UrST97cej2MlTOaLJ25RSxgRpsfriSKcbf8cyds2hJOvf3Vu5t4f3y8MpfQayD4iq9wMy8BNwhenjJ/5GZU/8e3HRSmc5J3ptk7FsaVPOBFJF2HOXvHIEPUuzlhUwom3XX+fxDEXEhUf496n+Lgw2Qt2rF9GRdmUEQOiznewqP2P8opbNn8iblE+qHLbsn7KsAsai4xttEk+AZ1jKUy0SRyHSbj/C8MUxyaTQPRjXe6sjt4P72+rqPrWY1eOXwDRwzEg88ULydHq+jjlErckClGsFUzYsS13ajopaTvYfZgcB5HfMk4awsnyq76ZubEt7Cq5ck6XVystoyAiJGLfxANI5JrEo6fYDVEnjv3yBmW00PAMFN0P3bwYHuvpM1zmwoBz919i9Cp2KuZUOsKJX+h+5FREE90P84rpCtzcGb847+IvY8uGG1sZ+4GDKeED5a8oJRxkQl0POyaRu4QmFm6VPIFw55b6mR2uPxHuQn+i7S/fH/W+5Pmp23ayMvsKa8dxfABz/nd9WQElgN0oBBS5/Pg7awonyy/N3LjiRtH4xX5XAtpHgybO3n7JDZygD07mcbk+tOLRakzr3181JU3STPgMSnaUbaavP/kM6urT245e4SS/H7tt8d8fdcWqltXgrWUe7mUyXWpxByUmYiEjNqWFlSpjEVtVe2gvRyDseETe5DjH0UqUS+Qqjizo7UPtDsStb9Go8PZX/3gprnhiFydkvqsdz0DSiQ3GTTsbww2BL35/5/GIV4/IE+651H60eHx7MzCFk0vOz9x4yx3S6UVDO4Fgg10PQ963X/oLfRMPFpFncvHqFU7k+hR5bu0Pz0C2p6jbxRWJ35eFug9q2VS3n089iHASpM/BY/xkBffYg/QX9dhS+YKSv5kYtFpqMQflLTPa3VjIiFNBfSq342QYl1vMxY4nzPkbV77C+Cjx8FDsFGjrX4VTXLnTFlxKDVl5kv1ukcOkMlJMi/rGi79AwPfq60uOhtXKu191XsGeLd37EfAQ3WJkX+/rysIrMIkU+N8pq5EvbC3hgE8X/vkatG0IJwu+PDezvvP+sB6n9PhwiQoOzdmv3AUy3IksuBBmXcqb1+aJx2uHXBzBuemd6R/GDz3Hhs+onB9WP6Krbf7XZfhsho1P9lJoUQjaX6kLJyIR1jlK7ONAVTgJylhupBavVdDvgvBniRlzuXKVyWhQ9jK209ImrvETR650xRKHr8UcX0E4lTuTYuYjrr6D51B9xKj/KcmPgrh/v2ej4HH7Z6YExROZRzAv8cR4yPMwIIk4ugWAJR3wSKjM+MJbdTzPBr8HA+ugcAmK7hLp75d4YPh55mOb7VJbDEjuIVynkhwu9ugyFtxynBG5XSz9te4QwnQWSdj4xMfnj0Jxe/dchdHRg/YZfNSEP9KiFvShvxRjDkJN5jtCRnhKC6+oGKvaDcJbJteqfiS9fVI5yfiVxnw5x5MMp6Tf7yb9HClV/8Tnh8roMe/jg94vyDGU80ccl1xvolZmP3I+BXzmcjmssD//Z7YCE54psuUv1ya4eBLmjllE3twfLM8y+Trrqwuo4nRWcfJw2Vec+EG0owoGWy6RcbSS819mcLh7G1BZ9XrOclU0o8lH8JjjyFvQPooZlXfffo/Vape0MPHJHzs4quWPGcyY0leVI9FB+gs6VuI6Tu4a5O1NOTIRjXorZpk/A8WVx1LoJ+xY84ox6BiMyp9SyIUss6gZyfgRtQ9R5Uv23kiGgayPpcpKNj608yYgn/vwI06+L5mM+fujty8ZfuH4qPmrdEfqNK3sqKIwY4MVvXjizIw8Rz8MhnCyfPnyTHNzs8xYRJuEETh06BAdOHCAVXooj/aERVI8dyqYeDN8+HAaOnRo8ZxAzyAAAiAAAiAAAiAAAiAAAiAAAokkcM78xWbFyQMd6xPpIJzyJ7B//34aN24cDRkyBKgCEjh8+DC99957NHLkyIAWcBgIgAAIgAAIgAAIgAAIgAAIgEC5EigQTlDBUHqpnjBhQuk5nTCP9+zZQ0cccUTCvII7IAACIAACIAACIAACIAACIAACxSZQIJzwCoZRo0YRn76ALfkE3n//fYJwEj5PEE7CM4QFEAABEAABEAABEAABEAABEChHAgXCyYcffkhjxowpx1jLMiYIJ3rSCuFED0dYAQEQAAEQAAEQAAEQAAEQAIFyIwDhpMQzCuFETwIhnOjhCCsgAAIgAAIgAAIgAAIgAAIgUG4EIJyUeEZjEU5626huCdH67maqKQavGPqHcFKMxKJPEAABEAABEAABEAABEAABEEg+geIIJ3030eylRPc/ez1VuzES7U8+19g8DCyccDGibg31Zj2tWdFN3c0eskhQ4cLrOEffRPXU3t/O/t9jC9q/QhYgnCjAQlMQAAEQAAEQAAEQAAEQAAEQSBEBQzj5+lfnZr5/v/k6Yuk1Tri4Mfu71JeFVX3Ds/Ts9UwGkRE9vNpYn99PtJQLK9a/XgKLV6Ls9mX8kUm4V7wyPsjYD9gmmHDSRQ1VbVTT3U2mVsJ+byBqb/eQLoIKF37Cib2CpauBqtpqqNuroiVo/wpMIZwowEJTEAABEAABEAABEAABEAABEEgRAUM4WX7VNzPNa25TEE4eoG+Mvomqn32WuFZCxH7/BtGPfzwvnHBigQ8rdoQ9vmAA+MRbssJJF9W7VXnkVYPU0AourpBtqo7bfkt8qWpgEoy51bd3U01bHa3JlrTkVbQUCCFcyMn6k2c/W4lib+/Rfy/rq26wM28RxiNfEE5SdNVDqCAAAiAAAiAAAiAAAiAAAiCgQMAUTi45P9O89k5F4eQBmvfBj4lJJbatj26aPZu+my1D4VUo99NSmm19wCbm3MDFFuJTdfroRCa4PGC0tX9uqzTJVZz8PT1os8uPmPfjD+j6380utF3t8OGSS4h+/UlzWlBe1cg8+jH3PyuyzDvxu/TdB8xQuG2uAQ1uXDhxi5e1yLOZjcPPB240r7LGzsGtb/9sBqs4YTUmDVXUwFWO+nbqz1Wa2AQM3q0lWLBipCVGhUg1tVkCh31/93zaXFdHvc39lFe0IllxYogeXfVM7OD2eemLacf4vLeZ+pv7smusePTP/avrpeasENRlls94T/1xQQrhROGqgaYgAAIgAAIgAAIgAAIgAAIgkCIChnAy98tzM+s71KbqPPCN0fQNLjTM+zF9YFcZ/Ko9HvgGjX5gHn1w/e/YNB8mRGQrVvpuYgII+/xZ5xQdt6k63MZN1fSsc/qOZdtZ9ZLz50S6aTQvizFFEaPPvuuzvnyXTrTEEg/77vE6BBWvKUJOJnbhxMaBeN+Gi05ByntEBhVOchb5NBmuoHABhQsUtnVPzDas6qO7htq4cGIIFIProhTsd061kV3jpGaFWSHibG9UlzBBRNR/fz11GdUugrVSfE5sCCcpuuohVBAAARAAARAAARAAARAAARBQIGBWnCy/NNPc/C/GYdJrnFidGA/7TEGxBBQ3kcC2FgpV3zAokFjih1G10UfXP1tNN9nXNnEKJ0a7QcElv9qDOcRtW5Ul1uKzznVTvPq0f+63cK09XkMAGlznxUSSX8mSq3Sx2/TyiU95ypsCJc5kaOHE6CJbaWIJFF4CSK7yxPF2HcnKklw0su3dhBPft/vwOIIJKBBOxGMNLUAABEAABEAABEAABEAABEAgjQQM4eTi5VdlbmleE0w4MY6yVV44qy6cQofboq9Swok5Bafv+uw0GjcRxSmW2EUUVxHGJtbICif2eC2hx23xWr8FaostnHBBoq2auq15NTkhI3+qTKHQ4bGfvZunzWuqjm0KjVA4MQQc0VSdwf12ew2b51O7sdIt98VQV7IL38qd1hBO5DihFQiAAAiAAAiAAAiAAAiAAAikjUCwxWH5g/9NJ9Kz1hSdArGECRK29UOs1w4XTMnJCg5502Y8Kk6YamJOrXHrk2UtZzu3lonTB5+pOm7VIHYxxDPefJt5g8cSgywOvKImOwXHi4MxVcdtGpLPqAxWcWIKHdZaqkTZRWAN3SH/NcXEp9HYK03c9lvTbGzTeOqz65RYa6n4Lw5rC1BpcVh2nDHNxxR0rIVpfV+t7MESwknaLn2IFwRAAARAAARAAARAAARAAATkCARc4yR/Adbc4q7GG3ZY/Ul2/RO+OOz1fbPNtVDYVj2PLS7yu2rzNcPO6Ttu1SG5KhFToMiaYZbM6TBsXkuh7azgkfNBcnFYS9xxf52yT7yO1xTnpgs5ONgXyfXkYE3zkcud0SqYcKLQQUqaQjhJSaIRJgiAAAiAAAiAAAiAAAiAAAgoEjCEk9PZ4rAPKC4Oq9gPmrsR0PDaZAgneoYWhBM9HGEFBEAABEAABEAABEAABEAABMqNAISTYmYUwkkx6ef1DeEkMamAIyAAAiAAAiAAAiAAAiAAAiCQKAIQThKVDnVnUHGizsztCAgnejjCCgiAAAiAAAiAAAiAAAiAAAiUGwEIJyWeUQgnehII4UQPR1gBARAAARAAARAAARAAARAAgXIjkBNOfvKju8stttTEM2HChNTEGlWgXDjBBgIgAAIgAAIgAAIgAAIgAAIgAAIWgTFjxhg/nvXVBebisFw4wQM4BggIgAAIgAAIgAAIgAAIgAAIgAAIgEDaCfA/rkM4SfsoQPwgAAIgAAIgAAIgAAIgAAIgAAIgAAKuBAqEk4sXzc20/CsqTjBeQAAEQAAEQAAEQAAEQAAEQAAEQAAEQADCCcYACIAACIAACIAACIAACIAACIAACIAACHgQgHCCoQECIAACIAACIAACIAACIAACIAACIAACEE4wBkAABEAABEAABEAABEAABEAABEAABEBAjQAqTtR4oTUIgAAIgAAIgAAIgAAIgAAIgAAIgECKCBQIJ01NTZnGxka8jjhFgwChggAIgAAIgAAIgAAIgAAIgAAIgAAIuBNAxQlGBgiAAAiAAAiAAAiAAAiAAAiAAAiAAAh4EIBwgqEBAiAAAiAAAiAAAiAAAiAAAiAAAiAAArLCyelfnpv5yY/ulp6q09/fTx9++CEdPnwYkGMmMGTIEDriiCOoqqoq5p7RHQiAAAiAAAiAAAiAAAiAAAiAAAikg0BBxYmqcLJ371466qij0kErgVGCfwKTApdAAARAAARAAARAAARAAARAAATKhkBo4YQbmDBhQtkAKbVAwL/UMgZ/QQAEQAAEQAAEQAAEQAAEQCCBBHrbqG4J0fruZqpJoHvFdAnCSTHpa+gbwokGiDABAiAAAiAAAiAAAiAAAiAAAsUiwAWLujXUm+u/hlZ0d1NzHOqFXSzRIZzosFGsPPj0C+EkgUlRcQnCiQottAUBEAABEAABEAABEAABEACBhBFwig2GkNJLzf3tVB+1q7qFk6j9LZJ9CCdFAq+rWwgnukjCDgiAAAiAAAiAAAiAAAiAAAgUgUBBlUYXNVR1Ub0lnORVpAxWo/S21VHdmmydSs0K6u6eT5vr6qi3uZ/aDcWF22mjmk311LWSqL56Da3pMuOrb+dteqmNtc+ZuOwyoic+6dKOHSDrw3qiJdnpPsy4w7/SnQIE4aQI54XOLiGc6KQJWyAAAiAAAiAAAiAAAiAAAiCgl8Drr7/ua/C4D+7PX1ukq4Gq2mqYEMKFBhcRhQsTXKCwVaV0NTQQtbMKFX5sVz31c+XE+rm5z5gKVG2IJVxPsdl3Vpy4tqumNqeQ4+UDm1/U5udfloSIid4MeFs77rjjpLoqEE6aLjk/07j6FukFX4M/uLMBUNdHzX4Lz/CENpiSWM2Kbuo2JnnxgdPA/t/QyahduXzJ0a9jPtlgP/n88tQ8a1d9OxuQZPOHu8Q/sxVUuc3x0jjvKzh/qfGBRiAAAiAAAiAAAiAAAiAAAiAAAiEIcJHA9wHducaJUT2Src4oWP/Eeg5mVSTGc7HzmXhQaGEPqtRVz8SSaseir17Tc9ymDOVEEPsaLD4+5GxwscXNvxAgNR8qzIutv6JUnORECPuAcEIwRBMmmjmEkS4r+UybMOz0NucLFT4wXftl/TRQe34pk8RCPNyPthom5rBBOHg8L3Uy6pIGF/KBcKJ5eMMcCIAACIAACIAACIAACIAACJQOAeEDekHVh219E+Ef3a3CgkEBxXxm5n/hz0738RJEuDjjt8aJtc82/cZ9vVqbD93ZipNcgUShf0nJnDAvxRZOjP4FA6CroY76mp0rCXuUKam8Lsm3Xxfhwy2rnov1OPzzijPngzkHzZpTZuh2VvmU5GhCxYkkKDQDARAAARAAARAAARAAARAAgSIQED6gO59R84oITOGBVRRk/9ifDYAd07B5PrUbszIcz7HZKhX2ah5z1oZIOLGm/Hi2M6tHpHxoNddT4VOJ2rz8K0IO3LoU5sVPOPn6eXMz/3Ln3dFP1fEVMOzTcUxvTUHBKUy4CBWiJPj1K1TzTOO5apPc+6GsRXVcpg65llYxI85qm7x5bKIgBvdDOJFnhZYgAAIgAAIgAAIgAAIgAAIgEDcB4QO6y3OoOVuCzNcSk+N1xcazpDUVxowmf8kJFyElu2CrUTHi6I8/3/IVMmqyi8Out08Tso5znU7k4sP8zdn1Wvz8izsD7v0J82I7rHCNk6Z/zDQ2rkqAcOJcRZiXK/F5XLbPbQvlVNtW7OWDZj0tya3gmzeIPMWR7IrDomk6ntUmhqRirlpstyEzVcewyeIS9e2SbwgnyTjp4AUIgAAIgAAIgAAIgAAIgAAIuBFQeUDXQjDgH+W19F1CRlTyUiCcfKvpqswNjd9OlnCSKz1qpl4uMNhfy2RXzmSS5CqcSIomXBqx1jbJVZvkd2pfg8XYIxROzGqVwVdGyQQx2AbCiRovtAYBEAABEAABEAABEAABEACBOAmoPKDr8KvgmVSH0TK0oZKXwoqTK7+Zabz+xviFE0clR55AYduXWxk4wOKwrkKGV7WHW2WJy2e9bQ20eX57djFY9YoT493WCgvcOscrhJMyPIMREgiAAAiAAAiAAAiAAAiAQNkQUHlAL5ugSyAQlbwUCCdzvzw3c/ePol3jxPlqX2P9Ev6KJNt7qM0FbqyFU2vMuV3GhKzgryN267e5j88d681LqzG1h8/NcvGnq956LXL2ENsrk/knBYu7+lac5M/7CvJ6ZQgnJXBGwkUQAAEQAAEQAAEQAAEQAIHUElB5QE8tpCIErpKXoryOuAhMyrZLCCdlm1oEBgIgAAIgAAIgAAIgAAIgUAYEVB7QyyDckglBJS8QTkomre6OQjgp8QTCfRAAARAAARAAARAAARAAgbImoPKAXtYgEhacSl4gnCQsearuQDhRJYb2IAACIAACIAACIAACIAACIBAfAZUH9Pi8Qk8qeYFwUuLjBcJJiScQ7oMACIAACIAACIAACIAACJQ1AZUH9LIGkbDgVPIC4SRhyVN1B8KJKjG0BwEQAAEQAAEQAAEQAAEQAIH4CKg8oMfnFXpSyQuEkxIfLzyB2EAABEAABEAABEAABEAABEAABIpDYMyYMUbHw4cPd3VA5QG9OBGks1eVvEA4SecYQdQgAAIgAAIgAAIgAAIgAAIgAAIhCdgfqCGchIQZ8+GhhJOmK7+Zabz+RpowYYKU25gqIoUJjUAABEAABEAABEAABEAABEAABMqMAIST0k1oKOHk9C/PzfzkR3dDOCnd/MNzEAABEAABEAABEAABEAABEACBGAhAOIkBckRdQDiJCCzMggAIgAAIgAAIgAAIgAAIgAAIgIBFIArh5ODBg7R7927q7++ngYEBwJYgMHr0aJo4cSINGzZMorXZJJRw8q1/mJ+54Z/vQMWJNG40BAEQAAEQAAEQAAEQAAEQAAEQSCMB3cIJF0127NhhPI/z/4YMGZJGrEoxHz58mPbu3Utvv/02TZkyRVo8CSWcXNR0Zaa18XoIJ0qpQmMQAAEQAAEQAAEQAAEQAAEQAIG0EdAtnOzatYt49cT48ePThjJ0vG+99Rbt27ePJk+eLGUrlHBSf3FT5nstjRBOpFCjEQiAAAiAAAiAAAiAAAiAAAiAQFoJ6BZO+vr6qKamhiorK9OKNHDcfFrTyy+/TNOnT5eyEUo4+RarOLkBFSdSoNEIBEAABEAABEAABEAABEAABEAgvQSiEE5mzpyZXqAhI3/ppZeourpaykoo4eSiRXMzrf+Kt+pIkUYjEAABEAABEAABEAABEAABEACB1BKAcJKs1McmnOB1xMlKPLwBARAAARAAARAAARAAARAAARBIJgEIJ8nKSyzCyXkLqALCSbISD29AAARAAARAAARAAARAAARAAASSSaCkhZOeVpo1q4V68tAuoI1ba6k17/NaWrV1K62sZQ29jhnYSAsSkCIIJwlIAlwAARAAARAAARAAARAAARAAARAAAYtAyQsn5xNt2LqSuCaS27g4Yv/cEEt6aCUXR5z7EjYUIJzIJKS3jeqWEK3vbqYat/ai/TJ9oA0IgEC6CYiuI6L96aaH6EEABEAABEAABECgrAikQjihTbS4spMWCoSTntZZNKslW79Su4q2OgWZGDKfHuGEP3TUraHeLNSaFd3U3cxkEJmHEa821ufriZZwYcX610tg8Uqo3b6MP6KBUWCjl9q48tNaT10rfQQgkV3sBwEQ8CeQtuuM7ZrKwdS391N7PftBx3UMYw0EQAAEQAAEQAAEUkyg5IUTr6k69oqTTYupsrXWFEJ8p/dkq1LYeNi0eDHRxvin76REOOmihqo2qunuJq6VELHfG4ja+R2+zA2+qI1ov+iED3t8gf2sULI+G692+6KAsB8E0kggZdcZ53UlKxpVW+JJGocAYgYBEAABEAABEAABTQRKXjjxmqpjF1Ts1SOeU3V4VcpiVpvC1kgp4nonKRJOuqi+v534H0MHNy4w1NGabBkKr0JZT0uozvqATcxZwcUW4lN1eqmaCS5dRlv757ZKk1zFyXzabLPLj+B/iW3uqyu0XePw4bLLiJ74pDktKO+v1/XUzv3PPqzUV6+hNV1mJLm/8toja6tjkaw3q2q6Gqiur5m6528enHKUZ9sRT67vXmo2mHEf26i628lP01UBZkCgLAhw4SRF1xk3QdZZhceuJezi4XLdYwl3VOdQzQrqzl5Dzeubec2rdjvecU2ub++mGtaOX7rdrodlMbwQBAiAAAiAAAiAQKoIlK1wYgkq9vVNeGaFa5wUV0CJTThpbGzMNDU10YQJE6QGPB8osm1ff/11X5vHHXcc0w6qqIELDfXt1G/Ukmc3v2oMJjhUsZv3/uY+Ns2HPRBlK1Z6+Y08+9y6yc9N0XGbqsNttNVQt3P6jmXbWfWS86ea2qp4WYxZ+m702duc9WUN5f6qK2Gfx95Vz+xUW2u1cNu2B7y8Ps3P+cNKW2+1wau9nj0Q1vVRsy0GEXOpJKMRCCSQAL9euG2iMZ+664zrtTMrHnXXUJvbulC56x4xkWnw+par/OPXUDb9x7Nqxe2a3MeusQ19psjNf3Zcb0V5S+AQhEsgAAIgAAIgAAJlTMDrXtMZctkLJzxgPlWHz7zxW+OECSqL2bP3RvPVO+ytPIbyYr6JJ8YtNuHkosYrM61N10uLIarCiewA5NUXVVxBsQQUj3Jzay0U+19Bc4vDGn8pZdUY1sOB1xonRrtBwcX1L6xWdYf1kOHyF1tjdpGzT0vE8BR+rL9+N1OfVS1it+1Ym4ABMf66yxQS6mvuZsIJe6hh1SptbdWsaoUJR/xfu+AU4yBFVyAQFwH+kO0nnOA6Y1sgW1Y48aksybumeq0TJTpe9xpRcQ029AMCIAACIAACIJA6An73mqkUTrgUYiz8SrTqgQW0iRUrF7yJx1hAlk/VMbfaVVtpa9yqCes3NuGk8eLzM00ttxRfODFw20rqnTfdTqHD7WZeSjgxp+D0NtsWS3SzHZlwwmfoMBGkni0I25UVPbxEGdtZyitb2qp5eT2vMOFTjtgUHfZrF/HKk9Rd2xBwyghoE07ScJ2RmapjVJA4xGN+TW3uZWKsrRLPVzB2Od5e3QfhJGVnKcIFARAAARAAgdIlkBrhpHRT5Ol5bMLJkvPmZm6+8+7iCCf8xtpeMVEglmTX8nA8CBRMyclWeeRNm7ELK7abeWNeP59aY6kNXrad64nITNWxl8CLphqx6prCN13kTwPKGx3MXsOSLia4mOuj9LLKkzZWflPT3J5dWLcMzwKEBAJZAqGEk7RdZwquPVyQzk6/saYFOqYv5q6p3fwaZFuw2084sV3vXK/JEE5w/oIACIAACIAACJQIAQgnJZIoFzdjE05O//LczE9+VCThxFjcdHAR2NzirsYcGF6ZYa5/wheHbe6tM9dCYVsNq9agvhrzNcP2qS18EUN7pUjBVB1TmMiaYZasaTDZdVbstrNiTM4HycVhC0rcXV+B7FisskAwGnw9szElybDheDOI1xoqpTvm4TkIeBIIJZyk7TrjnEJjLZrNr6u2a02ftb6U87pnTZu0smFbHDZ3fbNdnwuuyc7pjc7qPYxzEAABEAABEAABEEgYgWIKJ9u3b6cTTjiBKisrE0Yl+e4MDAxQby97WUw1WwNUYgua57POW0AVxRVOJKJDExAAgdQTCCecpB5fcAD2xbKDW8GRIAACIAACIAACIJBoAkEfqIcPH+4al4q9nTt30qhRo2jixImJZpRE5/j6q/v27aNJkyZJuaeSF/siwBBOpPCiEQiAQLEJQDiJLwO5z2rASwAAIABJREFUN50ZXWZftx5f9+gJBEAABEAABEAABGInEPSBWodwcvDgQdqxYwcdffTRNG7cOFSeSGSfV5pwYePdd9+lKVOm0LBhwySOIgqaZwgnUnjRCARAoNgEIJwUOwPoHwRAAARAAARAAATKl0DQB2odwgmnysWTV199ld555x3KZDLlC1pTZEOHDqWxY8fS9OnTpUUT3nXQPEM40ZQ4mAEBEIiWAISTaPnCOgiAAAiAAAiAAAikmUDQB2pdwkma2ccZe9A8QziJM0voCwRAIDABCCeB0eFAEAABEAABEAABEAABAYGgD9QQTkpraAXNM4ST0sozvAWB1BKAcJLa1CNwEAABEAABEAABEIicQNAHaggnkadGawdB8wzhRGsaYAwEQCAqAhBOoiILuyAAAiAAAiAAAiAAAkEfqCGclNbYCZpnCCellWd4CwKpJQDhJLWpR+AgAAIgAAIgAAIgEDmBoA/UEE4iT43WDoLmGcKJ1jTAGAiAQFQEIJxERRZ2QQAEQAAEQAAEQAAEgj5QQzgprbETNM8QTkorz/AWBFJLAMJJalOPwEEABEAABEAABEAgcgJBH6ghnESeGq0dBM2zIZw0Xnx+pqnlFpowYYKUU3v27JFuq+KYVOdoBAIgkEoCEE5SmXYEDQIgAAIgAAIgAAKxEFB5buXPw2PGjDH8gnASS3q0dRI0z4ZwclHjlZnWpuulxRAIJ9ryBkMgAAKSBCCcSIJCMxAAARAAARAAARAAAWUCQR+odQknBw8epN27d1N/fz8NDAwo+5/GA0aPHk0TJ06kYcOGSYcfNM9mxcm3lmaabvguhBNp3GgIAiAQNwEdwonXF1vcsaA/EAABEAABEAABEACB+AgcOHBA2FnQB2odwgkXTXbs2GE8j/P/hgwZIvQ37Q0OHz5Me/fupbfffpumTJkiLZ4EzTPWOEn7iEP8IFAiBMpJOKmoqKBMJlMi5OEmCIAACIAACIAACBSHgK57pqQLJ7t27SJePTF+/PjigC7hXt966y3at28fTZ48WSqKUMJJ0ipOntj+R7rj0dfpiZf/RH/cf5DGjhxGXzjhSLrqi8fRF6aPlQKCRiAAAuVFAMJJeeUT0YAACIAACIAACICAiEBahJO+vj6qqamhyspKERLsdxDg05pefvllmj59uhSbUMLJRY2NbI2TpkRM1Wna+Ap9/9FdnkFf9aXj6JZFn5GCgkYgAALlQwDCSfnkEpGAAAiAAAiAAAiAgAyBNAknM2fOlEGCNi4EXnrpJaqurpZiE0o4uYItDvudBCwOKxJNLBIQT6TGBBqBQFkRgHBSVulEMCAAAiAAAiAAAiAgJADhRIgIDRiB2ISTixbOzbTedndRK0749JwzbukeTPzAQaLMIfYfWweArQdAFWyl3Mqhuf3/ubzOf9pOVwNVNXQN2qtvp/7mPqqrW0O9/Of2+ty+roYqauhbQd3riZbw/caeemrvrqG23O9Wc/Z5fzvbiw0EQCBOAhBO4qSNvkAABEAABEAABECg+AQgnBQ/B6XgQWzCyelnzM385L7iCicL73yJ/m/3HjMvhw/R8UcNpfsu/Uv6u+oJ9MLOP9G8W39Dv9/LXsuUFU/OO3kCdV7hXs7U21ZHdWuq8wSOroYGomYmhCzppWpic8jWd/NfiXrbqG4JF1jqaX13M9UYv1Phz6UwYuAjCJQxAQgnZZxchAYCIAACIAACIAACLgQgnEQ4LDYtpsrFmwY7WLCRBlb20qxZLdTDf964ILdv0+JKWty3irZuIDqf7zf2LKCNW2upNfe71Zx9PrCR7Y1vi0c4qaeKJAgnE6/5tbEQrLEd+oi6bzydTp58ZI72Y3176PS2J4mGjTQ+GztyKL1126ku2ehlVSKG8mEKI/YtK4o013dRG62nbtaAV5t01aygPqadQDiJb3CjJxBQJQDhRJUY2oMACIAACIAACIBA6RDgIonbpuNNhEl/qw5fHDbONU56WmfRrJbqPIFj0+LFRCuZEHJ+j1FoULthK/+VqKeVZp3PBZYFtGHrSqo1fqfCn4s41FIlnFT9468GUR/YRxnbVBprR0XDZqLhR+Ta9d99emF6uDhS10vNbtNpctUk1dRW1UX1fCoO11j4FB23KhPDljV1x+oKU3WKeE6g6xQTgHCS4uQjdBAAARAAARAAgVQSQMVJFGnvYVUihvJhCiP2LSuKrFywiVppA21lDXi1SWftKupj2gmEkwRM1cmrOPn4PfrVitPptNqJuTS+8Pv3qO7b/0n0CbMKxbPixD7VxjnObPv6+LomrMqkvr2f2qs9puf42YpiDMMmCICAJwEIJxgcIAACIAACIAACIJAuAhBOIsg3F0dm9dBKt+k0uWqSGmqt7KSFfCoO11j4FB23KhPDljV1x/IVU3VyWduzZ4/0QrKyr/vJW+OEVZxMGTNAm//PF+nkKePpsW1/oAu+/yT9ft9woqEjDD+81zjpooaqNqrp9p6qk5uSY1WmeK1rAuEkgjMVJkEgGAEIJ8G44SgQAAEQAAEQAAEQKFUCEE4iyJx9qo3TvG1fH1/XhFWZLNg4QBurPabn+NmKwHUvk6maqlPwVp0DHxId+IBo4ADREPZGnarRbJrOqBwrv7fq+C8Om13LxE4dwkmMwxpdgUAwAhBOgnHDUSAAAiAAAiAAAiBQqgQgnESRuU20uLKVard6T9XJTcmxKlO81jWBcOKfoCgqTniPyze+Snc8+rpwdFz1xUl0y+Jpvu1M8cR8sbCxWa8jttYycRNO3F5H7NZe6CEagAAI6CYA4UQ3UdgDARAAARAAARAAgWQTgHASTX78F4fNrmVi7xrCCZ11Hnurzny2xskdRX4dsZUXkXgiI5pEM7xgFQRAoJgEIJwUkz76BgEQAAEQAAEQAIH4CUA4iY65KZ6YLxY2Nut1xNZaJm7CidvriN3aR+e2q+XYpuo0fmtppumG70qvWxJVxYlFgU/bueOXu4j/y19RPHbkMPrC9LF01ZcmGf9iAwEQSB8BCCfpyzkiBgEQAAEQAAEQSDcBCCfpzr9s9LEJJxc1Xplpbbo+McKJLCC0AwEQSA8BCCfpyTUiBQEQAAEQAAEQAAFOAMIJxoEMgdiEk0YmnDRBOJHJCdqAAAgUiQCEkyKBR7cgAAIgAAIgAAIgUCQCaRFOtm/fTieccAJVVlYWiXTpdjswMEC9vb1UXV0tFYTsW3+5MT7TZsyYMYZdY40TVJxIMUYjEACBIhJIjnDSSYsqFlGnxWJhB2U6FrLf7J8vpI5MB/FP3TZdNwFFTAe6BgEQAAEQAAEQAIHICei6ZzpwgL2pVbAFfaAePny4q2UVezt37qRRo0bRxIkTRW5iv4MAFzf27dtHkyZNkmKjkpcC4eSKxksy32lajak6UqjRCARAoBgEEiOcdC6iRdRBhlZCPdQyYzHRxm1U01JBnQszxuc9LTNoRs+qrKBSSEvXTUAx8oA+QQAEQAAEQAAEQCAuArrumZIunBw8eJB27NhBRx99NI0bNw6VJxIDjFeacGHj3XffpSlTptCwYcMkjiIKJ5x8fX7mO/9yB4QTKdRoBAIgUAwCiRFO8oLnVSadtDCzkDqNf7NVJj0tZOopq6jWBZaum4Bi5AF9ggAIgAAIgAAIgEBcBHTdMyVdOOE8uXjy6quv0jvvvEOZTCYuxCXbz9ChQ2ns2LE0ffp0adGEBxtKODmdvY74Jwl5HXHJZg6OgwAIREogWcIJrzSZQat7rCk5loBiTc9x/p6Pht8ErF69Ou/DVatWRcoPxkFAhcCkH33baL7rgn9WOQxtQQAEQAAEQEArgTQJJ1rBwZgnAQgnGBwgAAJlTSBZwomFmgskLVTLKkt6ZtgqToz1Tuy/Fwon+EtCWQ/Xkg+OCydcNLH+LfmAEAAIgAAIgEBJEoBwUpJpS7TTEE4SnR44BwIgEJZAMoUTtiTsIr62SQfRIkzVCZtjHJ8MAnaxBMJJMnICL0AABEAgrQQgnKQ189HFDeEkOrawDAIgkAACSRFOeloW0aYFHbTKWLzEqjjB4rAJGCJwQRMBCCeaQMIMCIAACIBAaAIQTkIjhAEHAQgnGBIgAAJlTSApwgkrMaEKVl1ibQs7zDfp4HXEZT38UhWcs8oEVSepSj+CBQEQAIFEEYBwkqh0lIUzZSWcvPLKK7Rlyxbavn077d+/n0aOHGmsljtnzhyaNm1aWSQMQYAACKgRSIxwoua2a2tdNwEaXIEJECggAOEEgwIEQAAEQCApBHTdM5XCW3WSwrzc/Sgb4aSjo4NefPFFOu2002j27Nk0YsQI2rt3r/FqpoceeohOPvlkWrjQ+PMuNhAAgRQRgHCSomQj1KIRcKsuQcVJ0dKBjkEABEAg9QQgnKR+CGgHUBbCCRdNeIXJvHnzDMHEuX300Ue0efNmGjVqFMQT7UMIBkEg2QQgnCQ7P/CuPAhAOCmPPCIKEAABECgXAhBOyiWTyYkjlHCy5Ly5mZvvvJsmTJggFdGePXuk28o6xqfn3HfffXTddde5iiaWY1w8ufnmm2np0qXG9B2vrbetjurW9OZ216zopu7mGqLeNqqrW0O99e3U316f29/VUEUNfSuoez3REr7f2FNP7d011Jb73WrOPu9vZ3uxgQAIxEUAwklcpNFPmglAOElz9hE7CIAACCSPQJqEk4MHD9Lu3bupv7+fBgYGkpeMBHo0evRomjhxIg0bNkzaO1l9ghvkuseYMWMM22edV08VVzRekvlO02ppMSQK4eSuu+6iGTNmGNNzRNtjjz1Gr732Gl122WWuTQ3RpKueurubiUklbOuihqoG6uPiyfzNVLekl6qpj2rWdxPXUgwxZUmXIZSs58cYv1PhzyLHsB8EQCAyAhBOIkMLwyCQIwDhBIMBBEAABEAgSQTSIpxw0WTHjh3G8zj/b8iQIUlKQyJ9OXz4sLGkx9tvv01TpkyRFk9CCSeNjY2ZpqamogonvP9rr72WjjrqKGFieNVJa2srrVu3zqUtF0naqKY7K4pYLSwxhFeUMFGkub6L2mi9UYXCq026alZQH9NOIJwI8aMBCBSFAISTomBHp0klwP8SVVlpesf+MkVVVVo85cLJwmP76afbfkoV7H9fm/E1uvUrt1LZr3MSEU8tSVE1UsqxJMT3ZY8sKzgHVNOgs33S/NEZG2yBgIhAWoSTXbt2Ea+eGD9+vAgJ9jsIvPXWW7Rv3z6aPHmyFJtQwsmSixszN7cUVzi5/PLL6fbbb5cKlje6+uqr6c477yxsb68WydvLBZUuqudTb4xqkmpqs/+eFVRchRNM1ZHOCxqCQFQEIJxERRZ2S44Au7Gijz8mYn+dIvbXFvbqOWJ3W0TvvBM6lBH/MpU2zruNZh87mzLsf0+//jTd230vvdA/g3Zd8M+h7SfSQIQ8Y4+3lGNJiO9n/uRMumL2FQXnwM8bfh57OnmHSfOnKBDQaaoJpEU46etjsyFqatjfRLJ/FEl11tWC59OaXn75Zd9lPOwWQwkn85lwckeRhRNecbJy5Urf9U2sgHlJztq1a90rTqSFk2bq4+uasCqT+vZ+aq/2mJ7jaU8toWgNAiAQjgCEk3D8cHQZEeDzeLloUlFhBnXoENGRRxL7c0uoIEff+llqP3clnTvt3Dw7Xawc85sP/wt9sOzZUPYTe3BEPIsSbynHkgDfeWXHnKlzXM+Bp15/itZ92a3SObpMJ82f6CKFZRDwJpAm4WTmzJkYCgEJvPTSS1RdXS11dCjhZMm3WMXJDcWtOOFrnEydOtV4DbFoe+aZZ6inp8djjRO5qTq5ypK6XmrmC716rWsC4USUDuwHgVgIQDiJBTM6KRUCXDTJZIitHmdO0+HiSchtaNso2nXNq/SpUZ/Ks7T7g9306dtPoEPNH4TsIcGHR8CzaNGWcixF9v2YdcdQ96XdrufAZ+/5LL3R+EasaU2aP7EGj85AIEsAwgmGggyB2ISTRrY4bFORF4fdvn073X///VrequO1OCx7FU5+ZYk9CxBOZMYk2oBA0QhAOCkaenScNAJ8eg4v5eVrm/B/hw83BZSQ29A1o+n1ZdvpmFHHpEs4iYhnyHQEO7yUY0mA78euO5aev/R513OgGMJJ0vwJNihxFAiEIwDhJBy/tBwdm3DScN7ZmbV33lPUxWF5Ujs7O42FXebPn+86ZYcvCrt582Y64ogjaNGiRb7jwPk6YmM6Dn9/sFcFiX3xWOfriK037KRl5CFOEEggAQgnCUwKXCoOgU98gmj/flMw4VUnXEDh60Ow78gw2+hbZ9OPz76e5p04L89MR28HXfTIOjZV55kw5pN7bEQ8ixJwKceSAN8bH2mkUyef6noOPPfGc7T2jLWxpjVp/sQaPDoDgSwBCCfRDIWe1lk0q6UnZ7x21VbaurKWqKeVZs1qoZ4FG2lg44Lc/k2LK2lx3yrauoHofL7f2LOANm6tpdbc71Zz9vnARrY3vi024eT0M87O/OS+4gsnlnjywgsv0JlnnknTpk0z3rLDBRM+Pefxxx+nk046SSia5KUIU23iG7HoCQQiJADhJEK4MF1aBMaONReH5f/xbcQIc42TN98MFQd/c87JVdvogroL6JRJpxi2ntz5JG3o2UC/3X9i+S4OGxHPUMkIenApx5IQ389pP8f1HHhw8YNBsxLquKT5EyoYHAwCAQhAOAkATXCIIZpsWkBbt64kJpWwbRMtrlxMfVw8YW+enXV+D1VTH9Vu2EpcSzHElPM3sR8W0AZ+jPE7Ff6s31Vpi6kUTjgdPm1ny5Ytxr9cNBnBbgqnT59Oc+bMkV4t106Zv26YLwJLVEMrnK8plk4HGoIACBSTAISTYtJH34kjEMFrW61XDjf9R5PxKla+NcxsyP2VvaxfSRwBz6KNmVKOJSG+e50Dxcpp0vwpFgf0m04CEE50552LJK1UuzUriljmLTGEV5QwUWTlgk3UShuMKhRebdJZu4r6mHYC4SRBFSe6hwbsgQAIlAcBCCflkUdEkVwCImFEtD+5kcEzEAABEACBUiUA4URz5uzVInmmuaDSSQv51BujmqSGWu2/ZwUVV+EEU3W8k7Rnzx7p9VBUXvejeVjAHAiAQBkRgHBSRslEKIkjICOKyLRJXGBwCARAAARAoKQJQDjRnD5p4WQl9fF1TViVyYKNA7Sx2mN6jqc9zX4LzKV2qk68mNEbCIBAKRCAcFIKWYKPpUpARhSRaVOq8cNvEAABEACBZBKAcKI7L3JTdXKVJbN6aCVf6NVrXRMIJ/4JQsWJ7gEMeyAAAiICEE5EhLAfBIITkBFFZNoE9wBHggAIgAAIgEAhAQgn+keF1+Kw7FU4+ZUl9q4hnNBZ59VTRZLeqqN/aMAiCIBAORCAcFIOWUQMSSUgI4rItElqfPALBEAABECgdAh0dnbmnF20aBFlMpnQzh84cEBoQ2WJCV5IMGbMGMPm8OHDXW2r2Ovr66OZM2cKfdTVwPk6YmM6Dn9/sFcFiX3xWOfriK037OhyLoAdTNUJAA2HgAAIlCcBCCflmVdElQwCMqKITJtkRAMvQAAEQAAEyoUAKk4izmRCptqEjRLCSViCOB4EQKBsCEA4KZtUIpAEEpAVRWTbJTBEuAQCIAACIFCCBCCcRJ80/rphvggsUS2tcr6mOPrutfQA4UQLRhgBARAoBwKJEU56WmjGjNXUk4Vau3obbVtVy0ob7Z/X0upt24h/7Lbpugkoh7wihmQQkBVEZNslIyp4AQIgAAIgUOoEdN0zJX2qzvbt2+mEE06gysrKUk9Z7P4PDAxQb28vVVdXS/WtMoXKPiULa5xI4UUjEACBYhNIjHDSuYgWUQd1LOREOmlRRQvVbttItHgx0casWMLaVLTU0rZtq5h2X7jpugkodk7Qf3kQUBFDVNqWBx1EAQIgAAIgUEwCuu6Zki6c7Ny5k0aNGkUTJ04sJu6S7JuLG/v27aNJkyZJ+Q/hRAoTGoEACJQqgcQIJ3kAe6hlBhdMHMIJrz4xdBQIJ6U63tLkt4oYotI2TQwRKwiAAAiAQDQE0iKcHDx4kHbs2EFHH300jRs3DpUnEsOJV5pw0eTdd9+lKVOm0LBhwySOIior4eSVV16hLVu2EC9Z2r9/P40cOZKmT59Oc+bMoWnTpkkBQSMQAIHyIpBI4SRPIOHVJ4tYDQrfxFN1Ojo6cglauNAoX8EGAkUhoCKGqLQtSjDoFARAAARAoKwIpEU44Unj4smrr75K77zzjpY3CZXVQHAJZujQoTR27FhDJ5AVTbiZshFO+MPEiy++SKeddhrNnj2bRowYQXv37jUG0UMPPUQnn3wy4SGj3E8DxAcChQSSJ5xY03TM6Tmdiyqoc2GGTeHhVSgzaHVNB2XM+TwFm66bAIwTENBBQEUMUWmrwzfYAAEQAAEQSDcBXfdMSZ+qk+4sxxt9KOFk2bJlmeXLl9OECROkvOYlMbJtVRzjogmvMJk3b54hmDi3jz76iDZv3mzM/4J4IpUqNAKBsiGQLOEkXzQxFobNm5pjTeFxXyBW101A2SQXgRSVgIoYotK2qEGhcxAAARAAgbIgoOueCcJJWQwHLUGo6BMFi8OedsbZmfX33SMthkQhnPDpOffddx9dd911rqKJRYmLJzfffDMtXbrUKMsp2HrbqK5uDfXWt1N/e31ud1dDFTX0raDu9URLZPYbR9ZTe3cNtfH2eR2xz/vb2V5sIAACcRFIjHBivD2nkxbmvTXHnKZDHbzihBEx2vTQqkwHudWc6LoJiIs9+ilvAqpiiGr78qaH6EAABEAABKIkoOueCcJJlFkqLdslL5zcdddd7EFjhjE9R7Q99thj9Nprr9Fll13mLpwsYa8joj6qWd9NzTWsCRdTlnQZQsh6Lpz47e9uphqjPdF6588ix7AfBEAgMgJJEU56WmbQjNXWy4jNcI1XEi/YZHtNsXiNk0wmExkrGAYBFQKqQohqexVf0BYEQAAEQAAE7AQgnGA86CZQ8sJJU1MTXXvttXTUUUcJ2fCqk9bWVlq3bp2HcELUXN9FbbSeuplywqtNumpWUB/TTkzhxGc/hBMhfzQAgWIQSIpwoiN2XTcBOnyBjXQTCCKCBDkm3ZQRPQiAAAiAQFACuu6ZUHESNAPld1zJCyeXX3453X777dKZufrqq+nOO+/0FE7Wd1dTW1UX1fOpNrx6JCuY5P712u8mnGCqjnRe0BAEoiIA4SQqsrCbZgJBRJAgx6SZMWIHARAAARAITgDCSXB2ONKdQMkLJ7ziZOXKlb7rm1ih87fsrF271rfihE+z6ePrmrAqk/r2fmqvzk6/sQQUr/2oOME5BgKJJADhJJFpgVMlTiCICBLkmBLHBPdBAARAAASKRADCSZHAl3G3JS+c8DVOpk6daryGWLQ988wz1NPT47PGiW19krpeauYLuVrrltiEE2MtE+d+CCci/NgPAkUhAOGkKNjRaZkTCCKCBDmmzDEiPBAAARAAgYgIQDiJCGyKzZa8cLJ9+3a6//779bxVx1rY1T4g3IQTt/0QTlJ8GiH0JBOAcJLk7MC3UiUQRAQJckyp8oHfIAACIAACxSWQJuHk4MGDtHv3burv76eBgYHigi+R3kePHk0TJ06kYcOGSXscSjhpOPfszNq7ivs6Yh5pZ2cn7du3j+bPn+86ZYcvCrt582Y64ogjaNEi9upPt83+Rpwgwon1umLj2OzriN2EGOnUoCEIgIAOAhBOdFCEDRDIJ+Amgix7ZBn9dNtPqYL972szvka3fuXWvIOKJpzwm8jKStMXdlNJVVVIZ7kTUMm5SlsBN9E5EDf2pPkTd/zoT57A975HxF4+Sl/4AtE118gfJ2yp8fwS9uVokBbhhIsmO3bsoAkTJhj/DRkyRBVV6tofPnyY+BIeb7/9Nk2ZMkVaPAklnCy74huZ5d+5yUiSzLZnzx7ptiqO8b65ePLCCy/QmWeeSdOmTTPessMFEz495/HHH6eTTjrJWzSRcR5tQAAESpIAhJOSTBucTjgBpwhy5k/OpCtmX0Gzj51NGfa/p19/mu7tvpd+3vDz4oon7C9K9PHHROzGktiNEo0cScQ/e+edhBOGe4EJqORcpa3AIdlzIHBcigcmzR9F99E8ZgIVFYMdZjKaOtd4fgXxKC3Cya5du9jX2mgaP358EEypPuatt94yii8mT54sxUFFn+C6x5gxYwy7Z51XTxXLll2cWb68RVoMiVI44U7xaTtbtmwx/uWiyYgRI2j69Ok0Z84c419sIAAC6SMA4SR9OUfE0RJwiib8r9pzps6hc6edm9dxV18XPfX6U7Tuy+tyn8dedcJLcLloYj0VHDpEdOSRxO6UooUE68UjoJJzlbY+EamcA3GASZo/ccSMPoITaGkxq02s7e/+jmj16uD2ckdqOr+CepIW4aSvr49qampYYWW2sjIosBQex6c1vfzyy9I6QTjh5KKvZZa3rkuMcJLCfCNkEAABAQEIJxgiIKCXgFP8OGbdMdR9aTd9atSn8jra/cFu+uw9n6U3Gt8onnDCe+aiCf8TKi8Z59N0uHiCrbwJqORcpa0HNZVzIA7wSfMnjpjRR3AClq7ML5P2n4NbtB2p4fwK6keahJOZM2cGxZT641566SWqrq6W4hBKOJl/xtmZO+4r/honUpGiEQiAQCoJQDhJZdoRdIQEnMLJseuOpecvfZ6OGXVM8oQTPj2H/xWOr23C/x0+3BRQsJUvAZWcq7T1IaZyDsQBPmn+xBEz+ghGwKo2sapMnL8Hs5o9StP5FdQHCCdByaXruNiEk9OYcLIewkm6RheiBYESIwDhpMQSBncTT8ApnDQ+0kinTj6V5p04L8/3jt4Oeu6N52jtGWtzn8c+VecTnyDav98UTPifU7mAwufds+m82MqUgErOVdr64FI5B+KgnjR/4ogZfQQj4FZhoq3qRNP5FSwyXj1TwS774RdsOXDggNCFoJUIw/kboqDEAAAgAElEQVR3k8umYo9P1UHFiTBFng0gnARnhyNBAATKjACEkzJLKMIpOgE38eOc9nPogroL6JRJpxj+PbnzSdrQs4EeXPxgnr+xCydjx5qLw/L/+MbWPjPWOHnzzaJzhAMREVDJuUpbgbuy50BEUReYTZo/ccWNfuQJeFWXaKs60Xh+yUc12BLCSRBqPsf0tNKsWS3Us2AjDWxckGu4aXElLe5bRVs3EJ0vs984cgFt3FpLrbx9Xpfs84GNbG98W2zCybJly9jisMuxxkl8uUVPIAACigQgnCgCQ3MQEBDwEj+a/qPJeB0x3xpmNuRVmlgmYxdOeMdFfB0mBlORCKjkXKWtIByZcyBOIknzJ87Y0ZeYwOmn5y8K6zzitNOIfvUrsR3fFhrPL1VPIJyoEhO058LJ+T1UTX1Uu2Erraxl7Y3PNrEfFtAGLpz47d+6kmqN9kQbnD9rdlXFXGzCCabqqKQFbUEABIpBAMJJMaijz3IloEP40GGjXPkiLhAAARAAAT0EIJzo4ZizkhU9Vi7YRK20gbYy5YRXm3TWrqI+pp2YwgmR534IJ1jjRPOQhDkQAAHNBCCcaAYKc6kmoEP00GEj1UlA8CAAAiAAAkICEE6EiNQa5KpFaqi1spMW8qk2vHokK5jk/t3qsd9NOEnTVB1UnKiNN7QGARCInwCEk/iZo8fyJaBD9NBho3wJIzIQAAEQAAEdBCCc6KBos2GbZtPH1zVhVSYLNg7Qxurs9BtLQGECiet+VJyg4kTzkIQ5EAABzQQgnGgGCnOpJqBD9NBhI9VJQPAgAAIgAAJCAhBOhIjUGjjXJ5nVQyv5Qq7W5zbhxFjLxLkfwgmEE7URh9YgAAJxE4BwEjdx9FfOBHSIHjpslDNjxAYCIAACIBCeAIST8AzzLNiFE/sON+HEbT+Ek2QJJ6+88gpt2bKFtm/fTvv376eRI0fS9OnTac6cOTRt2jTNowfmQAAESoEAhJNSyBJ8LBUCOkQPHTZKhRf8BAEQAAEQKA4BCCeauYcVTqzXFRtuZV9HbL1hR7OrKuZS+Vadjo4OevHFF+k09u6s2bNn04gRI2jv3r306quv0kMPPUQnn3wyLVy4UIUj2oIACJQBAQgnZZBEhJAIAroED112EgEFToAACIAACCSSAISTRKYlcU7FJpw0nHt2Zu1d99CECROkIOzZs0e6rd/DjrMzLprwCpN58+YZgolz++ijj2jz5s00atQoiCdSmUIjECgfAokRTnpaaMaM1dSTRVu7ehttW1Vr/ta5iCoWdRo/5n3uSIOum4DyyS4iiZOATsFDp604GaAvEAABEACB0iCg657pwIEDwoBVnlv58/CYMWMMm8OHD3e1rWKvr6+PZs6cKfQRDdwJxCacLLviG5nl37lJWgyJQjjh03Puu+8+uu6661xFEwsRF09uvvlmWrp0qTF9p2DrbaO6ujVEK7qpu7nG3M0/W0K0fj3REravt76d+tvrc4d2NVRRQ98K6rb2G3vqqb27htp4+7xO2Of97WwvNhAAgTgJJEY4YeLIIuqgDqPwrZMWVbRQ7bZttKqXiyZEHZkOEtXE6boJiJM/+iofAjrFDp22yocwIgEBEAABENBFQNc9U9KFE75ExQknnECVlZW60KXGzsDAAPX29lJ1dbVUzCqCll0gO+u8eqpYdtHXMstb1xVVOLnrrrvYX3FnGNNzRNtjjz1Gr732Gl122WWFTQ2RhIGjPqpZ302GdmIXTlz3dRlCyfruZqqx2jp/FjmF/SAAApESSIxwkhdlD7XMWEy0cRvVtMyg3lVMQMkWn/jB0HUTEClwGC9bAjrFDp22yhY4AgMBEAABEAhMQNc9U9KFk507dxqzKiZOnBiYVVoP5OLGvn37aNKkSVIIQgknZ59xduae+4o7VaepqYmuvfZaOuqoo4QB86qT1tZWWrdunYdwwqpLmnuprqverCzJE06Imuu7qI3WGxUpvNqkq2YF9THtBMKJED0agEDRCCRSOOHTdgzdpIZaWLmJOUnH3BZ2ZLJVKYXI+E0An5qYa4t1m4o2rtLYsU6xQ6etNOYCMYMACIAACBQS6OwcvKNatGgRZTKZ0JiSLpwcPHiQduzYQUcffTSNGzcOlScSGeeVJlw0effdd2nKlCk0bNgwiaOIQgkny5ZdnFm+vKWoFSeXX3453X777VLB8kZXX3013Xnnnd7CCasY6eOiSH0/tVfbpurwKTvd1dRW1UX1fCqONYXH+Nyl4gRTdaRzgoYgECWB5Akntmk6tfznTlpoTdMx1kHpoVUe03Z0/fUkSt6wXb4EdIodOm2VL3FEBgIgAAIgEJSArnumpAsnnA8XT/gLUd555x0tYlFQ5qVy3NChQ2ns2LHG8h2yogmPLZRwcuGyb2XWLL+hqMIJrzhZuXKl7/omVhL5W3bWrl3rX3FiF0H42iUOgYSLKg2syqS+3SasYKpOqZwn8DOFBJIlnNhFE54Mh3DClo61pvC4Td3RdROQwmGAkEMS0C106LYXMjwcDgIgAAIgUGYEdN0zlYJwUmapS2w4oYSTJCwOy9c4mTp1qvEaYtH2zDPPUE9Pj88aJ9nqEWaot62OTcupN6fiWAKKJZDU9VIzX+jVa10T++cip7AfBEAgUgKJEU6MahJWXcIXhLWtZ9K5qIJaarNv2EHFSaRjAcaDE4hC6IjCZvAIcSQIgAAIgEA5EYBwUk7ZTEYsoYSTJKxxwlcSvv/++/W8VceadmPkposaqhqMdUyMt+bk7csmD8JJMkYxvAABHwJJEU562CKwM1ZbLyM2HTZfPUysymQGmbtqabVDWLGHpusmAAMGBFQJRCFyRGFTNS60BwEQAAEQKE8Cuu6ZUHFSnuMjSFShhJPT2OKw64u8OCwPmi8ExFfEnT9/vuuUHb4o7ObNm+mII44gvlCQ6+ZWJdLVQFVtNWLhxO11xG5CS5AM4RgQAIFQBJIinIQKInuwrpsAHb7ARroIRCFyRGEzXVlBtCAAAiAAAl4EdN0zQTjBGLMIlIVwYoknL7zwAp155pk0bdo04y07XDDh03Mef/xxOumkk7xFE4wHEACBsiUA4aRsU4vAYiQQhcgRhc0YkaArEAABEACBBBOAcJLg5JSoa2UjnHD+fNrOli1bjH+5aDJixAhjtdw5c+YY/2IDARBIHwEIJ+nLOSLWTyAKkSMKm/ojh0UQAAEQAIFSJADhpBSzlmyfy0o4STZqeAcCIFAMAhBOikEdfZYTgagEjqjslhN7xAICIAACIBCMAISTYNxwlDcBCCcYHSAAAmVNAMJJWacXwcVAIEqBI0rbMaBBFyAAAiAAAgklAOEkoYkpYbcgnJRw8uA6CICAmACEEzEjtCgjAgMDRJWVZkD9/URVVaGDkxU3lj2yjH667adUwf73tRlfo1u/cquwb1nbQkNoUEgggrEQG+YS9T3IORAl06T5E2WssK2JQImee27Rp0k4OXjwIO3evZt97ffTAM8hNiGB0aNH08SJE2nYsGHCtlYDCCfSqNAQBECgFAlAOCnFrMHnQATYTQB9/DERu4Giw4eJRo4k4p+9804gc9ZBMuLGmT85k66YfQXNPnY2Zdj/nn79abq3+176ecPPffuWsR3K+bQeHNFYiAVnifoe9ByIimnS/IkqTtjVSKBEzz1XAiyWCvbG1UwmExpQ0t+qw0WTHTt20IQJE4z/hgwZEjrmcjdwmN0j7d27l95++22aMmWKtHgSSji5YMHZmbbb7zGSJLPt2bNHuq2KYzJ9ow0IgEA6CUA4SWfeUxk1/6sJF00qKszwDx0iOvJIInbzGGYTiRv8r9pzps6hc6edm9dNV18XPfX6U7Tuy+s8uxfZDuN3qo+NaCzEwrQEfQ9zDkTBNGn+RBEjbEZAoATPPU8KLJYK9h2YBuFk165d7G8ko2n8+PERDIryNvnWW2+xW6R9NHnyZKlAVfQJrnuMGTPGsHvWefVUAeFEijEagQAIFJEAhJMiwkfX8RPgogn/Cxsv1eXTdLh4EmKTETaOWXcMdV/aTZ8a9am8nnZ/sJs+e89n6Y3GNyCchMhB4EM1j4XAfgQ5sMR8D3MOBMEjOiZp/oj8xf4EESixc8+PXFqm6vT19VFNTQ2bpZudppug4ZR0V/i0ppdffln67bsQTpKeUfgHAiAQigCEk1D4cHApEeDTc/iNE1/bhP87fLgpoITYZISTY9cdS89f+jwdM+oYCCchWGs9NIKxoNU/P2Ml6HuYcyAKrknzJ4oYYTMCAiV47nlSYLFUsO/BNFSccOFk5syZEQyIdJh86aWXqLq6WipYCCdSmNAIBECgVAlAOCnVzMFvZQKf+ATR/v2mYMKrTriAwuesf/SRsinrABnhpPGRRjp18qk078R5ef109HbQc288R2vPWOvbv0wfgQNI64ERjIXYUJag72HPAd1sk+aP7vhgLyICJXjueZJgsVSw70AIJxGNlTIyC+GkjJKJUEAABMIRgHASjh+OLiECY8eai8Py//g2YoS5xsmbbwYOQlbUOKf9HLqg7gI6ZdIpRl9P7nySNvRsoAcXPyjsW7YPoSE0GCQQwViIDW+J+h7mHIiCbdL8iSJG2NRMoETPPVcKLJaKP/0JwonmIVKO5mITTq655prMtddeK73gKxaHLcfhhphAINkEIJwkOz/wTjMBza+SVBE1mv6jyXgdMd8aZjYIK02syFX60EyrvM1pHguxwipR34OeA1GxTZo/UcUJuxoJlOi550YgTWucxDZVp6eVZs1qIVq1lbaurDWx88/OJ9qwgeh8tq9nwUYa2Lggl5JNiytpcd8q2mrtN/YsoI1ba6mVt89LHvt8YCPbG98Wm3AS9eKw8SFDTyAAAuVM4LjjjnMNT3au4nA+9SEBm66bgASEAhdKgEBcgkZc/ZQAcrgIAiAAAiCgiYCue6akv4441jVODJGkh6qpj2o3bCVDO7ELJ677NhlCyYatK6nWauv8WVPOg5gpC+EkSOA4BgRAAARUCEA4UaGFtmkjEJegEVc/acsf4gUBEACBNBOAcBJB9i3hY2UPzepcaFaW5AknRCsXbKJW2mBUpPBqk87aVdTHtJPUCyennXF2Zv1990QyVSeCVMMkCIAACOQRgHCCAQEC3gTiFDTi7As5BwEQAAEQKH8CEE4iyLGtYqSPiyILB2hjtW2qDp+ys7WGWis7aSGfimNN4TE+d6k4SdNUHQgnEQxImAQBEIiNAIST2FCjoxIkEKeYEWdfJZgKuAwCIAACIKBIAMKJIjCZ5m5TbfjaJQ6BhIsqi1mVyYKNNmEl7VN1IJzIjDC0AQEQSCoBCCdJzQz8KjaBuIWMuPsrNl/0DwIgAAIgEC0BCCcR8LULJ8x8T+ssNi1ngTkVxxJQLIFkVg+t5Au9eq1r4rAVgbdSJmNb4wTCiVQ+0AgEQCChBCCcJDQxcKvoBOIWMuLur+iA4QAIgAAIgECkBCCcRIC3QOzYRIsrF9Mmto6J8dYca0qOvWsIJ3TWefVUAeEkggEJkyAAArERgHASG2p0VGIE4hYy4u6vxNIBd0EABEAABBQJQDhRBCbT3K1KZNNiqmytFQsnbq8jdhNaZPzQ2AYVJxphwhQIgED5EohVOOlpoRkzVufeV1+7ehttW8Xf4za4dS6qoEW9q2nbtlWUv8dso+smoHwzish0ESiGkFGMPnXxgh0QAAEQAIFkEdB1z4TXEScrr7q9gXCimyjsgQAIlCWBWIWTzkW0iDqoYyFH2UmLKlqodts2srQTLpq0ENvZW0sbIZyU5XgrpaCKIWIUo89Sygl8BQEQAAEQkCcA4USeVZpbxiacXHPh4sy1a27F64jTPNoQOwiUMIFYhZM8Tj3UMmMxMYXEEE56WmbQYtpI2xZsIvNjVJyU8LAqedeLJWAUq9+STxgCAAEQAAEQKCCQFuFk+/btdMIJJ1BlZSVGgSKBgYEB6u3tperqaqkjZZ8buLE9e/bQmDFjDLult8ZJbxvVLSFa391MNVJo0AgEQKDcCcheAIcPH64XBZ+2kxVImIJiiiamgiIUTjo6OnK+LFxolK9gAwGtBIolYBSrX63wYAwEQAAEQCARBNIinOzcuZNGjRpFEydOTAT3UnKCixv79u2jSZMmSbkt+9yQPOGECyF1a6g3F2Y9tfe3U71X2BBOpAYEGoFAmgjIXgD/P3tvHCNXdef5/joEk5mFdlbbbwd7M8pMNIHQ3eHJf4CERkgsCokd4XnBptvgzCQ4szsEa7HBCPBTbKobnBlYYs/uzkTsCNiF3RhwFc7y3kN6Iv/sSkgICaGWmOq2eIo0ExFbM5vekXacnQkwTr17blV136q6Vffce8+995xzP2WF2F3nnvP7fX6/W33Pt37nHLPCSXSZjqo8mZel1SHqc/H7nJh6CKhTjPE1PYGqBIyqxk1PiCsgAAEIQMB2AqaemWzf4+Tjjz+Wv/iLv5B/+k//qfzjf/yPqTzRSExVaaJEk//xP/6H/OZv/qZcfvnlGleJ6M4bYoWT/bu/2nn63z9bzVKdYSHk7H654sSsrIyrKEE40UoIGkGgTgR0PwDNCSeje5sM8NaoOOl0OnUKEb5WQKBKAaPKsStAzZAQgAAEIFAQgboIJwqfEk9+/OMfy89+9jPhOTE5oT75yU/Kpz/9abnmmmu0RRPVq+68IVY4eeCBf9F5+OFlO4QTOSv7rzgre1XVyUA1Sq8SJSqcDLw/K8dXVuRYsH5n7cQO2fFEr4Zl9vh4ESY5HrSAAAQcIKD7AWhEOAlP1WnJQmRD2BFECCcOZI3fJlYtXFQ9vt/RxTsIQAAC9SFQJ+GkPlGt1lPdeUOscHLfAwc7xx7+TiHCiTJs0uvXL744sGdJKHqc3RuIHdfJiSv2S7BuR14K1u2EP187Jh8eO9drr97vCSxqgL6gclrk6zvW5Fhvuc/Z/aqPzaU/SfZUG0ZGhwAEJn5e/Pqvx76t+wFoQjhRG8DOD63JGTmSGOGERK6YQNXCRdXjV4yf4SEAAQhAwBABhBNDIOlmg4DuvCFWOHng4Dc6D3/njwoTTn59zGQntH54j5N+hcjwkpywXSCIrMzKCbU5bCiQRPdGUZ2pqpS9cjYQXAJJZfJeKSQPBCDgFIFJH3K6H4AmhBMT0Ew9BJiwhT78JFC1cFH1+H5GFa8gAAEI1I+AqWcm2/c4qV9kq/NYd94QK5x89bavdp59oZg9ThING7dniY5wMvF0HbXkBwGlupRkZAiYJYBwYpYnvflNoGrhourx/Y4u3kEAAhCoDwGEk/rEuixPE/WJiCGlHkecaNjYzV67wsfkpTqb72/4F/S3/4d75CW12UlwVs+J7tnF4d4nvCAAAXcJIJy4GzssL5eALaKFLXaUS5/RIAABCEAgL4FWq7XRxeLiopGNUqk4yRsVf65P1CfcE06U7hE9qjhpc9igfbjMp7s3ytmew7PHV2QF1cSfTMeT2hJAOKlt6HE8JQFbBAtb7EiJj+YQgAAEIGARASpOLAqGJ6a4K5x4EgDcgAAEiiWAcFIsX3r3h4AtgoUtdvgTWTyBAAQgUD8CCCf1i3nRHiOcFE2Y/iEAgUoJIJxUip/BHSKQV7B48I0H5ZX2KzIV/Llr/i459ZVTmbzPa0emQbkIAgYImLoHDJgSdmGbPab8oh8I6BBAONGhRJs0BBBO0tCiLQQg4BwBhBPnQobBFRDIK1bs/MFOOXjjQblx+43SCf68/cHb8vzK8/L6/tczeZPXnkyDchEEchAwfQ/kMCW81DZ78vrD9RBISwDhJC0x2icRQDhJIsT7EICA0wQQTpwOH8aXRCCPUKG+1b71c7fK7s/vHrD27Lmz8tYHb8nJL59M7UUee1IPxgUQyEmgiHsgj0m22ZPHF66FQFYCCCea5MYeuKJ5fZ5mVY6dwW6EkwzQuAQCEHCHAMKJO7HC0uoI5BEqtp3cJiv3rsjVV1494MCFixfkhmdvkPNHzqd2LI89qQfjAgjkJFDEPZDHJNvsyeML10IgK4E6CCc7rrhC1va+JB++tHcD09n9V8j+c+rgk2OidThsGvFi4ACW7pB7X/pQwuHT9NO3Nss1WRPCwHW5hJMHDn6j8/B3/khmZma0TFHnGeu2TWOY1uA0ggAEakkA4aSWYcfpFATyihTbT26Xd+99V7ZduQ3hJAV3mvpDoIh7IA8d2+zJ4wvXQiArgVoIJzv2y3VyTmZPr0h4GGwoRKgzYvfK6aKEk6/LZt89IeW6vniSNlh1Ek5uue2rndMvPKsthiCcpM0m2kMAAnkJIJzkJcj1vhPIK5wceeOI3PzZm+WOL9wxgKq51pR3zr8jT9/2dCaEee3KNCgXQSADgaLugQymhJfYZk9WP7gOAnkI1EM4OSHH9p6VE3JaVgLlRFWbnJ09LsFK2a64MVAhslde+vClQFLpCSw7npC1PuDgmrBCZaD9rBxf6Qky/XZxQkf/Z6dFvt4TVeTEDtnxRK931Xf43log8pyVs70fh5Uq1ymhp2vrwDVBrUx37LXgxztk7VivqiW4fv8VJ2R22K48iZLi2jSFHUr3mJ6eDnvf9Tt7ZQrhJAVpmkIAApUQQDipBDuDOkTAhEBx+0u3y4EdB+Smz9wUev7mT96Ul1dfltf2vZaZhAm7Mg/OhRBISaCIeyClCQPNbbMnjy9cC4EsBOoinJxeuU5OXHFW9q7MygklQmwIGOrn+yVQS8KlNGtKzFg7FizrkUB82Pz55hKbXj9RcSVaXdIXXIZ/FooZQ+PvWJNjvX7O7g/GCkSdEztUm54Qc3a/hCb0bR6ujlHvn93bXYI07u9ZkiLnNbmEk/u+fkfn2L/+UypOcgaByyEAgeIIIJwUx5ae/SBgSqB46EcPhccRq9f+L+7PXGnSp2rKLj+ihBcuEDB9D+T12TZ78vrD9RBIQ6A+wskxOaf2NQmqTAaqOCIVIOFeJ2E1SSBoDIsV0YqRaBVKCDtSpaIrnIRCzv5AThmqcBkQXHqVI6/ulbOPxVXHBIP1q2D6wkxX8ZGze/vVJ2mywUzbXMLJgQcOdk48/B2EEzOxoBcIQKAAAggnBUClS28I2CxO2GybNwmAI8YJqLxVr58eeNJ433QIAQjoE6iTcNJdYtOr8ohZOqMtnIxUkwzx1lyq092UVokjPQFlpLJkSDhRIk+0ImVonHAJUrAJrlKH9vYrYvRTwVjLXMLJnm890PmTJx5GODEWDjqCAARME0A4MU2U/nwiYLs4Ybt9PuUCvuQnEM1Xcjc/T3qAQB4CtRJOoqA2RIdJS3U29wkJl/AEy2JWepUi/aU9sexHhJOuOBJe09+vJBBBTvxwj7zU3a02WKITqDGPRypLQk0lWIpzYra390l0eVH3JKBNm3onA/X2Xgk2Pgn3cqnqlUs4uS+oODlGxUlVsWNcCEBAgwDCiQYkmtSWgO2TO9vtq23i4PgIgbhcJX9JFAhURwDhZMLmsOEeI+r0nWBFzN5gH5FzszGbyao3h441HjmOOLKB7JBg0+1ddRGIHXt+GFTERDaj7S/jiQgx/eVGIzaFvfQEmP7pQRWlVS7h5MCdX+2c+LfVnqrz1KlnKkLHsBCAQNUEHj1yX6IJCCeJiGhQUwIuTOpcsLGm6YPbQwTG5So5TKpAoBoCdRBOqiGbYdS8xw73K1R0j1jOYKLOJbmEExtO1VHCyfGjh3V8HWlz4cIF2b59e6ZrfbkIBiIwcJPBE0/+W0E48eWTCD+qIODChM4FG6uIHWPaRWBSnpLDdsUKa+pDAOHEoljnFE66e5xUtylsnyTCCcIJ4hECmpPiEcKJRb8QMcVJAq5M6Fyx08kkwGgjBJJyNOl9I0bQCQQgMEAA4YSEME0A4QThBOEE4QThJOGTdcuWLfk/e1eXZX5+SVZ7Pc0ttaXdmBMZ9/OYEU09BOR3hh5cJ+DSRM4lW13PC+xPT0AnP3XapB+ZKyAAgUkETD0zffTRR4mgs06oxz1fpukv0TgaGCOQJi7r6+syPT0djr3rd/bKFEt1jMWhso5YpuLmMhXTCeNiHjhXcdJalEVpSnNBRa8li1PLMtduS2NtzM8DTWX4ZeohwHT+0J97BFyayLlkq3uZgMV5Cejmp267vPZwPQQg0CVg6pkJ4YSM6hNAOKHihIoTKk6oOEn4nWCk4mRgjFVZnt8nciYQTgYEknE/N/sQwK9ACLg0iXPJVjKrfgR081O3Xf0I4jEEiiGAcFIM1zr3inCCcIJwgnCCcFK2cKKW54S6SUMGdZMxP+/Zpx4Cms3mhrULC2H5Ci8IpCLg4gTORZtTBYXGThJIk5dp2joJA6MhYBkBhBPLAuKBOQgnCCcIJwgnCCelCieRZToDqsm4n28aZ+ohwIPfXbiQg4CLEzgXbc4RIi51hEDavEzb3hEMmAkBKwmYemZiqY6V4a3EqFzCyQMPPNB5+OGHZWZmRst4tUmKbltdw4o5jlhNYBaDXQg2XxsbOWp56k4jvb0tKuYRbp7ZkgW1H0TMvg95aesx0Bgl2MNiarGfNQvS7DRFvx5g0qQ5eUKtYd3EJsYY5DUkxfXO7XES+pZdNFFXm3oISIGZph4ScHHy5qLNHqYOLkUIZMnJLNfkha7GVK+fHngyb1dcDwGnCJh6ZrJZOLl48aL89V//tVy6dMmp2Nhk7GWXXSa/9mu/JldddVWiWbr6hOpoZHPYAw8c7Jx4+DvaYohbwklv48YCJuqJUSmxgd6EeXiy1xNSFprS6e506fRLj0GCi6G4syqNvlgS/Ht5rSGNBV3RA+EkbRI5J5yMEwBTCIOmHgLSsqa9PwSqmLiZouey7aYY0I89BLLkY5Zr8ngcHa/ssfPYzbUQMEHA1DOTzcLJj3/8Y/mN3/gN+dSnPmUCWS37+MUvfiF/+Zd/Kb/1W7+V6H8u4eSBb+3rPPzEKYSTRMz2NtATDWIm9cNCgb0uJlqmxyChG1Vtsjwn7eE9KyTMGIkAACAASURBVMZWGAz3h3CSGKihBq4JJ6vL8zK/1D+MuOuMqmQ7I/tifx4eVTz0MvUQkJY17f0h4PLkyWXb/ckgPOkTyJqPWa9LSz5unLLGTmsr7SFQBAFTz0w2Cyfvv/++zM15/i1/Eckx1Ofq6qpce+21iSPlEk7u3v3Vzvf+/bM1Ek66k1u1/qLVmu0uxQgFhCXpTociyzMiP59bWpLZpVb36NG5uOqNSHVLbH+9a5ZmZSnopz/h2pxYqZM45qU/J1totmUumKStNjq9o0+DK8ZM7PVEg7hJfXfM/hitxSnZXKXSr0TpXRdUpbQWu4wWmp3g+NXNCeTmEqjRtiPvRfmNYzGW+/h7QY9B0r3UrcJZCybCm3EZWuLUq9DRZRXvf2DHuJxLMnHC+2YY5DAgw6WuCScZXEQ4MQGNPjYIuD5pct1+UtEfAnlyMc+1ugQnjVHG+Lp20g4CRRJAOCmSrl99lyKc3HLbVzunX/BVOBnc40RN+Jvhsovo5HhIUAjEiflgeUa7sRa2C5SVULjoftMsspQonEzur9VfGhPupaG6V3todAWM1kJ0wt4TSloLG0tp1GS9tRARUnr5rjdhThZONm+faNuecDC31K3E6O0BsiEIDPgx1HZg+UJMn7Esun3Ecy9aOFH9bwpY3XxRP9OtJEnjf0Ro28i5fGqzXh7Y9SGJcGJXPLDGfgKuT5hct9/+DMFCXQJ5cjHPtSbsK2N8XTtpB4EiCSCcFEnXr74RTjTiOX6yqLmB48A3/70B1YQ+EE4GjxodnvhH90+JvCfR6pVIf8Hpo6rSpVuxMjQZD6+J7K2x4bfqN9hQNRRXgr/Pr0ljZBmJaJ6mMk44Cc9T7do0sDHqnIZINCwqjI6xKfak4DdwxKve/iLGRYNeXsxuiG1D++VosVJI+2KXTo7k22vGOAON+y9vE4STvAS5vm4EfJgw+eBD3fLOR3/z5mHe6ycx1elbp42PccOnehFAOKlXvPN4i3CiQc+McBIjWqiJ89gJ/ISlOhNFkLTCSbfSZV+wg4LaQ0H9f9yeCXoT5oQ9Tgb2O1FVF31BJWFZ0kA1xnDb6FIgx4STIPfCKqPVRlDxMyR6abMa4//YHNFI+AlN9PIg3ximr0Y4MU2U/nwm4MtEyRc/fM61OviWNw/zXo9wUocsw8e8BBBO8hKsz/UIJxqxzi2chBP/4X0t+pUU45aMDO4N0q3UWItUaIzrb4xwMjdmqY4yIxRwVmVW1mSuXxkyxEVvwhwngGz6N7B/ytglNn0u4/wYYjkgMGgKJ+H+MRUt1WkFp+jMBqfohBVB0ZioZVuDS2s2NpEdYRWJ/UT/43JEI+ERTkYI6G7ytGXLlnyADV1t6iHAkDl04xCBIidqZWLwxY8ymTGWWQImctBEH3Fepek3TVuzBOkNAuUQMPXM5MzmsKuPy/XXB3txNt6T9x7rLeFXP7tb5OX3HpN8i/rLiVlVoyCcaJDPL5z0xImNzWGDfw/svdHfyDW6OWzQJrpUY2FBFlqBsNFfhjO8/Cfsb8JSnY2lO5t7smzur9Fd7rEo448N1hdOonu+9Jfi9CFHNqedC/zZEGrSV5x0N97tbbUbu09IQp8RtoOb8o5PCD0GSQnV26Ok3yxyVPPGZrDhz2Y3N/KNYZXs/4ScSzIR4QThJEeOcKm7BHybIPnmj7uZVU/LTeWfqX6iUUjTZ5q29Yw0XrtOoJbCyd2rcp2ck7mX35NQO6mhcPLxxx/L+fPnw2Oa417q6OF/9s/+mVx++eUbbyOcaNztZibMGgNpH0mr01e6NuM2he33Uh6DJLv19iNJ6mXgfc0jk+1hkMo7o41dZMBSHaMpQGceEyhrgvTN/+ub8l/W/ouoh9U7vnCHvPC1FwqhWpY/hRhPp84TmJR/ae4B03kc198ke0yP73xgccA7AvUUToLqksdW5frggJBLZ+4cFE56FSndr6fvlDOXzsidPWHlzuuCyvlXuylw55lLoi4NRZeggqXbfi4oZOmJMZZniqoQevTRR+Ub3/iG7NixY8DalZUV+U//6T/Jk08+KVdcccXGewgnGkEtb7JYgCig4V93qY7avzU40WZM+/IYJBlsnlFY6bHWO9FnwvD2MEhiVNz7LjJAOCkuH+jZLwJlTJBmvz8r7//N+/LLX/4yhPeJqU/IdTPXSftg2zjMMvwxbjQdekFgUu6lvQdM5/Fwfzr2mLbBiyDjhDcEaiucBMtyzu27LDhNNRBArusv1ZmVxy9Tk8KuKLL6+PVy/epjcumxtVAcua4vlry6Ty57fE7ee0+1Dw4ZUeKKygjHKlf+1//6X3Ls2LEB8aQvmpw4cUL+0T/6RwN5jnCicduXN1k0LwpMdq+/dGZ4Sc3oVeUxSAqICUaRJUPhcAu9I5snj20PgyRGxb3vIgOEk+LygZ79IVDGxOibr31TfvDnP9gQTfr0PvGJT8g3rv+G/Mf/4z8aB1qGX8aNpkPnCYzLu6z3gKk8Hu5H1x5T4zsfWBzwkkCdhZO5vtDxssjdao+T/v/39zoJq0lW5bH35uTx6B4o0es2qk366dGrUnEkW6LiiTJZVZrEiSahLrS6Ktdee22iZ7p7I6qO1tfXZXp6Ouxz1+/slalbbvtq5/QLz8rMzEziQP0OdNvqGvbUqWfk+NHDWuMPN3JxspjJ0QkXwUD3SGbT5O3qz8U8QDixK4ewxk4CZUyMpv9oWi5+dDEWwPQV0/I/j/5P43DK8Mu40XToPIFxeZf1HjCVx8P96NpjanznA4sDXhKotXCixICgquTxoF7kXLAEJ5Nw4sGmsn3xRCX4ONEE4UTz9ndxsqjpmnYzGCCcqGRxMQ8QTrRvcxrWlEBZk6KtT26Vv/3wbxFOappndXF70v2U5x7Ie5/GXZ/Gnrzj1yX++OkGgVarezCHei0uLkqn05lsePTAjo2WgxXrTp2qMyB2vCr7guU5r841ektvxizVias4CZfqbLZ3I/rxVv7iF78I3/jUpz411g0qTjQi7OJkUcOtVE1g4KZokCrIGo1dzAOEE43A0qTWBMqaEN3z2j3yn9/7z/LLTnd/k/5LLdX55v/+TfkPv/MfColDWf4VYjydOkdgUr7luQfy5nHc9WnsyTu+c4HE4NoQSK440dsmwF3hJAj1xp4lwXHEEzaH3TiuOLqXyUD7oK9QgPHzWONShJMHvrWv8/ATp1iq4/BHkIsTZtO4YeCmeIRwYvpOoD+fCJQ9GZp/Zl7OrZ/b3Bw2EE3m/rdgg7lvv1cY1rJ9LMwROnaCQFK+Zb0HkvpNgjPuel178o6fZB/vQ6AqAnrCSbABaqcZ7Io4/uWMcFIVaA/GLUU4OfDAwc6Jh7+DcOJwwrz//vtam+E47GKi6TAQcZEBwkliatOgxgSqmAwd+L8PyA/XfhhS3zu7t7BKk35Yq/CxxilVe9d18i3rPaDTd1wAkq7TtSepn9oHHwBOEkgWToJ9QJbnZXm2Lc0JygnCiZPhT2V0KcLJA/d9o/PwsT9COEkVGrsauzhhNk0QBggnSTm1ZcuWpCalvK/zEFCKIQxiPYG6TITq4qf1Cee5gUXnWdb+s143HC5T/XieBrjnGIHkZya1VGdRNndF6Tvo6B4njsXHJnNLEU44VcemkGezBdHATdEgW7THX+ViHlBxYjoL6M8XAnWaBNXJV1/y00U/ysiztGOkbT+Ju8m+XIwvNvtJIFk40fPb5oqTH//4x/Ibv/EbEzc+1fOyvq3U5rF/+Zd/Kb/1W7+VCEH31F/V0chxxFScJPK1voGLE2bTUGHgpniEcGL6TqA/XwjUaRJUJ199yU8X/Sgjz9KOkbZ9EnfT/SWNx/sQKJqAnnAyXHUyJ0vttjTmNq2zWTi5ePGinDt3Tj788MOicXrb/xVXXCHXXXedXHXVVYk+5hJODjzwQLDHycMs1UnEbG8DRAM3RQPTGeViHiCcmM4C+vOBQB0nP3X02YdcdcWHMvNLdyzddmkYF9FnmvFpCwHTBJKFk1VZnp+X1UZnc4+T1WWZn1+VRmTDWJuFE9PM6G8ygVzCybcP39c5/sgxhBOHs8zFCbNp3DBwUzxCODF9J9CfDwTqOPmpo88+5KorPpSZX7pj6bZLw7iIPtOMT1sImCaQLJyoapPhU3WUmLJP5Mxm1QnCienIuNtfLuHkwJ1f7Zz4t88inLgbfydPUzGNG+EE4SQpp9gcNokQ79tAoK4Tn7r6bUPO1cGGsvMrabyk9/PEpMi+89jFtRDIQiBZOKHiJAvXOl+TSzhhc1j3UwfRwE3RwHTmuZgHzlWchOWfS7LaC97cUlva4SLa6PrawZ3ch+Oc/BBgOjPozyUCdZ701Nl3l3LUNVuryqtx4xZtT9H9uxZ/7HWbgN4z0/AeJ6PPYVScuJ0HJq1HONm+3SRP5/pyccJsGjIM3BSPnBNOWouyKM3eOlr1i3pZ5oINyGaXp6S10F1fu7o8L/OrDemof8S89B4CTN8h9OcCgbpPeOruvws56qKNVebV8Nhl2FLGGC7mATa7ScDUMxPCiZvxL8JqhBOEE7n22muLyC1n+kQ4QThJSlbzS3X6a2gbsjofWV+rqlLCpbUNiWzovmGeqYeAJH953z0CTHhEYOBe3tpucdU5pcbvv3564MlScFXtcylOMkgtCIx/ZurvbbIgranFoO53+DVYdYJwUot00XIS4WSMcBJ+89takPbIBKa7Hm6pV2+/0IzsxNxDPv5arZiU2ihONGgtTsli71NkcznBplmhf30AGz+OfMgE36wHn0PSjOxIHb0mykyN1f+2vVTHI4NNEk5CFkGVwGAFwGa1QGMu+veqPMg/rovikXMVJ9EwbQgks7I8sDFZ3EZlmxeqh4C4V6fTyZ8E9OAsASY63dDBwdkUttLwuuZTXf22MgkxKhcBU182IZzkCoNXF/stnMRM4KPRu3DhgmyPFU56693mlmKEk5a0AkFlQVXSxxxZtbFfQey19uXOyIQ58Gl5rSGNcKWAniigRJF9cibYr0G6otJswCcQXhY2hJOgn/k1aYQiVOTvit/yrLTHLEsoi9ZY0SCc3K7KrKzJXGR37UEueozK8iXrOAgnk8mZrTgZFt6iO7onCyeIJFmz3M/rmORsxhUWfuZ4VV7VNZ/q6ndVeca4xRFIFk7GnaqzLLPtpvQXTSOcFBcj13r2VDjpVYWMTOAHwzNOOFFCwHJwu6wFk/9xJfPdnkZvOP1r7UiVyRPm0SO5Rq2O+9AZ/lmccHKnvDo/+MFUFZFxDPqC0JlAFuoKQ/3FE1ScVBWr6LhuVpwMC21D9wpLdWxILadsYJIzGC54OJW+Vhtb11yqq99WJyPGZSKQXTjhOOJMwGtwkafCST9yk7+9jRVO+lUQjbWJew10dZNgSUpQfbKxjCPNtZYk12ThZDK/PoP5oEJlU1QYLyj1l/eopTqNtUCcmm33NsqsFkY8g4hoFMhog/tOIJxUG7Hu6M4JJ2GFWlBdEmwIu6HBhR8jbA5rQz65aAMTnNGowcTFTLbP5rrnUd39ty8jsSgLgfHCyeC2CyN9Lwwu0afiJAt9P6/JJZzccdtXO3/6wrMyMzOjRWd9fV27ra5hT516Ro4fPTxm/LTCyaTJ8uYQG/t1DNxYetdqgSqxUdL+Hstz/SNT44waV5GSJLhEK1BKdHbMULEMBr75H/YT4aT6qFUtnCTl+CihuL2BunsIrQUn7PQ3J+M4YhtyyxUbmNwgnLiSq67ZWfd7q+7+u5av2BtPILniRI8cwokepzq00tUnFAule0xPT4dYdv3OXpk6fN/vdR459qS2GGK7cLK5V0ewJCOhZD6kEO6hsiZLwTfId77a3+dD81pLsmt8tcV8sGnrJNEkcGDsHiWTJ5WtxXlZa3SZRatQqtrqJI7BQC6ErkaPiUU4sSF9q644CZfllVw1ZeohwIb4YUM+AkxsxvODTb7c4mo2GuYe4i7wgUDyM1O38mS1ETnoQ83tlucG9rhEOPEhG8z4kEs4OXD4vs6JR455Ipz0NoQd5pqwyWu3zL4pshhznJUDG8SOigY6+5p0IY2fOE4QTjbElgBZ3IaxZvI6VS+jDMbkQrDvTfekIISTVIALalytcJKUI8U4nfwQUMy49GofASY2CCf2ZaUfFnFvdeMIBz/yuc5eJD8zjdsclj1O6pw3k3zPJZwcDoSTR7wRToYwDVScRCbKwY6xreBIne5Oy2NOVNGpVrEkI0dEg+F9WzbsHPZ1ksAyTjhR1/Q3hI3bMFadulP+K5bBkNocyEQRVRrhpPwojY5YrXBSDYHkh4Bq7GLUcgkwoUnmDaNkRrSIJ0DuIJxwb/hBIPmZKabiJObEVCpO/MgHE17kEk78qjjRFE7URqHzS8E0uvtSG52OLDFxWDiZvA/DssxtbGw5aTlO/Huxy1+WuiRjOZrIcI0+hoUTVUUUt7fL5nKdoFpmqs9ijHimMa5NTTiOeHI0Yo8jDn+5qs+CuXC5XmNttLzTdIyTHwJMj0h/thFgUqcXETjpcaLVKAFyB+GE+8IPAnrPTMMVxL1nusg3uQgnfuSDCS9yCSffPvz7neOPPO7JUh0TON3rw8UJs2nKMBBxkUG1FSebFVezwV4nas+expz+MresOaz3EJC1d65zgQCTOv0owUqfFS0RC+JygHuIO8NlAqaemRBOXM4Cs7bnE06+fkfn+L/+U4uFk8mwYo8jNsvX+t5cnDCbhgoDhJOknBqtONmsqgo260E4SQLI+0YIMIlJhxFe6XjRmn09hnOAe4i7wmUCWsJJeNBHa8jNwRMOEU5czgKztucSTm4JjiM+bfVxxAgnSemCaOCmaJAU17Tvu5gH1VacqEO11MbQHVlo9YQTluqkTTvapyRg+yTmwTcelFfar8hU8Oeu+bvk1FdOpfTQbHPbeZn1lt5MEMibM7bdA3ntycvDREzoAwJZCSQLJ3rL7RFOskbAv+sQTrZv9y+qKTxyccKcwj2tpjBwUzyqWjjpbxjc26YnyLXBbyi0ki9lo+SHgJQd0twZArZPYHb+YKccvPGg3Lj9RukEf97+4G15fuV5eX3/65Uytp1bpXAYfIBA3lyx7R4wZU9eLqQZBKoikPzMNGm/xk2rEU6qiqB94yKcIJzItddea19mlmgRwgnCSVK6xW4Om3RRAe8nPwQUMChdVk7A9omL+lb71s/dKrs/v3uA1dlzZ+WtD96Sk18+WRlD29lVBoaBRwjkyRXb7gGT9uThQppBoEoCOs9M6uCH5dn26EEfEcMRTqqMol1jI5wgnCCcvP8+DBxkUH7FyfDO63Ef5sVWneg8BNj1KwZrTBCwfeKy7eQ2Wbl3Ra6+8uoBdy9cvCA3PHuDnD9y3gSGzH3Yzi+zY1xolECePLHtHjBpTx4uRgNEZxBISSD5mWnccx17nKREXZvmCCcIJ4gGDooGpj+hXKy6KV84iVJXJ+gsy2y7GSzQ6b3U8cTLs9IeOZ/cXLSSHwLMjUVPdhBwYdKy/eR2effed2XbldsQTuxIG6xISSDvfWbbPWDanrx8UoaD5hAwQsDUMxMVJ0bC4UUnCCcIJwgnCCccR5zwcT7pVJ0N4UQ4jtiL34oWOeHKZOXIG0fk5s/eLHd84Y4Bes21prxz/h15+ranK6fqCsvKQdXUgLz5Yds9YNqevHxqmla4XTGBZOGEipOKQ+Tc8AgnCCcIJwgnCCephRMlkswHp+q0pd2Y616tKk7mV6XRiVShGP6VkPwQYHhAuquMgGsTldtful0O7DggN33mppDZmz95U15efVle2/daZQyjA7vG0wpoNTLCRH7Ydg+YtMcEnxqlE65aQiDTM1NM9TAVJ5YE1AIzEE4QThBOEE4QTlILJ6FSEoonm6fqzMlSuy19HaWIz/dMDwFFGEKfhRNwcaLy0I8eCo8jVq/9X9xvRaUJ4knhqer8ACbvNdvuAZP2mOTkfNLggBMEsj0zjVYPI5w4Ee5SjMwlnNy9+6ud7/37Z2VmZkbL2PX1de22uoY9deoZOX70sNb4w40uXLggFy9ezHQtF0HANwKuna5U7R4n1UQ/20NANbYyanYCTFCys5t0JVyL4ep6r+SFXgThpMeJVvYQyPbMNHpEMcKJPTGt2hJdfULZqXSP6enp0ORdv7NXpr59+Pc7xx95XFsMsVE42U7FCRUnVJxQcZLwSay3x0nxH+fZHgKKt4sRzBFgcmKOZVxP8C2Wr2u9kw/6EYOVPita2kEg+Zkpfo+TuaXIMuzAFYQTO+JpgxW5hJPDhw93HnnkEYQTGyKZ0QYXT1PJ6OrYy2AgCCephRO1pcm8LM+2pcBDdEasSn4IMH130F+ZBJiYFE8bxsUzdmkE8iFdtOCVjhetqyVg6pkJ4aTaONo0ei7h5O5vHe587wmEE5sCmtYWRAM3RYO0cU5q72IeVLtUR28n9iTuad839RCQdlzal0OASQmcyyHAKH0C3HPpcgFe6XjRulwCy8vLAwMuLS1Jp9OJMSK6HCf5RESEk3LjaPNouYSTOwLh5E8RTmyOb6JtLk6YE51K2QAGbopH1QonKZPMUHOEE0MgLeyGCUl5QYF1eaxtHok8SB8dmKVnxhXVERj/zIRwUl1U3B45l3By931BxckxKk5cTgFEAzdFA9M552IeVCqctBZlarE1EIaFZqfwZTsIJ6Yz347+mIyUHweYl8/cthHJgWwRgVs2blxVPgGEk/KZ+z5iLuHkcLA57CNsDut0jrg4YTYNHAZuikdVCSdqb5P5pVlpdpqysJGM3aOJWwuDG4rF52rwTcf8mjTaDZlTDVaXZX5+KTjcWL0mH2mMcGL67q++PyYh1cQA7tVwt2VU4p89ErDLzo4ryyWAcFIu7zqMllU42bl7j0zdffuuzvf+7Dk2h3U4UxAN3BQNTKeci3lQjXAyaS3s6BF2w3Hqii6BRDK3JO1QOBnqT1WyLM/13huNMsKJ6cyvtj8mIPCvlkB9R+feyx572GVnx5XlEpgsnCzKYN1w1LaFgS/H2OOk3LjZPFou4eSWL+3qnH4R4cTmACfZ5uKEOcmntO/DwE3xqBrhZJI4krzBWJibqsJkn8iZOOFk4D2Ek7T3skvtmXxUHy1iUH0MqrKA2OcjD798/Li6HAKmvmxCOCknXi6MgnCyfbsLcSrMRkQDN0UD0wnhYh5UI5zkqzgZFU7UT6In9CQv1Wk2mxvhX1jYXCxkOifor1gCTDyK5avbO3HQJeVPO2KeP5YwzM+QHoongHBSPOO6jYBwgnAi1157bd3yfsBfF0UD0wFzkUE1wokqGMm5x8lQVUlrcSrYG0VtLNvdJ2VptimdZrwgYuohwHT+0F86Akw60vEqsjWxKJKunX0T8/xxgWF+hvRQPAFTz0xUnBQfK1dGQDgZFk4ip2XMLY1u9LixR8FAhLtr4SSYAPUP2oi71sakiJswq4ncJD8mMehP98I2rYWNvRqi10RPH9mcNFZHZ5JoELKQ4YmsqhBYlrl2Wxpz0b9X50PekRFOJhPcsmXLYIM8p+pEhZORpTmTl/uYegjImy9cn50AE47s7Iq6kpgURda+fom1uZjA0hxLeiqGgKlnJoSTYuLjYq/eCidJk38VrAsXLsj2AeEk/YRYCQL75Iy073xVltca0giVA3cm0yMT5mAil9aPDQaN8IyQnv/BpksbG2BGTxGJ/F1NGpdnpT3m2/WybqixokE4qV2VWVmTuTNKJOlblD5PyvIl6zgIJymFk6yg1XUDYkl3mU6gvHaPMg5P2FmVxsCJPZuDmXoIyGM+12YnwEQjO7siryQuRdK1q29ibS4esDTHkp6KIZD8zJS8qb+yDOGkmPi42Kufwonm5H9EOBlbQj8utONuOM1NIi3ImMkTZh0/RhkoIWU5OKh1LdiuursBZpxwcqe8Or8ss+3oka7VABnHoC8InQmksVAcGxCGqDipJlqbo1a1VCeP38PVWmH11SzHEedh6sq1TDLsjhTxsTs+JqwjxiYoDvYBU/NM6dEcgWThpLv8enm23f3yaswL4cRcTFzvyU/hZCAq4yf/oxUn0bYaKmRQrj8fVJlsTqj7A2tca0nmTBZONPwYZtCvImmsRU4O6e8LERzDGrzUZLGxlvxBVRaieAaRXAhkoM1TUJRVVJyUFZtJ47gonOTlpvMQkHcMrjdPgMmFeaameyRGpona1x8xNh8TmJpnSo/mCCQ/M0U354+Oy3HE5qLgV081EE7GT/5HhZMguGGp/JKoKX50L47RsI8XZNQyoeW50f1RbEydpP09JvsxzGCS2BD1PlqBUj2VWAaTjoxFOKk+aIEFCCdWhAEjEggwsXAnRYiVO7FKaymxTUtMrz1c9TjRqhoCycKJnl1UnOhxqkMr74WTSSJGrqU6sftzdE/FaC24IZqoBB9fbaHhxxCDgb1ORja93LydWovzstZoy52vqtNJNqtQqtrqJI7B8L4t4RKL1UbvtBMqTmz4cCxfOBn3zcT4bylMczL1EGDaLvqLJ8Ckwq3MIF5uxSuNtcQ2Da10bWGbjhetyyOg98w0/Gw3J0vh4Q+bdiKclBcz20fyWDhJFjGGhZORTU7VyRnByTBxR4OOronT2Q/EvnQYFQ30/RhkMGZSubFBbM/3DbElOIRofk0aI3uglM9olEFS6R7CSflRGh2xfOGkeq/1HgKqtxMLRJhMuJkFxM3NuCVZTVyTCGV/H7bZ2XFlsQSSn5m6c8XVRm+DfmVOzCb9CCfFxsml3j0VTvQm/yMVJ0ooWZ7bOEJ3s1plLXL8bHhXBTfaPrXz6aYiOUFksTkhRkSDsX4MnxSUwDi24kRd098QdsxJOxXAimUQyYOuSdEPV4STCsI0MmTVwonOsdymOSU/BJgekf6yEGAikYWaPdcQP3tiYcIS4mmC4vg+4FssX3rPTiD5mSluO4fR+Q3CSfYY+Haln8KJpogRt8fJwGRooRmzNEOlQPxJMv1lJ/0kYDBjsgAAIABJREFUmVuyf8nOsGgQNxns+jEsHiVsHBsjnMQuf7Fwqc645V2by3WCapkpTtWp+sOwWuGkn/8NWeuLgSUcr538EFB1VBifSYT7OUAM3Y9h1APiWXw8YVw8Y0ZITyD5mYmKk/RU632Fl8LJ+Ml/ZMFaEPfYzWFrlg+TT9WpBwwYjNvrxu742yGcNAMVbVGkqY7V1qt0y0M1+SEgT+9cm4eAmjio108PPJmnG6evffCNB+WV9isyFfy5a/4uOfWVU876w0TQ2dANGF52HG27B8qyp2zOfmQnXhRNQO+ZaXh5/uCJOspGKk6KjpQ7/XspnOjiRzhxc8KsG1/ddggnbuZBtcLJpkiiNjlenm1Lc0Hj+G7dpBzTTu8hIOcgXJ6aAJMGkZ0/2CkHbzwoN26/UTrBn7c/eFueX3leXt//emqeNlxATG2IQn4byoyjbfdA2faUyTp/ZtBDHQiYemZCOKlDtuj5mEs4OXz4cOeRRx6RmZkZrdHW19e12+oa9tSpZ+T40cNa4w83Qjhxc8KcKdgTLkI4cTMPqhVOBhNKLe9abI3uxG46V009BJi2q879MVkQUd9q3/q5W2X353cPpMLZc2flrQ/ekpNfPulkihBbJ8O2YXSZ8bPtHqjCnjJ5u52ZWF8WgeRnpnF7nPT3Y+xainBSVsTsH0dXn1CeKN1jeno6dGrn7j0ydcuXdnVOv/icthiCcGJfQiAauCkamM4kF/PAJuHEdDzG9Zf8EFCWJYyjCDBR6ObBtpPbZOXeFbn6yqsHEuPCxQtyw7M3yPkj551NGGLsbOhKvT9tuweqsof7xd37xUfLk5+Z2BzWx7gX6RPCyfbtRfK1vm8XJ8ymocLATfGoGuGk/0t2QVpTi8E20cOv0bWxJvM1+SHA5Gj0NYkAE4RNOttPbpd3731Xtl25DeGE28YKAmXfn7bdA1XZUzZ3K5INI6wlMP6ZqbspbO98ilH7Nw4H6b5FxYm1IS7dMIQThBO59tprS088mwZEOEE4ScrHLVu2JDUp5X2Ek1IwTxyETWBH8Rx544jc/Nmb5Y4v3DHwZnOtKe+cf0eevu3p6gOXwwImgzngVXBpFfGy7R6oyp4q2FeQYgzpCAFTz0wIJ44EvAQzEU4QThBO3n8fBg4yqKbiZPNTOe70LgnO1ml21Ak7xbxMPQQUY53/vTIpGB/j21+6XQ7sOCA3feamsNGbP3lTXl59WV7b95oXiUHs3QljVbGy7R6oyp6q+LuToVhaFgGdZyadZzmEk7IiZv84CCcIJ4gGDooGpj9aXKy6qVY4Kf4EnbgY6zwEmM4N+usSYDKQnAkP/eih8Dhi9dr/xf3OV5pEPSb+yfG3oUXVcbLtHqjCnqpjYEMeYoMdBJKfmfrPcg1Zm+9tCLu6LPPLs9Jubn4FhnBiRzxtsALhBOEE4QThRBBOJn8cxy3VaS3Oy1qjLY258j7Kkx8CyrOlLiOxNKcukU72kwlhMqOqWxCjqiOA0GxHBLBCEUh+Ztr8EkwWF0WaqmJY7X+yT+TM5vMdwgn51CeAcIJwgnCCcIJwkvA7IU440SnvNP2rJvkhwPSI9e6PSVi94z/sPflgdz4QH3viQyzsiUWdLUl+ZtoUSe58dV6WZ9vSXBitKEY4qXMWDfqeSzi5+/Zdne/9mdvHEV+8eJFsgAAEAgKubRLMUh3StkgCPPgXSdfdvskLe2NHbOyKDfGwKx51tCZZOBmk0lqcksXWnCy1B6uJEU7qmD3xPucSTg5/+/c6jxx/UmZmZrSIrq+va7fVNeypU8/I8aOHtcYfbnThwgXZTsWJcxPmTMGecJGLy1RgIFKtcCLCUh3TWWhHfyzNsSMONlvBhNC+6BATYmIfASyqmkBa4WScvQgnVUfSnvF19QllsdI9pqenQ+N37t4jU4cP/37nkUce1xZDEE7sCXzfEkQDN4/iNZ1JLuZBtcKJKuVclNZIIDhVx3Rultkfk68yabs9FrliT/yIhT2xGLaE2NgbmzpYliycqKU687La6ARLdHpEWosytTwn7XZD+lvYIZzUIVv0fMwnnBxY7Dxy4o8RTvRYW9nKxQmzaZAwcFM8qlY4MZ2Fev0lPwTo9UOrQQJUmZARaQkwIUxLrLj2xKI4tnl7JjZ5CXJ9HgLJz0xxJySyOWwe5r5fm0s4ueNLuzp/+qLbe5ywVOd9luqwOSybwyZ80sdtDhss1hmqOhldFxvfbXDd/Jo0It9mBOt+ZGqxW78yt9SW9pijepIfAnz/lWXWPwQTszzr1huTwuojTgyqj0GSBcQoiRDvF0Ug+ZkppuJEHUc8vyqNjjphp/ui4qSoCLnXby7h5JZAODmNcOJe1CMWU23hZrWF6aRzMQ+qrTjR+2U7HKeNk3jmljbLQEPRJDgFL/JLelx8kx8CTGeGv/3xMO9vbMv0jDwqk/boWPCvlr/O6MRIhxJtiiCg98yU/CUYwkkR0XGzT4QTNoel4oSKEypOEj6/RytO9Mo7Y7tV32bsEznTqzhJs8ms3kOAm7+MyrKaKpOySNdjHCaF1cUZ9tWxTzsysUpLjPYmCJh6ZkI4MRENP/rIJZwcPnw42Bz2EfY4cTgXXKw0MI0bBm5W3bhYcRLm7oBwMrrJ7EIzsknZULKrh4Bms7nx04WFfiGp6bvCv/4QTPyLqS0eMSksPxIwL595nhGJVx56XJuGQKu1uW3/4uKidDqdmMv7X34tSEtjo3+EkzQR8LttLuGEpTruJweigZuigenMczEPqhVOVASGRQ/NE3VGhJOWLPSX6cSsrY3G2tS3J6bzx+b+EExsjo4/tjExLDeW8C6Xt4nRiJkJivSRhoCpZyaEkzTU/W6LcMJSHZbqsFSHpToJn/Pxm8Nm/OUwSTiR0d3cEU4ycg4u40E9OzuuTE+AfEvPLMsVcM5CrfpriFv1MaibBfHCyWil7yiXwS/CEE7qljnj/UU4QThBOEE4QTjJIpxETsLZvFyj6mRkj5MpWZ7rnaRDxYmR385UmRjBSCcpCTAxTAksQ3MYZ4Bm0SXEz6Jg1MCU5IoT9WXVssy2N0/QCZdTL89Ku7m5FBrhpAbJoukiwsmwcKJxLOjGyRgh5NGJUvh+a2Hz1AzNYFTRLG6JRmtxSnono048GnWz3eAxrHE/jzKL7uGg2rYWxu/pUAaTSctUQl+kKZ3IB2h3icayzLXb0piL/r0Ma4sZg6U6k7nGbw7bzwH9mAx+dgSfHuF+Jt0TepZWVT+TjzROfgjQt8XHlggmPkbVLZ+YGBYbL/gWy7fo3olf0YTpP0og+ZlJb6N/hBPyqk/AU+EkOhHpT05Gg37hwgXZHhVOBr7tHT8hnjzZ75WARY8btTjfRibMAYPltYY0QqF1MoONb8kj/ik2oz8P+plfk0Z4ikjk7zGqbhWoxooGYWXAqszKmsydUSJJ3zqEkyriNDxmtXucxP2yLZ5K8kNA8TbYOAKCiY1Rqa9NTA6LiT1ci+Fadq/EsWzi9R0v+ZmpO19sLfSqfhWqmMpfhJP65tCw554KJy1pBRUf4YETE0rfh4UT9W3wPjkj7d4MefjfG9PmxXlZa0Qn0ptY1TXLQRXKWrCpc/+4UZvTbXKlwbj9FqJCSNQ7nZ/329wprw6Xx1UEahyDfvzPBFkRzQsqTioK1NCw1Qon6qMluNdn20HFSHk8kh8CyrOl6pH6Yomy46cHnqzaHMaHwAABJodmEwKeZnlW2RuxrJJ+vcbWe2Ya/LI9rvIX4aReeTPJW0+Fk6HJ/FTk1IrIW9mEk8EbbG5pSKVU6+Iaa0Glgg/CyZhv1dVypkAYWgiO/AoP/epX14z7eahfBcuXumsRwuUJjbXyJ53jboR44SQiGgVS2GA8qTix4SO0WuFk3OZiGnuc5ICn9xCQYwAHLqW6xIEgYSIbExvMASbaBmFa0hUxtSQQnpth6pkJ4cTzREnhXi7h5O7bd3W+92fPyczMjNaQ6+vr2m11DXvq1DNy/Ojh8eOHk/mFoT0qus1HluqE+5uINMOjQWPKt0ZGiU6gJ020tfBU0ihpf4+45TgSclqTpXCPj6D+or88Z3Y5/ueba1x6Po6rTKkEQfzGqAMbeA5X3iCcVBOpwVGrFU6qIWDqIaAa6/ONimCSjx9Xl0+AyaEZ5nA0w9GmXoipTdHw1xatZyaNjf4RTvzNkbSe6eoTql+le0xPT4dD7Ny9R6YOf/v3Oo8cf1JbDClTONmocFgY3thzE9GIcBK8tVkZMRcu9Vmb21y6Ewe3LxoMLOcYOjUjbVDKbD++2mJozV/UqGExqv/vhdagSDVGtGr1ljrd+epgFUqZSx6i7sQxiFu2Nb/a6AlwCCdl5ui4sRBObIhCsTawHKdYvvRePAEmiPkYwy8fP5uvJrY2R8cP25KFE70DHhBO/MgHE17kE04OLHYeOfHHVgonG3CGqiOi0OKEk0F9IPnEl+5GsU2RxcXuspXoy4ENYkdFg3H7mkQcyyOcbGwIGyCL2zDWRFan7GOUQdIyDISTlIgLaV6tcNLLkQnCbBFOJz8EFDFq+X1SXVI+cxMjPvjGg/JK+xWZCv7cNX+XnPrKKRPdutXHpUsil13WtfnDD0WuuIJlOxkj6OLE2rZ7wDZ7hlPBxRhnTGcuq4BA8jOT3kb/CCcVBM/SIXMJJ7u+tKvz3IuWL9UJwI87BWeicKLEgeW53pHCYxTJcOPZYP+U3pKVjRi7XHEydmnTOLGgu6RptaGOVR1eutT/eZ9M9Lz0MSftVHCjjAgnA7GP2h7np55aXYFbqYbkOOLJuEaPI+61HyjxLHZ/EzVi8kNAqrBb1ZjqEqvCkdqYnT/YKQdvPCg3br9ROsGftz94W55feV5e3/966r6cveCqq0R+8QuRjz8W+eUvRX71V0XUz372M8STlEF1cUJt2z1gmz1xKeBinFOmMs0rJKDzzKSz0T/CSYVBtGzoXMLJ4cO/33nkkcftqzhRm5YG62y6h12Mn9iOCifRSoPoJGhYNNisLlEbnY4sMXFYOIlu4trP1e4GuGuyOLUsc32RKBSNloKdYIJX9Fv3cT8PmsUuf4lsGGvLUp34I5V7y7jC5TpBtcwGC4STqj7Tqq04iRNOoiSKEVF0HgKqikeWcRFLslCz7xr1rfatn7tVdn9+94BxZ8+dlbc+eEtOfvmkfUYXYdHll3dFk6mpbu//8A8iW7eK/PznCCcpebs2obbtHrDNnknhdy3WKVOZ5hUSSH5mSqow7xqPcFJhEC0bOpdwcs/h+zrffeSYfcJJdPIezutjxI3g50lLdSyLVSHmuFhpYBoEDCR+g1zToA33V61wwlKdrOFELMlKzt7rtp3cJiv3rsjVV149YOSFixfkhmdvkPNHzttrvGnLlGjS6YioJTvBMp1QPOm9mCDqwXaRk233gG32IJzo5T6tzBJIFk70xkM40eNUh1a5hJND3/7dzqPHn7JPONGMHMKJmxNmzfBqN0M4cTMPqhVOtNPLaENTDwFGjaKz2hPYfnK7vHvvu7Ltym31Fk7U8hy1v4na20T9/5YtXQEl8nJRFCgzwV3lY9s9YJs9STnkatyT/OL9agmMf2aadLpndFuBrv0IJ9XG0abRcwknruxxMg44wombE2bTNxDCiZt5UL5wMq6kM5qRxSzR6Y+AcGL67qc/EwSOvHFEbv7szXLHF+4Y6K651pR3zr8jT9/2tIlh7O/jU58S+bu/6womqupECShqj5O//3vEE43ouTx5tu0esM0ejfCznE0HEm1SEZgonEzFHOqx0fvgsxzCSSrsXjfOJZzcEmwOe9qBzWERTsbnMKKBm6KB6U8lF/OgfOHENPX0/SGcpGfGFeUQuP2l2+XAjgNy02duCgd88ydvysurL8tr+14rxwAbRvn0p7ubw6r/qdev/Ep3j5O/+qsR61wWCYpA7QMP2+4B2+xJyhsfciDJR94vlwAVJ+XyrsNoCCfbt9chzmN9dHHCbDpgMHBTPKpeOBmuQJmTpeETtgwnK8KJYaB0Z5TAQz96KDyOWL32f3F/fSpNohRjjiMeB5mJ4iYZX1jYdg/YZk/SB44veZDkJ++XQ8DUMxMVJ+XEy4VREE4QTuTaa691IVcLsxHhBOEkKblGjyOOHsPduzrclHpVGsGxS90Tvcy/TD0EmLeMHiEAgSwEmCgKSzSyJI6n13A/eBrYitwy9cyEcFJRAC0cFuEE4QTh5P33YeAgg2orTlS1SUsWBkQSJabsEznTlsZcMZ/2ph4CirGOXiEAgSwE6jxZrLPvWXKlDteQE3WIcjk+mnpmQjgpJ14ujIJwgnCCaOCgaGD6w8XFqptqhRMqTkznIP1BoM4E6jhZrKPPdc7xNL6TG2lo0XYcAYQTcsM0AYQThBOEE4QTQTiZ/NE6ulRHtR/e46TYE3XUiKYeAkz/IqE/CEAgH4G6TRTr5m++7Kjf1eRH/WJehMdaz0zhMuslWZXePnVrizK1PCftdiP4SfdFxUkR0XGzT4QThBOEE4QThJOEz+944aT8D32th4DyzWJECEDAAIG6TBbr4qeBlKh1F+RJrcNvxPnkZ6bNJdazy/Oy1lBLrUeXXSOcGAmHF53kEk7u2bur891/95zMzMxowVhfX9duq2vYU6eekeNHD2uNP9zowoULcvHixUzXchEEfCPg2ibBlS3V2fh2QmVA8VUm0TxLfgjwLSvxBwL1IuD7ZNF3/+qVrcV7S74Uz9jnEZKfmTb3q5NFhBOfc8GUb7r6hBpP6R7T09Ph0Dt375EpW4STQ/fdk5nH1q1bM1/LhRCAQHUEqhFOhvY2aQUlna0F6TSLOkdnkG/yQ0B18WBkCEDADAFfJ4u++mUm6vQSR4CcIS/yENB5ZmotTklroSMLrZ5wwlKdPMi9vxbhBOHE+yTHQT8JVCOcDJ+mE3e6ThLv4Jr5NWlE1s/2r1C/wBfXlgbW1kZ703kISBqd9yEAAfsJ+DZh9M0f+zPIHwvJHX9iWbYnes9M3S/Ellb71o1WErNUp+zI2TsewgnCib3ZiWUQmEDAReFkNVhDO69+O8+NiiNKNFkOlv7I2lxwovHmpmQIJ9wGEKgnAV8mjL74Uc8stMNrcsiOOLhmhZ5wkuwVwkkyo7q0QDhBOKlLruOnZwSqE04Wg/N0xr009jxRe6TskwFxRAkq++SMtO98deQ9hBPPEhd3IJCCgJowqtdPDzyZ4ip7mjLhtScWLltCHrkcvepsjxdOhk9EjLNv8FkO4aS6GNo2ci7h5NChQ51HH31Ue8PXojaHZY8T29IKeyBQPIFqhBMDfg0JJxuiSSM4+C5GVBkWTprN5saPFhbK2VvFgNd0AQEI5CDg4sTRRZtzhIhLCyZAPhUM2MPukytO1DKdZZltN1W9b/elnsOWZ6Ud2bsO4cTD5MjoUi7hhM1hM1LnMghAIDcBP4ST4bW1PSwxS3nUO8kPAbmx0gEEIGApAZcmji7Zamm4Q7P+v3suk2teuGSziaXaRl6Vitv5wZKfmeL2qeM4YucDX6ADCCcs1SkwvegaAsUR8EM4GeKjUXHS6XSKg0rPEICA1QRcmDi6YKPNQVZiSf+lRJP+vxFQulTIL5uz1y7bkoWT7pdXrYW2tFXVr3qp57D5VWl0NqtQqDixK65VWpNLOLnlS7s6p198jqU6VUaQsSFQUwIIJzUNPG5DoOYEbJ04ur4fiw1pNanChOoThBMbctQlG5KFk1ApGTpVZ06W2m3p6yiqBcKJS1Ev1laEEypOis0weodAQQRcFE42TtXpMVlodiSyjFZrjxMqTgpKKLqFgEMEbBNPbLPHoVBumKojjOi0cdH3tDaTb2mJ1bO9nnCSzAbhJJlRXVognCCc1CXX8dMzAi4KJ3lDYOohIK8dXA8BCFRPwJbJoy12VB+R7BakEUTStM1ukf1Xknf2x6hqC/WemYZP2aHipOq42Tw+wgnCic35iW0QGEsA4YTkgAAE6k6g6uUxTF7zZ2AWISTLNfktta8H8s++mNhkUbJw0l2ms9qIVP+yx4lNIbTOFoQThBPrkhKDIKBDAOFEhxJtIACBOhAoewJZtWDjS0zzCCB5rvWFX9l57ws3n/1otVob7i0uLsrk5c2cquNzLhThG8IJwkkReUWfECicAMJJ4YgZAAIQcIhAWZPIssZxCH0mU00IHyb6yGS8RReRjxYFwzJTqDixLCAemINwgnDiQRrjQh0JIJzUMer4DAEITCJQ5CSSKhNzuWdK8DDVjznPqumpyLyvxiNGNUEgWThRowzvcbIgzchRxKoFm8OaiIYffeQSTg4dWOw8euKPOY7Yj1zACwg4RQDhxKlwYWwNCDz4xoPySvsVmQr+3DV/l5z6yqkaeG2fi0UIHExM9eKscw+YFjsm9adjj55n9rciR+2PUdkW6gknyVYhnCQzqkuLXMLJLV/a1Tn94nMIJ3XJFvyEgEUEEE4sCgam1J7Azh/slIM3HpQbt98oneDP2x+8Lc+vPC+v73+99myqAmBCQDHRR1X+lz2u7j1gWjhRfsb1qWtP2ZyKHA/xpEi67vU9XjgZrjIZ9m2w6gThxL3YF2UxwglLdYrKLfqFQKEEEE4KxUvnENAmoL7VvvVzt8ruz+8euObsubPy1gdvyckvn9Tui4bmCWQRP7JcY95yd3rUvQeKEE3ihBNde9whrG8p4ok+K99bjhdOuqfpLK2KLDQjJ+qMAYJw4num6PuXSzi56/ZdnZN/RsWJPm5aQgACpgggnJgiST8QyEdg28ltsnLvilx95dUDHV24eEFuePYGOX/kfL4BuNoIgSQxpP++GuynB540MmZdOtG5B4oSTfqMo/3r2ONrbBBOfI1ser90luq0FqdkMTiIZ5KAgnCSnr2vV+QSTg4d+lbn0UefYKmOr9mBXxCwmADCicXBwbRaEdh+cru8e++7su3KbQgnDkQ+KpBEzUUsyR68pHvgv773V3LNC5eyD6BxZVQ4SbLHdzET8UQjYWrQREc46WMIBZS1JWm3GzI3xAbhpAbJouliLuHkDw59u9N49DjCiSZsmkEAAuYIIJyYY0lPEMhD4MgbR+Tmz94sd3zhjoFummtNeef8O/L0bU/n6Z5rIWA9gaR74F+ePlW4cKIg9cWTJHvqcE8inlh/2xRuYLJwordkB+Gk8FA5M0Au4eTQvb/befSxpxBOnAk3hkLAHwIIJ/7EEk/cJ3D7S7fLgR0H5KbP3BQ68+ZP3pSXV1+W1/a95r5zeAABDQLj7oF//f/+P6WIJlHhRP2de1IE8UQjcT1ukrw57JwstdvSGC4xGWKCcOJxkqR0LZdwsjM4Ved5TtVJiZzmEICACQIIJyYo0gcEzBF46EcPhccRq9f+L+6n0sQcWnpyhMDwPVBWpUkUT3TJDvck4okjt04hZiYLJ+OG5VSdQgLiQae5hBOOI/YgA3ABAo4SQDhxNHCYDQEIQKAGBIreDHYSwirHtjG0VJ7YGJXibUpeqqNnAxUnepzq0ArhhOOI65Dn+OghAYQTD4OKSxCAAAQ8IFC1cFH1+DaGEPHExqgUaxPCSbF869g7wgnCSR3zHp89IIBw4kEQcQECEICAhwRsEC5ssMG20CKe2BaRYu1BOCmWbx17RzhBOKlj3uOzBwQQTjwIIi5AAAIQ8IyALYKFLXbYFl7EE9siUpw9CCfFsa1rzwgnCCd1zX38dpwAwonjAcR8CEAAAp4RsE2ssM0eG8KNcGJDFMqxAeGkHM51GgXhBOGkTvmOrx4RQDjxKJi4AgEIQMBxAjaKFDbaZEOYEU9siELxNiCcFM+4biMgnCCc1C3n8dcTAggnngQSNyAAAQg4TsBmgcJm2xwPO+ZbTgDhxPIAOWheLuHk0L2/23n0sadkZmZGy/X19XXttrqGPXXqGTl03z1a48c12opwkpkdF0KgSgLuCictWZxfk0a7IXMK4OqyzM8vyWoP5txSW9qN8J2Rl6mHgCrjxtgQgAAEfCJguzBhu31V5gKVJ1XSL35sU89MHEdcfKxcGUFXn1D+KN1jeno6dG3n7j0ydcuXdnVOv/icthiCcOJKWmAnBOwn4KJwsro8L/NLgUQytyTtvnDSWpRFaUpzQTEPRJWpZZlrtyVOOzH1EGB/dLEQAhAwTUBNoJNe17xwKakJ7w8RcEGYcMHGqhIL8aQq8sWPa+qZCeGk+Fi5MgLCCRUnruQqdkJggICLwknogKow2Sdypi+cDHi1KsvdNxFOyHcIQCA3gahYoiOKpG2f20DHO3BFkHDFzqrSAfGkKvLFjotwUizfOvaeSzj5g/1f6zSe/j4VJ3XMHHyGQMUEvBROJooqIuohoNlsbpBfWAjLVHhBAAIQGCDQF0B0xJJx6Ez04XNYXBMjXLO37NxBPCmbePHjIZwUz7huI+QSTu459O3Odx89jnBSt6zBXwhYQMA/4WTyMh2F3NRDgAXhwwQIQKAAAkWIHUX0WYDrpXbpogjhos2lBjUYDPGkbOLFjmfqmYmlOsXGyaXecwknXztwqPP9E48inLgUcWyFgCcE/BJOkkUThBNPEhc3IFAAgTLEjTLGKACN8S5dFiBctt14IMd0qMQT9frpgSfLGpJxCiKAcFIQ2Bp3m0s4+YOg4qRBxUmN0wfXIVAdAW+Ek/BUnZYsjNkQNkrY1ENAdVFjZAhAwCSBKsSMuu6DUgVrk7nS7wvxRI8q1Sd6nGxuZeqZiYoTm6Ncrm25hJN79u7qfPffcapOuSFjNAhAQBFwUTjZOFWnF8KFZkcaa72TdiJhHXcksamHADIIAhBwm4Atk3hb7Cg6mj6JDT75UnTcEU+KJlxs/6aemRBOio2TS73nEk44jtilUGMrBPwi4KJwkjcCph4C8trB9RCAQPkEbK708FlA8VFo8NGnou5IxJOiyBbfr6lnJoST4mPlyggIJxxH7EquYicEBgggnJAQEIBAHQi4JEq4ZGtS7vjky7CvCCdJ0R98H/F3Zo8iAAAgAElEQVQkHS9bWiOc2BIJf+xAOEE48Seb8aRWBBBOahVunIVA7Qi4PHF32XaVaHUQFurgo8kPDcQTkzTL6QvhpBzOdRoF4QThpE75jq8eEUA48SiYuAIBCGwQcF10iIbS5uVFcSnnE/ukWwrhJInQ6PuIJ+mZVXkFwkmV9P0cG+EE4cTPzMYr7wkgnHgfYhyEQK0I+D5pt1lE8Z39uBsJ8ST9RwziSXpmVV2BcFIVeX/HRThBOPE3u/HMawIIJ16HF+ccJPDgGw/KK+1XZCr4c9f8XXLqK6cc9KJ8k+s4abdFRDHN3rZ7QMcexJP09zziSXpmVVyBcFIFdb/HRDhBOPE7w/HOWwIIJ96GFsccJLDzBzvl4I0H5cbtN0on+PP2B2/L8yvPy+v7X3fQm3JMNj1pL8dq86OULaIUNZ5t94CuPQgn2XJaiSfq9dMDT2brgKsKJ4BwUjji2g2QSzg5dOhQ59FHH5WZmRktcOvr69ptdQ176tQzcui+e7TGj2u0FeEkMzsuhECVBBBOqqTP2BDYJKC+1b71c7fK7s/vHsBy9txZeeuDt+Tkl0+Cq0egqEm7L4CjfPo+XfPCpdzuFc3dtnsgrT2IJ9lTjOqT7OyKvhLhpGjC9etfV59QZJTuMT09HULauXuPTN1z6Nud7z56XFsMQTipX4LhMQSKIoBwUhRZ+oVAOgLbTm6TlXtX5Oorrx648MLFC3LDszfI+SPn03XoYWuqS7IHNU5MSdubCfFl0pi23QNp7UE4SZtRg+0RT/LxK+pqhJOiyNa331zCyaEDi51HT/wxwkl98wfPIVAZAYSTytAzMAQGCGw/uV3evfdd2XblNoSTodxAMKnHzWLbPZDFHsSTfLmKeJKPn6mrW63WRleLi4vS6XRyd/3RRx8l9pF1Qr1ly5bYvtP0l2gcDYwRSBOXkYqTu27f1Tn5Z88hnBgLBx1BAAK6BBBOdEnRDgLFEjjyxhG5+bM3yx1fuGNgoOZaU945/448fdvTxRpgYe8IJhYGpUCTbLsHstqDeJIvSRBP8vEzfTUVJ6aJ0l8u4eSWL+3qnH4R4YQ0ggAEyieAcFI+c0aEwDgCt790uxzYcUBu+sxNYZM3f/KmvLz6sry277XaQCt6H43agHTUUdvugSz2IJzkTz42jc3P0FQPCCemSNJPnwDCCZvDcjdAwEkCCCdOhg2jPSbw0I8eCo8jVq/9X9xfm0oTqks8TuqUrtl2D2SxB/EkZdDHNKf6xAzHPL0gnOShx7VxBBBOEE64MyDgJAGEEyfDhtEQ8IIA1SVehBEnYgggnJhLC8QTcyyz9IRwkoUa10wigHCCcMIdAgEnCSCcOBk2jIaA0wSoLnE6fBivSQDxRBOURjPEEw1IBTVBOCkIbI27RThBOKlx+uO6ywQQTlyOHrZDwB0CVJe4EyssNUcA8cQcS/Y9MccyTU8IJ2lo0VaHAMIJwolOntAGAtYRQDixLiQYBAFvCCCWeBNKHMlIAOEkI7gJl1F9Yp7ppB4RTsrlXYfREE4QTuqQ5/joIQGEEw+DiksQqJAAYkmF8BnaSgKIJ+bDgnhinum4HhFOymNdl5EQThBO6pLr+OkZAYQTzwKKOxCoiAD7llQEnmGdIIB4Yj5MLN0xzzSuR4STcjjXaRSEE4STOuU7vnpEwF3hpCWL82vSaDdkLoxH8O+pxeC/6rUgzU4z+G/8y9RDgEdpgCsQyESA6pJM2LiohgQQTooLOtUnxbFVPZt6Zvroo48SDc06od6yZUts32n6SzSOBsYIpInL+vq6TE9Ph2Pv3L1Hpm750q7O6Refk5mZGS2DVAe6bXUNe+rUM3Lovnu0xo9rtBXhJDM7LoRAlQRcFE5Wl+dlfmlVZG5J2j3hpLU4Ja2FjjQDtSR8f7UhHfWPmJeph4Aq48bYEKiKAGJJVeQZ13UCiCfFRRDxpDi2pp6ZEE6Ki5FrPevqE8ovhBPXoou9EPCYgIvCSRiO1WWZ3ydyJhROVLVJSxb6VSYD740Gz9RDgMdpgWsQGCCAWEJCQMAMAcQTMxzjemHpTjFsTT0zIZwUEx8Xe80lnNx/z0Ln6Hf/jXYVCRUnLqYINkPATgJeCifDQsoQevUQsLS0NPDTRqNhZ4CwCgIVEIgKJWr4a164VIEVDAkB/wggnBQfU6pPzDJGODHLk95Ecgkn37z/3s4fHn0M4YRMggAESidQV+Gk0+mUzpoBIWAzAapKbI4OtvlEAPGk+GhSfWKOMcKJOZb01CWQSzi5/97f7Rx97CmEE7IJAhAonYCXwglLdUrPIwZ0kwBiiZtxw2r3CSCelBNDqk/yc0Y4yc+QHgYJ5BJO2ByWdIIABKoi4IdwEpypw+awVaUQ4zpGALHEsYBhrpcEEE7KCyviST7WCCf5+HH1KIFcwgkVJ6QUBCBQFQEXhZONU3V60Baa6jQdjiOuKocY124C7Fdid3ywrr4EEE/Kiz1Ld7KzRjjJzo4r4wnkEk6+ef/9wR4nR1mqQ3ZBAAKlE3BROMkLydRDQF47uB4CRRBAKCmCKn1CoBgCiCfFcB3XK9Un6XmbembiVJ307H29Ipdw8gfB5rANNof1NTfwCwJWE0A4sTo8GAcBLQIsv9HCRCMIWEkA8aTcsFB9ko43wkk6XrROJpBLOPnmnl2dP/yT56g4SeZMCwhAwDABhBPDQOkOAiUQoKqkBMgMAYGSCCCclAR6aBiqT/S4I5zocaKVPoFcwgmbw+qDpiUEIGCWAMKJWZ70BoEiCCCUFEGVPiFgDwHEk2piQfVJMneEk2RGtEhHAOFk69Z0xGgNAQhYQQDhxIowYAQEBggglJAQEKgfAcST6mJO9cl49ggn1eWlryMjnCCc+Jrb+OU5AYQTzwOMe04QQChxIkwYCYHCCSCeFI547ABUn8SjQTipLid9HRnhBOHE19zGL88JIJx4HmDcs47AsEiiDLzmhUsbdj74xoPySvsVmQr+3DV/l5z6yinrfMAgCBRJwLZ7oGx7EE+KzK7kvhFQBhkhnCTnDC3SEUA4QThJlzG0hoAlBBBOLAkEZnhLIE01yc4f7JSDNx6UG7ffKJ3gz9sfvC3Przwvr+9/3Vs+OAaBKAHb7oEq7EE4seOeYPlONw4IJ3bko09WIJwgnPiUz/hSIwIIJzUKNq4WTiCpmmSSAepb7Vs/d6vs/vzugWZnz52Vtz54S05++WTh9jMABKokYNs9UKU9iCdVZuLm2FSfIJzYkYl+WYFwgnDiV0bjTW0IIJzUJtQ4aphAHpEkzpRtJ7fJyr0rcvWVVw+8feHiBbnh2Rvk/JHzhj2gOwjYRcC2e6BqexBP7MnPOlefUHFiTx76Ykku4eRrX9rV+f6Lz8nMzIwWj/X1de22uoY9deoZOXTfPVrjxzXainCSmR0XQqBKAggnVdJnbFcImBZJ4vzefnK7vHvvu7Ltym0IJ64kBnYaJWDbPWCDPYgnRlMsV2d1rT5BOMmVNlwcQ0BXn1CXKt1jeno67GXn7j0ydf+9v9s5+thT2mIIwgk5CAEImCKAcGKKJP34QCBOIFF+RTdvLcrPI28ckZs/e7Pc8YU7BoZorjXlnfPvyNO3PV3U0PQLASsI2HYP2GIP4okV6blhRN0EFIQTu/LPB2tyCSffvP/ezh8efQzhxIdMwAcIOEYA4cSxgGGuMQJlVJGkNfb2l26XAzsOyE2fuSm89M2fvCkvr74sr+17LW1XtIeAkwRsuwdssQfxxL50rsvyHYQT+3LPdYtyCSf3B8LJUYQT13MA+yHgJAGEEyfDhtEpCFRZRZLCzI2mD/3oofA4YvXa/8X9VJpkgcg1ThOw7R6wxR7EE/vSug7VJwgn9uWd6xblEk6oOHE9/NgPAXcJIJy4Gzss3yQwThxRLcpYZkMsIAABCJRBAPGkDMrpx/BZQEE4SZ8PXDGZQC7h5A/u/1ancfQJluqQZRCAQOkEEE5KR86AOQi4Vj2Sw1UuhQAEIDBCAOHE7qTwUUBBOLE751y0Lp9wcvfXOo3vfR/hxMXIYzMEHCeAcOJ4AD0zf1LliHKV6hHPAo47EIBAagKIJ6mRlX6BT/ufIJyUnj7eD5hLOLklOI74NMcRe58kOAgBGwkgnNgYFb9tYlmN3/HFOwhAAAIQEHG5+qTVam2EcHFxUTqdTu6QfvTRR4l9ZJ1Qb9myJbbvNP0lGkcDYwTSxGXkOGKEE2NxoCMIQCAlAYSTlMBonkiAqpFERDSAAAQgkJsAlSe5EdKBBgEqTjQg0SQVAYSTrVtTAaMxBCBgBwGEEzvi4IIVSYJI3weW07gQTWyEAAR8IIB44kMU7fYB4cTu+LhoHcIJwomLeYvNEBBvhJPVZZmfX5LVMKZzstRuS2MuPsCmHgJ8SR8EEV8iiR8QgEAdCSCe1DHq5fls6pmJpTrlxcz2kRBOEE5sz1Hsg0AsAT+Ek1VZnt8ncqYnlrQWZWp5TtrtRiChjL5MPQTYmlK6QkjffipEbI0kdkEAAhDQI4B4oseJVukJmHpmQjhJz97XKxBOEE58zW388pyAl8KJqj4JdRR/hRM2WPX8xsQ9CEAAAikJIJ6kBEZzLQIIJ1qYaJSCAMIJwkmKdKEpBOwh4Idwoni2ZHFqMfiveiUv1Wk2mxtBWFhYsCcgWAIBCEAAAhDISKAvqlNJmBEgl40QQDghKUwTQDhBODGdU/QHgVII+CKctBanpLXQkeaCWrYzL0uzTek04wURUw8BpQSIQSAAAQhAAAIpCVB9khIYzccSMPXMxFIdkqxPIJdwctftuzon/+w5mZmZ0SKqzjPWbatr2FOnnpFD992jNX5co60IJ5nZcSEEqiTghXAysjRnaM+TIcCmHgKqjBtjQwACEIAABCYRQDwhP0wQMPXMhHBiIhp+9KGrTyhvle4xPT0dOr5z9x6Z+oP7v9VpHH1CWwxBOPEjafACAjYQ8EI46S3TkaaqOAmohifsrEqj05S4mhNTDwE2xA8bIAABCEAAAuMIIJ6QG3kJmHpmQjjJGwl/rs8lnNx///2do0ePIpz4kw94AgFnCPghnPTFEo4jdibxMBQCEIAABEohgHhSCmZvB0E48Ta0lTmWSzi56577Oye/i3BSWfQYGAI1JuCNcJIihqYeAlIMSVMIQAACEIBAZQQQTypD7/zApp6ZqDhxPhWMOZBLOPlaIJx8H+HEWDDoCAIQ0CeAcKLPipYQgAAEIAABVwkgnrgauWrtRjiplr+Po+cSTu66N6g4eYyKEx8TA58gYDsBhBPbI4R9EIAABCAAATMEOK7YDMc69YJwUqdol+NrLuHk/mBz2KNsDltOpBgFAhAYIIBwQkJAAAIQgAAE6kWA6pN6xTuPtwgneehxbRyBXMIJxxGTVBCAQFUEEE6qIs+4EIAABCAAgeoIIJ5Ux96lkRFOXIqWG7bmEk5u+dKuzukXn+NUHTdijZUQ8IoAwolX4cQZCEAAAhCAgDYBxBNtVLVtiHBS29AX5jjCydathcGlYwhAoDgCCCfFsaVnCGQh8OAbD8or7VdkKvhz1/xdcuorp7J0wzUQcJLAP//nIv/tv8WbfsstIv/1v5bvlu/3JPuelJ9TLo2IcOJStNywFeEE4cSNTMVKCAwRQDghJSBgD4GdP9gpB288KDduv1E6wZ+3P3hbnl95Xl7f/7o9RmIJBAokMDUl0unEDzDpvaJMqtM9SfVJUVnkdr8IJ27Hz0brEU4QTmzMS2yCQCIBhJNERDSAQCkE1Lfat37uVtn9+d0D4509d1be+uAtOfnlk6XYwSAQqJKATcJJHe9JxJMqs9/OsRFO7IyLy1YhnCCcuJy/2F5jAggnNQ4+rltFYNvJbbJy74pcfeXVA3ZduHhBbnj2Bjl/5LxV9mIMBIogYJNwUtd7kqU7RWS2u30inLgbO1stRzhBOLE1N7ELAhMJIJyQIBCwg8D2k9vl3XvflW1XbkM4sSMkWFEBAZuEk7rfk1SfVHADWDgkwomFQXHcJIQThBPHUxjz60oA4aSukcdv2wgceeOI3PzZm+WOL9wxYFpzrSnvnH9Hnr7tadtMxh4IGCdgk3DCPSmCeGI8xZ3rEOHEuZBZbzDCCcKJ9UmKgRCII4BwQl5AwB4Ct790uxzYcUBu+sxNoVFv/uRNeXn1ZXlt32v2GIklECiQgE3CiXKTe7IrnqjXNS9cKjDydG0rAYQTWyPjrl0IJwgn7mYvlteaAMJJrcOP8xYSeOhHD4XHEavX/i/up9LEwhhhUnEEbDyOmHuyG2+qT4rLe5t7RjixOTpu2oZwgnDiZuZide0JIJzUPgUAAAEIQAACENAiQPWJFiavGiGceBVOK5xBOEE4sSIRMQICaQkgnKQlRnsIQAACEIBAvQlQfVKf+COc1CfWZXmKcIJwUlauMQ4EjBJAODGKk84gAAEIQAACtSBA9UktwiwIJ/WIc5leIpwgnJSZb4wFAWMEEE6MoaQjCEAAAhCAQO0IUH3id8gRTvyObxXeIZwgnFSRd4wJgdwEEE5yI6QDCEAAAhCAQK0JUH3ib/gRTvyNbVWe5RJO7r///s7Ro0dlZmZGy/719XXttrqGPXXqGTl03z1a48c12opwkpkdF0KgSgIIJ1XSZ2wIQAACEICAPwSoPvEnln1PEE78i2nVHunqE8pOpXtMT0+HJu/cvUembvnSrs7pF5/TFkMQTqoON+NDwB8CXgknrUWZWmyFwZlbaku7MRcbKFMPAf5kAZ5AAAIQgAAEzBCg+sQMR1t6MfXM9NFHHyW6lHVCvWXLlti+0/SXaBwNjBFIExeEE2PY6QgCEMhLwBvhJBRNRJqdpiwkQDH1EJCXPddDAAIQgAAEfCWAgOJHZE09MyGc+JEPJrxAOGGpjok8og8IlE7AF+GktTgva422jCkyGeBq6iGg9GAxIAQgAAEIQMAxAizfcSxgQ+aaemZCOHE7D0xaj3CCcGIyn+gLAqUR8EM4acliUG7SXaTTfS00O9IcU3qiHgKazeZm24WkGpXSwsFAEIAABCAAAe8IUH3iRkjV81Hcq9Pp5HYA4SQ3Qm86QDhBOPEmmXGkXgT8EU5astBfprO6LPPzq9IYs2zH1Lcn9coUvIUABCAAAQjkI4CAko9fFVebemZCOKkienaOiXCCcGJnZmIVBBIIeCmcyKosz+8TORO/dMfUQwDJBQEIQAACEIBAegIIKOmZVXWFqWcmhJOqImjfuLmEk9++5bZO8/QLnKpjX1yxCALeE/BDOBFpLU7J8lzvJB0qTrzPWxyEAAQgAAH3CbD/if0xRDixP0auWYhwQsWJazmLvRAICfginEhYZTIvS6vKqzlZao/fKNbUQwApBAEIQAACEIBAPgJUn+TjV/TVpp6ZqDgpOlLu9J9LOLlj3z2dPz31XSpO3Ik3lkLAGwL+CCf6ITH1EKA/Ii0hAAEIQAACEJhEAAHFzvww9cyEcGJnfKuwKqtw8o1/cb9MsVSnipAxJgQgoAggnJAHEIAABCAAAQjYQgABxZZIdO1AOLErHj5Yk1U42bl7j0xRceJDCuADBNwkgHDiZtywGgIQgAAEIOAzAQQUO6KLcGJHHHyyIqtwElacIJz4lAr4AgG3CCCcuBUvrIUABCAAAQjUiQACSrXRRjiplr+PoyOcsDmsj3mNTzUggHBSgyDjIgQgAAEIQMBxAggo1QQQ4aQa7j6PinCCcOJzfuObxwQQTjwOLq5BAAIQgAAEPCOAgFJuQBFOyuVdh9EQThBO6pDn+OghAYQTD4OKS+4TuHRJ5LLLun58+KHIFVe47xMeQCANAZvuAZtsScPQ87YIKOUEGOGkHM51GgXhBOGkTvmOrx4RQDjxKJi44gWBjz/1Kbns44/lE2qy9stfyqVANPko+N+v/PznXviHExBIJHDVVSK/+IVIcB+oe0B+9VdF1M9+9rPES403sMkW48750SECSrFxRDgplm8de0c4QTipY97jswcEEE48CCIueEXgl0GlyWXBZLHT8+qTwf///ZYtcrmqPOEFgToQuPzyrmgyNdX19h/+QUQ9Z1YhHtpkSx1in8NHBJQc8CZcinBSDNc695pLOPntW27rNE+/IDMzM1oM19fXtdvqGvbUqWfk0H33aI0f12grwklmdlwIgSoJIJxUSZ+xITCGQDBhVFNGtVjn4098QqZU9QkvCNSJgBJNOoF8qHJfLVVT4klVL5tsqYqBQ+MioJgNFsKJWZ70JqKrTyhWSveYnp4Ose3cvUemEE5IIQhAoCoCCCdVkWdcCIwhoJYmBFUnalcTJZd8rEQU9TNeEKgLgd49EO7vo/b6CSquQgGlipdNtlThv8NjIqCYCR7CiRmO9LJJAOGEihPuBwg4SQDhxMmwYbTHBC4FSwO2BN+u/0NQaaK+cd8S/O/vP/lJ+aRausALAnUgEOzzI3/3d13BRFWdKAFF7TXy939fvvc22VK+916MiICSL4wIJ/n4cfUoAYQThBPuCwg4SQDhxMmwYbTHBD78lV+RTwbCidogVr3+IRBSPgp+9qt/+7cee41rEIgQ+PSnu5vDqv+pV5D/4R4nf/VX5WOyyZbyvfdqxL6Aopy65oWKKpgcJIpw4mDQLDcZ4QThxPIUxTwIxBNAOCEzIGAhAY4/tTAomFQqAZvuAZtsKTUI/g5GFYp+bBFO9FnRUo8AwgnCiV6m0AoClhFAOLEsIJgDAQhAAAIQgEApBBBQkjEjnCQzokU6AggnCCfpMobWELCEAMKJJYHADAhAAAIQgAAEKiGAgDIeO8JJJSnp9aAIJwgnXic4zvlLAOHE39jiGQQgAAEIQAAC+gTYB2WUFcKJfv7QUo8AwgnCiV6m0AoClhFAOLEsIJgDAQhAAAIQgEDlBKhC6YYA4aTyVPTOAIQThBPvkhqH6kEA4aQeccZLCEAAAhCAAATSE6i7gIJwkj5nuGIygVzCyV3fOtg5+cR3ZGZmRovz+vq6dltdw5469Ywcuu8erfHjGm1FOMnMjgshUCUBhJMq6TM2BCAAAQhAAAIuEKjrMh6EExey0y0bdfUJ5ZXSPaanp0MHd+7eI1MIJ24FG2sh4BMBH4WT1uKULK4tSbvdkLmYYJl6CPApD/AFAhCAAAQgAAE9AnWqQjH1zPTRRx8lws06od6yZUts32n6SzSOBsYIpIkLwokx7HQEAQjkJeCbcKJEk2VZEFmbkzMIJ3nTg+shAAEIQAACEBhDoA5VKAgnpL9pAggnLNUxnVP0B4FSCPgknKwuz8s+OSPtO1+V+X2CcFJKBjEIBCAAAQhAAAK+VqEgnJDbpgkgnCCcmM4p+oNAKQR8EU42RJNGsDhndTlROGk2mxt8FxaCChVeEIAABCAAAQhAICcB36pQEE5yJgSXjxBAOEE44baAgJME/BBOVmV5fl6WVodCMBe/z4mphwAnA47REIAABCAAAQiUQkCJKNe8cKmUsYoaxNQzE3ucFBUh9/pFOEE4cS9rsRgCAQE/hJOhUGpUnHQ6HeIPAQhAAAIQgAAEIDCBAMIJ6WGaAMIJwonpnKI/CJRCAOGkFMwMAgEIQAACEIAABJwjgHDiXMisNxjhBOHE+iTFQAjEEUA4IS8gAAEIQAACEIAABOIIIJyQF6YJIJwgnJjOKfqDQCkEvBROEsiZeggoJUAMAgEIQAACEIAABCoiYOqZiT1OKgqghcMinCCcWJiWmASBZAIIJ8mMaAEBCEAAAhCAAATqSADhpI5RL9ZnhBOEk2IzjN4hUBABhJOCwNItBCAAAQhAAAIQcJBAq9XasHpxcVFMbKhPxYmDiVCQyQgnCCcFpRbdQqBYAggnxfKldwhAAAIQgAAEIOAqASpOXI2cvXYjnCCc2JudWAaBCQQQTkgPCEAAAhCAAAQgAIE4Aggn5IVpAggnCCemc4r+IFAKAYSTUjAzCAQgAAEIQAACEHCOAMKJcyGz3uB8wsmBg52TJ74jMzMzWo6ur69rt9U17KlTz8ih++7RGj+u0VaEk8zsuBACVRJAOKmSPmNDAAIQgAAEIAABewkgnNgbG1ct09UnlH9K95ieng5d3bl7j0zdhXDiatyxGwLOE0A4cT6EOAABCEAAAhCAAAQKIYBwUgjWWneKcELFSa1vAJx3lwDCibuxw3IIQAACEIAABCBQJAGEkyLp1rNvhBOEk3pmPl47TwDhxPkQ4gAEIAABCEAAAhAohADCSSFYa90pwgnCSa1vAJx3lwDCibuxw3IIQAACEIAABCBQJAGEkyLp1rNvhBOEk3pmPl47TwDhxPkQ4gAEIAABCDhIYHl5WRqNhoOWY3KdCCCc1Cna5fiKcIJwUk6mMQoEDBNAODEM1LHuWq2WLCwsOGa1O+bCt9hYwRe+xRIotneEk2L58vlghi/CiRmO9LJJAOEE4YT7AQJOEkA4cTJsxozmwdIYytiO4AvfYgkU2zv5WyxfhJNi+ZK/ZvginJjhSC+GhJN//n/+x84P/tWXZWZmRoupOs9Yt62uovPUqWfk0H33aI0f12grwklmdlwIgSoJIJxUSb/6sXmwLDYG8IVvsQSK7Z38LZYvwkmxfMlfM3wRTsxwpBeEkw0CCCfcDhBwk0BdhRM3o4XVEIAABCAAAQhAoFwCnU4n94AfffRRYh+6X/irjlQhwfT0dNjnli1bYvtO01+icTQwRiBNXKJx3rl7j0xRcWIsDnQEAQikJFBH4SQlIppDAAIQgAAEIAABCOQggHCSA55nl+YSTr6275ud75/6Q+3lNyzV8Sx7cAcCFRJAOKkQPkNDAAIQgAAEIACBGhBAOKlBkDVdzCqc/N6/+Fcy9du33NZpnn4B4UQTNs0gAAFzBBBOzLGkJwhAAAIQgAAEIACBUQIIJ2RFn0BW4SRcqoNwQiJBAAJVEUA4qYo840IAAhCAAAQgAIF6EEA4qUecdbzMJZzsCSpO/uQ0FSc6oGkDAQiYJYBwYpanE72tLsv8/K/j360AACAASURBVJKs9oydW2pLuzHnhOmuGdlanJLFtSVptxsCYYPRay3K1GIr7JD8NchVdTXw+TAnS+228PFginFLFufXpLHxeRD8e2pRupm8IM1OM/gvr+wEhvjyuy47ygKuRDgpAKqjXeYSTqg4cTTqmA0BDwggnHgQxLQuBJPORWlKM3xCVw/uyzLH5CgtxcT2SjRZVtOgtTk5g3CSyEu7QSiaCJNMbWBpGq7K8vw+CRK2K5Yo1stzCH9pEI5pu7o8L/NLgVw9tymkqs+I1kIn/CwO319tSKf7wcwrJYE4vip/+V2XEmSBzRFOCoTrWNcIJ1u3OhYyzIUABBQBhJO658HQRKnuOAz5rx7i98kZad/5qnTnoVScGEIbzIXmZa1BFYQpnoP9DH0eqG/syV9zqAd4KtG6JQv9KhNY5+c8kSG/6/IDztcDwkk+fj5djXCCcOJTPuNLjQggnNQo2HGu8rBuPAE2RBP1lT18DfONLm3odr3Q7H5jz8sUgShjluqYohr2M0k4Cav/IkKK0YFr0tmkz1s+iytPAoSTykNgjQEIJwgn1iQjhkAgDQGEkzS0fGvLMh3zEVXfas6LqsgfeEXK882PWaceY76ln1+VBntDGEuCzeUjvVyebbJ8xBRdhBNTJOP7GSuO8LuuWPB6vSOc6HGqQyuEE4STOuQ5PnpIAOHEw6BqucSDpBamvI34ljMvwaHrh7+Vp/zeKOCRfIVvcXxZqmOUreos9vOW33XGOWfsEOEkIzgPL0M4QTjxMK1xqQ4EEE7qEOUhH8OTBoKScDaELT74CCfGGYeb7s71ToIKc5mKE3OQu8t0gp13u8uf4GsObczEns1hzeIdEU74XWcYcL7uEE7y8fPpaoQThBOf8hlfakQA4aRGwe65unH6QMR1jnQtKA8QTgoAG10OxR4cxgFzHLFxpF3NpHeqTq/37t48HEdsCnYc38baIHM1Fr/rTBFP3w/CSXpmvl6BcIJw4mtu45fnBBBOPA8w7kEAAhCAAAQgAIGKCSCcVBwAi4ZHOEE4sSgdMQUC+gQQTvRZ0RICEIAABCAAAQhAID0BhJP0zHy9IpdwsueW2zp/cvoFmZmZ0eKzvr6u3VbXsKdOPSOH7rtHa/y4RlsRTjKz40IIVEkA4aRK+owNAQhAAAIQgAAE/CeAcOJ/jHU91NUnVH9K95ieng673rl7j0z9diCcNBFOdFnTDgIQMEgA4cQgTLqCAAQgAAEIQAACEBghgHBCUvQJIJxQccLdAAEnCSCcOBk2jIYABCAAAQhAAALOEEA4cSZUhRuaSzj5l0HFydJpluoUHiUGgAAERgggnJAUEIAABCAAAQhAAAJFEkA4KZKuW33nEk6OLtzWuf/fIJy4FXKshYAfBBBO/IgjXkAAAhCAAAQgAAFbCSCc2BqZ8u3KJZywOWz5AWNECECgSwDhhEyAAAQgAAEIQAACECiSAMJJkXTd6juXcMLmsG4FG2sh4BOBMoUTn7jhCwQgAAEIQAACEICAOQJZJ9RbtmyJNSJNf+a8oKckAmniwqk6STR5HwIQKI0AwklpqBkIAhCAAAQgAAEIQGAMgawTaoQTt1Iqa5w5jtitOGMtBLwjgHDiXUhxCAIQgAAEIAABCDhHIOuEGuHErVBnjTPCiVtxxloIeEcA4cS7kOIQBCAAAQhAAAIQcI5A1gk1wolboc4aZ4QTt+KMtRDwjgDCiXchxSEIQAACEIAABCDgHIGsE2qEE7dCnTXOCCduxRlrIeAdAYQT70KKQxCAAAQgAAEIQMA5Alkn1AgnboU6a5wRTtyKM9ZCwDsCCCfehRSHIAABCEAAAhCAgHMEsk6oEU7cCnXWOCOcuBVnrIWAdwQQTrwLKQ5BAAIQgAAEIFAigY8//lguXLggH374oVy6dKnEke0d6qqrrpJf+7Vfk8svv1zbyKwTaoQTbcRWNMwaZ4QTK8KHERCoLwGEk/rGHs8hAAEIQAACEMhHQIkmf/EXfyEzMzPh/z7xiU/k69CDq3/5y1/K3/zN38h//+//XX7zN39TWzzJOqFGOHErabLGGeHErThjLQS8I4Bw4l1IcQgCEIAABCAAgZII/PSnPxVVXfFP/sk/KWlEd4b567/+a/n5z38un/3sZ7WMzjqhRjjRwmtNo6xxRjixJoQYAoF6EkA4qWfc8RoCEIAABCAAgfwEzp07J7Ozs3LZZZfl78yzHtSypffff1+uueYaLc+yTqgRTrTwWtMoa5wRTqwJIYZAoJ4EEE7qGXe8hgAEIAABCEAgPwElnHzxi1/M35GnPfz5n/+5XHfddVreZZ1QI5xo4bWmUdY4I5xYE0IMgUA9CSCc1DPueA0BCEAAAhCAQH4CCCeTGSKc5M8x33pAONm61beY4g8EakHACeFk7YTs+LrI6ZVjMhuNyrifD0dOt51uxE30Z6IPXXtpBwEIQAACEIBAIQS8Ek5WH5fr7xZ5+b3HZM4QLYQTQyA96gbhBOHEo3TGlToRKFM42bHjxKD40RcPTot8PU4Y6QciSTjJer3qP4uAEXeN+tmOJ2RtI3n2yksfviR7xyVTlnHH9HV2/xWy/9xxWRkWlsL2Z2X/FfuD//Zee1+SD19SVg39PJCkjq+syLG+MjXOx0lxmnTjDPGZPb4iKxuDDV14dr9csb9r8Wa7qL1xbIP3d5yTYxsMxrQP7ViTY3GxGYmhyN6XPpQQl+mXwfibNo3+IAABCEBAn4Ax4USJFtcvy2pk6DvPXJIzdwY/KEDQiPWwgHEQTvRzqS4tEU4QTuqS6/jpGQErhJPYCX8EdJJwkvV6NUSWCayOqKAm/ydmx4gZGceNyT0lmpxQ8sy52dGKHNU+sGO/vNSb/K/JiW7pTiCQKGHhrOwdJ+7o+JjmXhiwQ419QmajQk2/r1A0kRHRSfl5dm9XxFg7sUN2rB3rCUC9fz8RSFazEfFI9XN2b9gmZDTbFWqi/YyYP+xzT0i5rijxJA0/2kIAAhCAgJUEjAon0WqPnpByXV88KcN7hJMyKNd+DIQThJPa3wQAcJOAFcJJtGJk+Ft/NRnuvb/3uifkiV7pRFgJcF1vCU/W6/cqIWGHqDm3eoXVDXt+GKkciVRhxNkVFWxGhIaIMDFwba9aItp+4P3hMQNxI05gCLWXHfJ1Od21WasSJCqW5BFO9sgPI9wUu3SVGVEBZ/C+Obt/h5w7Fql8Cd8eslVH1IkTTpI4JfQbJIvs6CdLv0InkK12fH1NrgtsPBvk0d6XVmQ2aKeabebo5vsbrIZydyS3VZVLUs65+ZGD1RCAAAS8IlCYcKIo9YWMl0Xu7okq8vj1cv1yry5lriHvhctqXpV9l+0L/tt9qUqVx9Yi7YIWjffek8ekuxTnzuuWZfnVO+XMpTNy53Cly0afZsJExYkZjj71gnCCcOJTPuNLjQiUKpxccUVkKUsPckQYOb1ynZzolht0KySiS3mCZTAb3/z3qzn6gsmGcJLyeiV8DEyWx03Qx/Q7QTgJqyKCioeVIZ82qiWOneuJHarvSOXHiKASL5xsiCZquUti1UxfIIoucRlcqjOydCZm2UoYsWhVR6hpJFTWxN1LY+0dXj7UF2SGRZ4Y0Wekz6go1vU7KHPZqFqJvcVj7RojMPWFGRXHHb0YnVPVMue6S57U31XFkcrN/vtqGVS/omZlVk4osSt8Pya3x90LSdVVNfrswlUIQAACNhAoVDgJBZGWLLw3J48r4UQJKNevymNK8Aicf3XfPpEzj8na9dfL6mO9ZT1xUF7dJ5e1FuTSY2vhcqDNKpau4BIoKIUtCUI4sSFL7bIB4QThxK6MxBoIaBIoVThJ2uNkeK+SqHASragY/vmIgNLbRDbp+mHhJFYsCCbd/Uluf9I6rjIhusdJX2CIXf4R7LExNHHe3BtFBS5hf5RAfopWymyEeljUGMmBcUtkYn6uU9UR8hpfEROfghOW6cRVloT7kQTLbQaWFekIJ0Ojb/jTFcG6hUtDnJOEkwnVUOHGxcOiV18YGagG6vn/auDTYz3hZFJuT8o5zXucZhCAAAQgUByBUoWT92bl8bCypFctotwat7wmrpIkUrkSbv46fC1LdYpLFHreIIBwgnDC7QABJwlYJZwcW5Md0X1B/v/27j9GjrO+4/jXnB2LNHHO+GLTYjc5IDa31xhMhUoJEVAUGhUCwWdjcoESVKAECZoWVFTp7BDf/dFKaRW1lKYRqoKoL73EZyJAqtRC0x/mh1qJkw68R4LBuCQBx3aUFDfq5WKu88yvfWb2mdlnfuzezO7bEq19N/PM87yeZzY7n32eZzsFH/HAJOv5SQ+7nb69xyZUCEaDTXBitcwmZXh1nHHSOte8x4dh6UzHNnrhTXMqy+apaaGJqmM8EAnqNSVNFdAE+7F0rFvcSmufmgmi7X0S7JvinpFWbnzmiGlslhmcJI1lZpzU8nWWSiOAQP8KdDU4MSzV8b7tJlia4wQowWwU/Ztw3NDEiVfU8hx1QlI5BCf9OzAr3DKCE4KTCg9PqoZAskClghN3eYK2aWjW4CTr+UFwEn7LirdUJFwqFLJFH/hby3C0r0fusPwkKNO8VMd0Tf9B3mZGR9vynta3xjRnJuXY3ln/23K0djgBQrhprDuTIvZNMx3CCXe/D22DVo/KC1PmJwzfmJM0OyV2bX0jV2+PD69e+jKb+OawiaFH0H/afifuUhnr4EQbD8GeJH5wEY6B+P46QQiWNHYTl5nFZkkljWWCE17OEUAAgUoJdC840ZbRjPlfE+zMGDns/DdszktDnO1OwvU70aU6sUDkhNoXxdnTZDE+48QNYA7LuB+whMfxdcSVGmP9VhmCE4KTfhvTtGdABKoVnDgPj9pX0bpdENkDJWEJjv7wmuV8/yHU/TpfZ+1G++aw/vXVcfpX5E4YvsUmbdZHZIlHp81htWvaLoVJCU68PTXCLyNubeIaW3bStrlranCiL3dRnRQseUmeUeIGDeHGqt7N1fLWQxt9GZL+FcnJX0ccLzvalvhsGq2c+NKm+FKc2Fc0B+PErXswBmyCE9PXVHcKBWNjLrwXCE4G5JWZZiKAQF0ESg1OIl9H7G/oqs8YCZfqeDrjdy7KogpRYsty1Oaw+x8akgP+brHj+5wdUZbGvT1S9G/uUYWo/U/8A8PjCE7qMvxqWU+CE4KTWg5cKo1AL4OTzNr6TIHMJzsnFD0/zzUH+Ry823s/wzKq1KGD7SDfWbQdAQQqLFBacFLhNhapGpvDFtHrz3MJTghO+nNk06q+F6hacKJ/qt95k9T27il6ft93eBcbqGZ+zIwteN+IxB9PoEBwwlhmECGAAALVFyA4Se8jgpPqj+Fe15DghOCk12OO6yFQikDVgpNSGkUhCCCAAAIIIIBADwQee+wx2bVrlwwNDfXgavW6xMWLF6XZbMrY2JhVxfM+UF9yySXG8rOUZ1VBDipFIEu/nDt3TjZt2uRe98ab9sq66958w+qDR+6XkZERq8qoAmyPta3Yn/3F38gnbr/N6vqmg64gOMltx4kIrKUAwcla6nNtBBBAAAEEEKizwOnTp+Wyyy6Tbdu21bkZXam7ema9cOGCbN++3ap82+dWVZj+QE1wYsVbmYPy9rMbnHx6/w2rn7iH4KQyvUlFEBggAYKTAepsmooAAggggAACpQqsrKzIqVOnZOvWrbJ582Zmnji6aqaJCjbOnz8vo6OjsmHDBivzvA/UBCdWvJU5KG8/E5xUpgupCAKDKUBwMpj9TqsRQAABBBBAoBwBFZ6cPHlSzp49K6urq+UUWuNS1q9fL8PDw7Jz507r0EQ1N+8DNcFJvQZL3n6u1FKdepFTWwQQKEvg0390e8ei0l7ksrwAdrwQByCAAAIIIIAAAggMnECW95Ms1anv8Mjbz5UJTupLT80RQKAXAgQnvVDmGggggAACCCCAwGAK5H2gZsZJvcZL3n52g5O9zuawf3Vkbfc4qRc3tUUAgV4LEJz0WpzrIYAAAggggAACgyOQ94Ga4KReYyRvPzPjpF79TG0RGFgBgpOB7XoajgACCCCAAAIIdF0g7wM1wUnXu6bUC+TtZ4KTUruBwhBAoFsCBCfdkqVcBBBAAAEEEEAAgbwP1AQn9Ro7efuZ4KRe/UxtERhYAYKTge16Go4AAggggAACCHRdIO8DNcFJ17um1Avk7WeCk1K7gcIQQKBbAgQn3ZKlXAQQQAABBBBAAIG8D9QEJ/UaO3n7meCkXv1MbREYWAGCk4HtehqOAAIIIIAAAgh0XSDvAzXBSde7ptQL5O1ngpNSu4HCEECgWwIEJ92SpVwEEEAAAQQQQACBvA/UBCf1Gjt5+7knwUm9KKktAghUVWDHjh3GqqkXQP4ggAACCCCAAAIIIFBEIOm9ZrzMc+fOyaZNm9wfE5wUEe/9uZUNTnpPwRURQAABBBBAAAEEEEAAAQQQ6I4AwUl3XHtRKsFJL5S5BgIIIIAAAggggAACCCCAwEALEJzUt/sJTurbd9QcAQQQQAABBBBAAAEEEECgJgIEJzXpKEM1CwUnH37zDaufOXK/jIyMWAmogWJ7rFWBHIQAAggggAACCCCAAAIIIIBADQQITmrQSQlVJDipb99RcwQQQAABBBBAAAEEEEAAgZoIEJzUpKMM1SQ4qW/fUXMEEEAAAQQQQAABBBBAAIGaCBCc1KSjCE7q21HUHAEEEEAAAQQQQAABBBBAoL4CBCf17TtmnNS376g5AggggAACCCCAAAIIIIBATQQITmrSUYZqFgpOrnM2h33wCJvD1rf7qTkCCCCAAAIIIIAAAggggEAvBAhOeqHcnWsQnHTHlVIRQAABBBBAAAEEEEAAAQQQCAUITuo7GAhO6tt31BwBBBBAAAEEEEAAAQQQQKAmAgQnNekoQzUJTurbd9QcAQQQQAABBBBAAAEEEECgJgIEJzXpqCoEJ/WlouYIIIAAAggggAACCCCAAAII5BfYtGmTe/Ill1xiLETNbOBPNQV27NhhVTE9ILvxpr2yLuvmsM8//7zVhTgIAQQQQAABBBBAAAEEEEAAgX4VSApO+rW9g9SuwsHJIGHRVgQQQAABBBBAAAEEEEAAAQQQGCwBgpPB6m9aiwACCCCAAAIIIIAAAggggAACGQQITjJgcSgCCCCAAAIIIIAAAggggAACCAyWAMHJYPU3rUUAAQQQQAABBBBAAAEEEEAAgQwCBCcZsDgUAQQQQAABBBBAAAEEEEAAAQQGS4DgZLD6m9YigAACCCCAAAIIIIAAAggggEAGAYKTDFgcigACCCCAAAIIIIAAAggggAACgyVAcDJY/U1rEUAAAQQQQAABBBBAAAEEEEAggwDBSQYsDkUAAQQQQAABBBBAAAEEEEAAgcESIDgZrP6mtQgggAACCCCAAAIIIIDAwAlMf+WUfPbrT8gzz60ktn340g3y/je8VO5+zysHzocGpwsQnDBCEEAAAQQQQAABBBBAAAEE+lbgk3M/cEKTx63bd/CdozL1jqutj+fA/hcgOOn/PqaFCCCAAAIIIIAAAggggMDACmy743jqTJM4zPCl6+XMPdevnVdzRvbcKnLkiMit6v8vTElj7WrDlR0BghOGAQIIIIAAAggggAACCCCAQN8KbPzII5nbtnzfW6LnBGGGHmKYfpb5SoYT0oIT9bs909KMnDYhs8uzMlHGtdeqjF765mgjwUkONE5BAAEEEEAAAQQQQAABBBCoh4BNcPKBN75MvnD8ibBBlQ5O+nEWSrdCqJKGKMFJSZAUgwACCCCAAAIIIIAAAgggUD2BTsHJ/R+6Vh75/nknOHkyd3AiM3tkz7Q/D6RxUBbUzJTI7JCGHFxYkKnYmpumfp6zIMc9RlKW6iQFDP7PJ8amZXren4GSeP15mdw4KfNBa1V948uC9OuYyvHr6F3PK2hidllm3Wkv0fInZhek4bSzOaX/fkYaukfajBO/bsZrJbQx4hr0R4GhSXBSAI9TEUAAAQQQQAABBBBAAAEEqi2gByc3v3arPPydp8IKm0IT9ctMM07Ug/2epkz5y2XmJydFJQjzG+dlIlhCYzOjYn5SNjqhx/LUUvIeJ0lLdRYaTnYzLWOR8MJ0/b1ybI8WYiQtCwrrOyYzpna4bdaup+o+03ACo1j5gXTQNpWs6H8Pft8pODFeK61u8f4otpSJ4KTa9zi1QwABBBBAAAEEEEAAAQQQKCCgBye3OUty3vSqzfLBz39PkkKTzMHJgnqAVzM4tL1GbPciiR+nz/4wbQ7bYcZJuJFs4vUTAp2kGSd+QNK2p4oKavQlQx03tFWzULwgx/mLzE8Es0/8ju0UnCRdy7jfi2pjrD8KjB91KsFJQUBORwABBBBAAAEEEEAAAQQQqK5AfKmOCk/uvPkV8pmHT0aW5+gtyDTjJNwwNlii4gQo8WDBxOOGG06YECxZiYcPRYMT414orQDDXVXTacZJ0jf7xIOOjsGJmmiiAhMVnGgzYQKXvMFJ6n4vWn8U3DyX4KS69zc1QwABBBBAAAEEEEAAAQQQKChg2uNEfeXwM8+9kFhyW3Di7tsR3ZfD3UejOeUurZk8tldm3Q1Mms6SGfU0PyXNPWrJTmxmhX7FWFjglucs1Qn3GykSnPj7jLRfX9UvYamOttworIs/m6atnKTgJGmpThDSODNEnI1cZKF9sxdveZLpW4sS91/xZvqY6tbeH+37y2QZVgQnWbQ4FgEEEEAAAQQQQAABBBBAoFYC2+447oQkK9Z1VqHKmXuubz/etKzGfdCPbobaCIKBxONbRatZGM4EDPdPY8KZA7LUkCNBUFAoOFEZTuyri42b1qoLe5vZ6hvchnVp2+TWP956M1l909ggVDKEGG1Li7RZOxmu5bUlWDrlu5qCGuvR4B1IcJIRjMMRQAABBBBAAAEEEEAAAQTqIzDz1R/L9JdPWVf442/dLncfuMb6+FofaLNpbVkNDDeQVWFTvf4QnNSrv6gtAggggAACCCCAAAIIIIBARoFPzZ2UL37rZ6kzT4Yv3SAqNJm66eqMpdf48B4GJ94eJylLlyrMSHBS4c6haggggAACCCCAAAIIIIAAAgggsLYCBCdr68/VEUAAAQQQQAABBBBAAAEEEECgwgIEJxXuHKqGAAIIIIAAAggggAACCCCAAAJrK0Bwsrb+XB0BBBBAAAEEEEAAAQQQQAABBCosQHBS4c6haggggAACCCCAAAIIIIAAAgggsLYCBCdr68/VEUAAAQQQQAABBBBAAAEEEECgwgIEJxXuHKqGAAIIIIAAAggggAACCCCAAAJrK0Bwsrb+XB0BBBBAAAEEEEAAAQQQQAABBCosQHBS4c6haggggAACCCCAAAIIIIAAAgggsLYCBCdr68/VEUAAAQQQQAABBBBAAAEEEECgwgIEJxXuHKqGAAIIIIAAAggggAACCCCAAAJrK0Bwsrb+XB0BBBBAAAEEEKidwMrKijz55JOyvLwsFy9erF39u1Hhyy+/XLZt2yYbNmywKh5DKyb3IGztrZKOxLC4YZES8C+iV+65WfsiuDrBSbn9QGkIIIAAAggggEBfC6gH/lOnTsnIyIj7vxe96EV93V6bxv3iF7+Qp59+Wp566ikZHR3tGJ5gaKPqHYOtvVXSkRgWNyxSAv5F9Mo9N2tf6FcnOCm3LygNAQQQQAABBBDoa4HHH3/cnQGwZcuWvm5nnsadOXNGLly4IFdddVXq6Rhm18U2u1n8DAyLGxYpAf8ieuWea9sXBCflulMaAggggAACCCAwMAJLS0vSaDRkaGhoYNps21C1bOnRRx+VnTt3pp6Coa1o6zhss5vFz8CwuGGREvAvolfuubZ9QXBSrjulIYAAAqUJTH/llHz260/IM8+tJJY5fOkGef8bXip3v+eVpV2XguwE6B87p7oeRf/a9Zx66L/22mvtDh7Ao7773e/K2NhYx+AEw+yDA9vsZvEzMCxuWKQE/IvolXuuTV8QnJRrTmkIIIBAKQKfnPuBE5o8bl3WwXeOytQ7rrY+ngOLCdA/xfyqfjb9a99DBCfpVjZvxjG0H2/6kdjmc8OwuFtZJTCGy5IsXo5NXxCcFHemBAQQQKB0gW13HE+daRK/4PCl6+XMPdeXXg/rApszsudWkSMLU9KwPqlLB/agLrXrny5RZy62B32TuU6GE2rRv3kt856XAFvJh/4Th2X3LSIPLB6S8TIGRIEybN6Md9WwQhYFGI2nds22G2bdKLME0K4ZllC3XEVU1DmpLX3nn6vTqnGSTV8QnFSjr6gFAgggEBHY+JFHMoss3/cW8znzk7Jxcr71u4lZWZ6dyFx+6gllPIypMvZMSzNWv/nJjTK5dFAWbEOZMurSQafU/pGmzOzZI9Ni2cY87Qtsw3Y15ODCgkz1IuXS65un7vG+KKOMXvRvWeZJ7c3rkPc8m+BEPbTsvktOhMeOy52Li3KoF+mF/sBUxsNTGWU4DjZvxsPgpKRrRroqpcwTh3fL7ru03rpzURZ70ll+DQu2N5Otafy2jdd9MndxTvbZ1CvtmFi548p1Yr4yYZ5OkcmwzUuV1OV7vE+cSwlOquRvrItz/yyOy+EgtE7qO8O5++Yuyty+Dv9htrkvC7yztbkXCE4KAHMqAggg0C0BmwfzD7zxZfKF40+EVTAFJ82ZPbJnekxml2cliErmJydFZlv/LqUNZTyMuWU0ZUyczSaP+A/17s9U6DNhP5uljLqU8GBt0z/uZUztTrt+nvbFz3Ef6psypY2LUsaBqZCyg5OuVbRVcCn3X7fN84yDcLyVNzssMlsi/sbWfYN8Qg6ph9Fu91vZwUlJ9bV5M74WwYkbmhzdJ4vhrJwTcvjAvEzM9XCWTsEHoUy2ScGJPjPp6AEZOjwuiw+I3NJpxlJi3Y/KgaHDMh4Ghs6/D4jMHWr2R3DSyaWk+yYspk+cSwtOquJvc++mBSd6O/wgZaxTeGJzzQLjz+b1hOCk7xNBxgAAEO1JREFUADCnIoAAAt0S6PTgdv+HrpVHvn/eCU6eTAlO1EwGd/2MeWZB5BPxCS9cCR/i52W+6cQVswvScMKXaffvyzI7FoQb3u/Vn9bP/YexSLnBzIZ5mdw4KUsHF2RBTXNwj3HepOuzHvwHwSnnk7kZOeIep2abzDcOypKTnbjLgEx1Dh4G1WyVQMM5x52hYqyLurwKlPyjg2MzdGY5/eNdUNXlVqe9U809MtPQfPSlT+FD8l45pmanhFV3jt97zJup4/VGJCQLm9T2kK36w/EPghNrJ+/6zSlnLLhJnCpnRhpHJ2T+kHP1sWmZ9ic3ueNiwp9NE9T3ox8V+fcrDce5EFo7WjNi2vrqiMitrk3UIjIWQ498M2tK6d+yzMP2xsez02I1dvXfB/eCP3acF4DWOHcW0bmzjJy7K1hWF/l9jvtAXS41OBH1EPmQ7A+Ck8gnja1PqiMzH8bvdB7mnfG0e7ecOBR8Cuk/jH5pnxydEtk3dpfcddQb3d4nlc5Dv3N8MHli/GO3i/zbVsNxzgm2dQgfnr26aBMzvGuO6bNrkj91t3kz3jE4idTZnxXhNkWfMaLVIf6JrmuqByLxh/vYi1+CUdROn51xwgm8j8pRZ/LKvrlFGXfqpbzCT5GN5aX1mSr7kDRNY0CbwZTJ1vT63vYg5o/X+Kfm4SyqwD5W98hMndiYD67rX6t97Cb0o6jlZi3X1ljPMIYtlqplMkwNMQ7IUuDg9vdR2eferzZtiM708YxaYyC8r2vsnPT2orb+HUOR6OumO+sqmM1mOlf7mfNirs2EC17X2u+5B+QWw3EZ3sjFDrXpC/2Uc+fOyaZNm9wf3XjTXll33ZtvWH3wyP0yMjKSvxaciQACCCCQWUB/cLv5tVvl4e88FZZhCk3UL9tmnKTOKvCCDOcp230Adh9Om1OyPLXUCjSW1BKfJe9hS/19puE9pOmBh7sMyClmoSEz7sPamMzEH8iDACCsz5QsmQKd8EHTLyMoM3wwVD831HlWIm3xZnCk1MVtQ2u2RZ4ZOKX0j9ujWrgVGAeBjzE48R+ew98l9GN8KVb8IV71m+pPd/mTIURR5Sc5qXPnJ7zlXsHf3XEzLWP+eHJ/HpQfn3FiPC5h3Jjq4ARq3ljT9tMJr5cy/jLchaX0b1nmYXuj4z8c5ynBSWQllt5Xaf2bwUkdmhqcBJ/guw9whhBFfeqoAgptVspR9+N5Z4aKOveh/XJRzd8O/q4+tXceYsNPJvXy4zNOjMc15HA8yEmqg/MmP5xyHpiE10sox/CgavNmPD04UW7KxAuR3LDkxCHPRf8TeknkeDfsiH9KnfrJbUI/Lao2G+rh9onzkKwCjSWnzw4secuz1N/V7A33vFh4ZprKb/rU2TQGtHZnsjWN65hDOAsnDM0S2ux1ROIMkqMHhuSACvb2zbX6Kd6+yL2hVS4y1n1XtdRN/dzl3y8P2Y5hdR91uJ8zGRqWWEgQyoWzy1Tg5XawHFLhTzA22tqQNJa0+1vVvU+ck7qhtv6mseCMNuulOm0zZxICR/01IO11Sz8u43/DgsNt+kIvmuAkJzSnIYAAAmUL6A9utzlLct70qs3ywc9/T5JCk8TgJGnD1qRlBGEAEntAD46PP6TFZhx4D9vazA8XpjULIpg90AhmnuhwWp2W1L4mzsyFyGwW0wOiCkD0OrtZhB+cJNbF+STECWCc+Rbm2RkWnVlK/+h1DQMMZ/ZGbFaA+/CbtNwlZTnImDbboKFmetx7b/uMnKBsY58lObWCFiexkvmJYCaSFmZkqW/4EG8aN4Y6GNvsz15SsylSxp9F17qHlNK/kRk0TqH6jI7478L7JKW9SQFJWnBiqkMsiCxyH6hqtwUn+h4n+kyHpDfa7oPgASdWac2k8Pqp9UbaSQLkof3+LI/4FO+kh3DTcW5Io+/Boq6jrmuoQ/xNevApugoF3AdCUzntD6o2b8ZTgxNjPfzlT6aZJfFlJh2DE+2TXNVfSUb6LAzFFjwoJ+1pEFw30Ty2l4jxocgwBrQkIJOt6eZPmpmj171tSYFm32nZhBt2OAmKClDiS3UMQV+420zQD5HytVlX77YcwxYveJkMUwO31syZcHaBcUaPs4zJnzkWbt5sGktB3Ttc03upqL5zUlfU1r/jjBMnLLc5JoTRgpNO92UQUCcdZzHuTYfY9IV+HsFJTmhOQwABBMoWiC8VUOHJnTe/Qj7z8MnI8hz9uu17nPjLKEybgHYzOEn7dh1/o9pOwYm3xMafFZIU2gTHpAUnqd/0483WyPPgWE7/xJYM+Z3p2qjlNzYzTlKCk8j2v22zPrT9TdqWlMRHc7uTu4TK2cRXpVvuch9TPfSZRqa/q8skBnIpdYj0t7cUKFw61LEtdndqKf1blnnbzCt/pk3afRGGUdpyuNTwM999oDQTZ5yEn0D7YULHByBvZoUeoKhP7h/aP+dMofBnLJhChKzBSerDrlaHSFDghQvh0qGObWmNM5s347mCE1U//dP8tId946e7+j4cfhASzL4xGSUFODbBSZJ5PDwwHNc2BrRbOJNtUnCS1lZTCBXMjrIeA4blP0HwFM520maWJPWjGyQaQoe2drXfR2mvepkMO7XZDzB6Hpx46Ym3LNAU8FXAuRfBSRAg9cTfJhSxOSaAiQSthvtBhSVtYWPCcXb/mW87yuZeIDjJictpCCCAQDcFTHssqK8cfua5FxIvm21zWO+TbeNSnbQH3vin28ESiYTlNNHKBjMV1LX9mRX6WoKkh97I0pukpTqt8txZLc5SkgV32VDr+LAuTnmTx/bKrPuVMh32gUnQLqd/Yg/96lq6p7acqNWmYJ+LIPgosFTHpVGbBEfLsHLyZzI467hae9akBT3xECxYZpPQt6l1OOztp6KW6rh7dKglZuHSpIS2ZLxZS+lf01KdPOZhe9V4Nozz2HKmcKzE7tW2nzu/nyl4HyjWjkt13Bn5KjyJLjkJu8R5M3zAuV/n3PXvKqDwp/m7//RmdjhrP7z18Z2Ck6SH2vC86NKL1DrMePupqE/F3TX3keUxCW0xjDObN+O5lurEZjC0NntVbWyFIu2bwHqVbPt5J6NY/4VLhvR6GIOQBHOvEq3Ng9MesvQxoBlnsjW9BnR8sOuwVMe08bEq83BDFoMlRZ0CrVg4075cyN+bJrJMrLXMxeo+Snn9y2SYGpwEMwbU7C1//Ln7tGhfC57QBuNYCuocD2D1n1fJ2Z2Fpm2EbQqODeOl1v6dAta0vmubTeWPabV3lPa7yOtUyutF4nHx1xnTv/0xZdMX+q3EjJOMb6w4HAEEEOiWwLY7jjshyYp18SpUOXPP9cbjI5trqiOCr/uNTOPXN4fVNmKNhyhty18SzmvbqDUWYgR7o+jf6tIxOEnZHFb7yuXGhDPXYqlh2EzWabu7XMKrS/AFzcbZLx3kS+kfY3tbs4T2Hmtt7Blpk1M39yuanQaEs1Mybw4bzHaR1oahCX1mdooFTmkzTvT6+pvDhvuTtM3KiG/wa+ircDZO9HfhkrC0JTKWd1S3+te7FzOa67OPEsa5vsmrPlaCJW+q2eHP25bqeCh57gN1XvrmsMH0fZV9GJa4uEt5vIdTf69XZ8sE/StxDUFK0lIdpy7B3hLB5rCRpQD6zJS25USGOoRfHxv9nbe0x19mkrQsSRtnNm/GI8FJZAmQ6VqtJU3hXhrO9cb3OWtYlsbdoGc8WLoQ/3ls/Cd+HXHaVPn4RqlJs0baPh3WlpdoS7gS+yysa2wM5LU13fsdgxP/U+62zWG9wsK6t41ZfTNhf3PLeIigXXsp2BNF76+2JU7aUjZj/6TdR8kvfMXGpypXte+QnNithTnBfizurCh9WVFSG9K/BroWzp2CkoQQobb+NvdO0j0SH7+xr7ROfF2LlXfoxG5vL6H461wX+0K/kwhOLN9QcRgCCCDQbYGZr/5Ypr98yvoyH3/rdrn7wDXWx+c+sKSlELmvX5ETK9s/vfKJbC7bq4v27joD378ZqCPBSYbzrA5N2kDT6uRqHJTpwagaVa5WLVLGQF/bdloWU1IvddWwR20oRLHGdRx4/0KdV+7JNn1BcFKuOaUhgAACpQl8au6kfPFbP0udeTJ86QZRocnUTVeXdt3UgghOQp5K9k9vRoH3NdFqU9jIRio9uniPLjPI/ZuFuJvBibe/RfCVxFlqVZ1jbd6Md9OwOhL5apI2BvratkcP9F017FEb8o0s/6w1ruPA+xfqvHJPtukLgpNyzSkNAQQQQAABBBAYGIHHHntMdu3aJUNDQwPTZtuGXrx4UZrNpoyNjaWegqGtaOs4bLObxc/AsLhhkRLwL6JX7rm2fUFwUq47pSGAAAIIIIAAAgMjcPr0abnssstk27ZtA9Nm24aqNfAXLlyQ7du3p56Coa1o6zhss5vFz8CwuGGREvAvolfuubZ9QXBSrjulIYAAAggggAACAyOwsrIip06dkq1bt8rmzZuZeeL0vPr0Ur0RP3/+vIyOjsqGDRtSxwOG9rcLtvZWSUdiWNywSAn4F9Er99ysfUFwUq4/pSGAAAIIIIAAAgMloB78T548KWfPnpXV1dWBarupsevXr5fh4WHZuXNnx9AkOB9Du2GDrZ1T2lEYFjcsUgL+RfTKPTdPXwQ14Ft1yu0LSkMAAQQQQAABBBBAAAEEEEAAgT4SIDjpo86kKQgggAACCCCAAAIIIIAAAgggUK4AwUm5npSGAAIIIIAAAggggAACCCCAAAJ9JEBw0kedSVMQQAABBBBAAAEEEEAAAQQQQKBcAYKTcj0pDQEEEEAAAQQQQAABBBBAAAEE+kiA4KSPOpOmIIAAAggggAACCCCAAAIIIIBAuQIEJ+V6UhoCCCCAAAIIIIAAAggggAACCPSRQFtw8vrrf2v1vs/9pezaeU0fNZOmIIAAAggggAACCCCAAAIIIIAAAtkFguDk3Pmn5b3vu03WveZ1163edehP5Ma33ZC9NM5AAAEEEEAAAQQQQAABBBBAAAEE+kggCE6+/Z//JZ/69JSse9WrX7f60d+7TW7//Q/1UTNpCgIIIIAAAggggAACCCCAAAIIIJBdIAhO/n52Tu7563tl3a+8fGz1laNXyezsrFw5/EvZS+QMBBBAAAEEEEAAAQQQQAABBBBAoE8EVHDy8wv/Kx/52Cfk5KnTsm5kxzWrL3nbH8h9vy3ym+/6cJ80k2YggAACCCCAAAIIIIAAAggggAAC2QVUcPLn93xWvvqP/yRPP/s/Kjh52+qHP/enct26J2Xjxo0yOjoqL37xi7OXzBkIIIAAAggggAACCCCAAAIIIIBAjQV++rMz8oUvzsp/fPPb8sRPz8iq05Z1VzozTladv61bJzJ8xeXyy9sa8seH/1B+dehZufylL5eRLVtq3GSqjgACCCCAAAIIIIAAAggggAACCCQLnDt/Xk6e/JGc/OEP5YEH5+WnZ56SZ579uReaqP+ppTruv7z/I5dseIW8zwlORv71sMw/ulHWDw05v3F+N/Lrcsu7fk2u+O/jcu8//7Dtile+7t0yMbzY/rstr5X3uud9Q/72a+3nVbvzXiK/sfft8uor/Fo+e0K+dOw7clavtNO+A+8clyt+8k25r0j7PP4++NM3DalWX2x5jUy8vSFXPP5t+bt/+VG16ubW5uVyw+++XnbEavaTb8xK+HJRsA2VHVkvebVM/M6YbIq3/Zv/IF+rYldVcPRQJQQQQACBwRVQDyT8QaA7Aj0YXT24RHdsKFUXWOdEIysvvCD/t7wsy8sr7t4mz6+s+Ic4v3X6+f8BFlW4p/DJqnAAAAAASUVORK5CYII=" /> <img alt="image.png" src="data:image/png;base64,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" /></p>
</section>
</section>
<section id="Fitting-Mode-Shapes-to-FRF-Data">
<h2>Fitting Mode Shapes to FRF Data<a class="headerlink" href="#Fitting-Mode-Shapes-to-FRF-Data" title="Permalink to this heading"></a></h2>
<p>Once the poles and participation factors are known, we can go ahead and fit the mode shapes of the system. Looking again at the frequency response function equation</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\left( \frac{v_{ir}l_{jr}}{j\omega-\lambda_r} + \frac{v_{ir}^*l_{jr}^*}{j\omega-\lambda_r^*}\right) + \frac{R_{Lij}}{(j\omega)^2} + R_{Uij}\]</div>
<p>containing the frequency response function <span class="math notranslate nohighlight">\(\mathbf{H}\)</span>, the participation factors <span class="math notranslate nohighlight">\(\mathbf{l}_r\)</span>, the frequency lines <span class="math notranslate nohighlight">\(\omega\)</span>, and the poles <span class="math notranslate nohighlight">\(\lambda_r\)</span>. We wish to solve for the mode shapes <span class="math notranslate nohighlight">\(\mathbf{v}_r\)</span> and the residuals <span class="math notranslate nohighlight">\(\mathbf{R}_u\)</span> and <span class="math notranslate nohighlight">\(\mathbf{R}_l\)</span>.</p>
<p>We want to pose this problem in an entirely real set of equations <span class="math notranslate nohighlight">\(\mathbf{A}\mathbf{x}=\mathbf{b}\)</span>.</p>
<p>The mode shapes will generally be complex <span class="math notranslate nohighlight">\(\mathbf{v}_r = \mathbf{v}_r^R + j \mathbf{v}_r^I\)</span>, so we will want to solve simultaneously for the real and imaginary parts. Similarly, the frequency response function is complex, so we will need to split that up into its real and imaginary parts. Ignoring the residuals for now:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\mathbf{H}^R\\\mathbf{H}^I\end{bmatrix} = \mathbf{P}\begin{bmatrix}\mathbf{v}^R\\\mathbf{v}^I\end{bmatrix}\end{split}\]</div>
<p>The goal is to then find the coefficient matrix <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> which allows us to solve for the mode shape coefficients.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf{P} = \begin{bmatrix}\mathbf{P}_{RR} &amp; \mathbf{P}_{RI}\\\mathbf{P}_{IR} &amp; \mathbf{P}_{II}\end{bmatrix}\end{split}\]</div>
<p>We will start with the term</p>
<div class="math notranslate nohighlight">
\[\frac{\mathbf{v}_r\mathbf{l}_r^T}{j\omega-\lambda_r} + \frac{\mathbf{v}_r^*{\mathbf{l}_r^*}^T}{j\omega-\lambda_r^*}\]</div>
<p>We will substitute each term with its real and imaginary parts to ensure that all of the variables in the expression are real.</p>
<div class="math notranslate nohighlight">
\[\frac{\left(- j l^{I}_{jr} + l^{R}_{jr}\right) \left(- j v^{I}_{ir} + v^{R}_{ir}\right)}{j \lambda^{I}_{r} - \lambda^{R}_{r} + j \omega} + \frac{\left(j l^{I}_{jr} + l^{R}_{jr}\right) \left(j v^{I}_{ir} + v^{R}_{ir}\right)}{- j \lambda^{I}_{r} - \lambda^{R}_{r} + j \omega}\]</div>
<p>As we wish to collect real and imaginary parts, we will want to multiply each term’s numerator and denominator by the denominator’s complex conjugate.</p>
<div class="math notranslate nohighlight">
\[\frac{\left(- j l^{I}_{jr} + l^{R}_{jr}\right) \left(- j v^{I}_{ir} + v^{R}_{ir}\right) \left(- j \lambda^{I}_{r} - \lambda^{R}_{r} - j \omega\right)}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{\left(j l^{I}_{jr} + l^{R}_{jr}\right) \left(j v^{I}_{ir} + v^{R}_{ir}\right) \left(j \lambda^{I}_{r} - \lambda^{R}_{r} - j \omega\right)}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\]</div>
<p>We would then like to collect real and imaginary terms, as well as collecting terms that have the real and imaginary part of the mode shapes. <span class="math notranslate nohighlight">\(\mathbf{P}_{RR}\)</span> will contain real coefficients of the real part of the mode shapes. <span class="math notranslate nohighlight">\(\mathbf{P}_{RI}\)</span> will contain real coefficients of the imaginary part of the mode shapes. <span class="math notranslate nohighlight">\(\mathbf{P}_{IR}\)</span> will contain imaginary coefficients of the real part of the mode shapes. Finally, <span class="math notranslate nohighlight">\(\mathbf{P}_{II}\)</span> will contain imaginary coefficients of
the imaginary part of the mode shapes.</p>
<div class="math notranslate nohighlight">
\[j v^{I}_{ir} \left(\frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega + l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\right) + v^{I}_{ir} \left(\frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} + l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\right)\]</div>
<div class="math notranslate nohighlight">
\[+ v^{R}_{ir} \left(\frac{- l^{I}_{jr} \lambda^{I}_{r} - l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\right) + j v^{R}_{ir} \left(\frac{- l^{I}_{jr} \lambda^{R}_{r} + l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\right)\]</div>
<p>We can substitute this into a matrix form where the real equations are on the top row and the imaginary equations are on the bottom row.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{matrix}H_r^{R}\\j H_r^{I}\end{matrix}\right] = \left[\begin{matrix}\frac{- l^{I}_{jr} \lambda^{I}_{r} - l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} + l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\\j \left(\frac{- l^{I}_{jr} \lambda^{R}_{r} + l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\right) &amp; j \left(\frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega + l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\right)\end{matrix}\right] \left[\begin{matrix}v^{R}_{ir}\\v^{I}_{ir}\end{matrix}\right]\end{split}\]</div>
<p>Cancelling out the <span class="math notranslate nohighlight">\(j\)</span> terms in the bottom row reveals the final matrix equation for the contribution to the frequency response function from one mode shape <span class="math notranslate nohighlight">\(H_r\)</span>.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{matrix}H_r^{R}\\H_r^{I}\end{matrix}\right] = \left[\begin{matrix}\frac{- l^{I}_{jr} \lambda^{I}_{r} - l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} + l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\\\frac{- l^{I}_{jr} \lambda^{R}_{r} + l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega + l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\end{matrix}\right] \left[\begin{matrix}v^{R}_{ir}\\v^{I}_{ir}\end{matrix}\right]\end{split}\]</div>
<p>We can then solve this equation in a least squares sense by using the pseudoinverse.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{matrix}v^{R}_{ir}\\v^{I}_{ir}\end{matrix}\right] = \left[\begin{matrix}\frac{- l^{I}_{jr} \lambda^{I}_{r} - l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} + l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\\\frac{- l^{I}_{jr} \lambda^{R}_{r} + l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega + l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}}\end{matrix}\right]^+ \left[\begin{matrix}H_r^{R}\\H_r^{I}\end{matrix}\right]\end{split}\]</div>
<p>Note that this equation must be generalized to solve for all modal coefficients simultaneously in terms of all frequency response functions for all degrees of freedom at all frequency lines. For this we will give some thought as to how to structure the matrices.</p>
<p>At the end of the computation, the matrix <span class="math notranslate nohighlight">\(\left[\begin{matrix}v^{R}_{ir}\\v^{I}_{ir}\end{matrix}\right]\)</span> should have real and imaginary parts for each degree of freedom for each mode being solved for. We will solve for these terms over all frequency lines simultaneously. However, because there is no frequency line dimension in the mode shape matrix, this reveals that the frequency line must be on the inner dimension of the matrix product. The frequency lines must correspond to the rows of
<span class="math notranslate nohighlight">\(\left[\begin{matrix}H_r^{R}\\H_r^{I}\end{matrix}\right]\)</span> and <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> (which will be the columns of <span class="math notranslate nohighlight">\(\mathbf{P}^+\)</span>). We also see that the columns of the FRF matrix corresponding to the references at each frequency line do not appear in the final mode shape matrix (they are related to the participation factors, which are known). Therefore this dimension must also be encoded in the inner dimensions of the matrix product.</p>
<p>We can therefore start to envision what the structure of each term in <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> should look like. The columns of <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> (the rows of <span class="math notranslate nohighlight">\(\mathbf{P}^+\)</span>) must correspond to the mode shape matrix, and they should correspond to the mode index rather than the response degree of freedom index because we need matrix multiplication of <span class="math notranslate nohighlight">\(\mathbf{P}\mathbf{v}\)</span> to sum over modes, and summation occurs on the inner dimensions of the matrices in matrix multiplication. The rows of
<span class="math notranslate nohighlight">\(\mathbf{P}\)</span> (the columns of <span class="math notranslate nohighlight">\(\mathbf{P}^+\)</span>) must correspond to both the mode participation factor (reference degrees of freedom) and frequency lines, separated into real and imaginary parts. If we compute each partition of <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> as a <code class="docutils literal notranslate"><span class="pre">num_input</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">num_freq</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">num_modes</span></code> array, and then reshape it into a <code class="docutils literal notranslate"><span class="pre">num_input*num_freq</span></code> <span class="math notranslate nohighlight">\(\times\)</span> <code class="docutils literal notranslate"><span class="pre">num_modes</span></code> array, this should produce the correct size matrix.</p>
<p>Each partition of the mode shape matrix <span class="math notranslate nohighlight">\(v^{R}_{ir}\)</span> and <span class="math notranslate nohighlight">\(v^{I}_{ir}\)</span> will then be revealed as a matrix with number of rows equal to the number of modes and columns equal to the number of response degrees of freedom.</p>
<p>We can similarly construct the dimensions of the partitions <span class="math notranslate nohighlight">\(H_r^{R}\)</span> and <span class="math notranslate nohighlight">\(H_r^{I}\)</span>, as they must now be consistent with the rest of the terms in the equation. The number of rows of these partitions must match the number of rows of partitions in <span class="math notranslate nohighlight">\(\mathbf{P}\)</span>, meaning that the FRF must be similarly structured with mode participation factor (reference degrees of freedom) and frequency lines along its rows and response degrees of freedom along its columns.</p>
<p>This generalization into matrix form can be somewhat abstract to visualize, but should become more obvious when applied to real data arrays.</p>
<section id="Fitting-Residuals-for-Out-of-Band-Modes">
<h3>Fitting Residuals for Out-of-Band Modes<a class="headerlink" href="#Fitting-Residuals-for-Out-of-Band-Modes" title="Permalink to this heading"></a></h3>
<p>We note that the terms <span class="math notranslate nohighlight">\(v_{ir}\)</span> are not the only unknowns in the frequency response function formulation. In general, we can never fit all of the modes of a structure, so there will always be some contributions from out-of-band modes in our frequency response functions. As we try to solve for the mode shapes of the structure, these out-of-band modes can contaminate the response. Therefore we also include terms to try to match the contributions from these out-of-band modes, and we call
these terms residuals.</p>
<p>We will in general have a lower residual <span class="math notranslate nohighlight">\(R_{Lij}\)</span> and an upper residual <span class="math notranslate nohighlight">\(R_{Uij}\)</span>, and as the expression suggests, there can be one term in the residual for each pair of input and output degrees of freedom. We must therefore solve for these terms simultaneously with the mode shapes. We can think of these terms as “extra modes” of the structure, which therefore should imply that the <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> matrix should have columns added corresponding to the coefficients of the residual
variables, and the <span class="math notranslate nohighlight">\(\left[\begin{matrix}v^{R}_{ir}\\v^{I}_{ir}\end{matrix}\right]\)</span> matrix should have rows appended corresponding to the real and imaginary parts of these terms.</p>
<p>Indeed, the coefficients are easily picked directly from the frequency response function.</p>
<div class="math notranslate nohighlight">
\[\mathbf{H}_{ij} = \sum_{r=1}^N\left( \frac{v_{ir}l_{jr}}{j\omega-\lambda_r} + \frac{v_{ir}^*l_{jr}^*}{j\omega-\lambda_r^*}\right) + \frac{R_{Lij}}{(j\omega)^2} + R_{Uij}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\left[\begin{matrix}H_r^{R}\\H_r^{I}\end{matrix}\right]
= \left[\begin{matrix}\frac{- l^{I}_{jr} \lambda^{I}_{r} - l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} + l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; -\frac{1}{\omega^2} &amp; 0 &amp; 1 &amp; 0 \\
\frac{- l^{I}_{jr} \lambda^{R}_{r} + l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{R}_{r} - l^{R}_{jr} \lambda^{I}_{r} - l^{R}_{jr} \omega}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; \frac{- l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega - l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} - 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} + \frac{l^{I}_{jr} \lambda^{I}_{r} + l^{I}_{jr} \omega + l^{R}_{jr} \lambda^{R}_{r}}{\left(\lambda^{I}_{r}\right)^{2} + 2 \lambda^{I}_{r} \omega + \left(\lambda^{R}_{r}\right)^{2} + \omega^{2}} &amp; 0 &amp; -\frac{1}{\omega^2} &amp; 0  &amp; 1\end{matrix}\right] \left[\begin{matrix}v^{R}_{ir}\\v^{I}_{ir}\\R^R_{Lij}\\R^I_{Lij}\\R^R_{Uij}\\R^I_{Uij}\end{matrix}\right]\end{split}\]</div>
<p>When generalizing to multiple references, responses, and frequency lines, each residual term <span class="math notranslate nohighlight">\(R^R_{Lij}\)</span>, <span class="math notranslate nohighlight">\(R^I_{Lij}\)</span>, <span class="math notranslate nohighlight">\(R^R_{Uij}\)</span> and <span class="math notranslate nohighlight">\(R^I_{Uij}\)</span> will have a number of rows equal to the number of references and a number of columns equal to the number of responses. Similarly the coefficient terms (<span class="math notranslate nohighlight">\(0\)</span>, <span class="math notranslate nohighlight">\(1\)</span>, <span class="math notranslate nohighlight">\(-\frac{1}{\omega}\)</span>) will have a number of rows equal to the number of <code class="docutils literal notranslate"><span class="pre">num_freq*num_input</span></code> and number of columns equal to <code class="docutils literal notranslate"><span class="pre">num_input</span></code>. Because
of the structure of the matrices, they are easily constructed using Kronecker products of identity matrices multiplied by either <span class="math notranslate nohighlight">\(1\)</span> or <span class="math notranslate nohighlight">\(-\frac{1}{\omega^2}\)</span>.</p>
</section>
<section id="A-Note-on-Types-of-FRFs">
<h3>A Note on Types of FRFs<a class="headerlink" href="#A-Note-on-Types-of-FRFs" title="Permalink to this heading"></a></h3>
<p>Note that the mode shape derivations described in the previous sections are valid for <em>receptance</em> FRFs, meaning FRFs between displacement and force. When transforming to from <em>receptance</em> to <em>mobility</em> (velocity over force) to <em>accelerance</em> (acceleration over force) FRFs, we multiply the FRF expression by <span class="math notranslate nohighlight">\(j\omega\)</span> at each step. This will clearly change which terms are real and which terms are imaginary, as well as the coefficients on each term. As this document is already quite long,
these will not be derived, but the same approach as described above can be used to find the coefficient matrices for those cases; simply substitute for real and imaginary parts of each variable, collect imaginary and real coefficients for imaginary and real parts of each term of interest, and place them into a matrix form.</p>
</section>
<section id="Normalizing-Mode-Shapes">
<h3>Normalizing Mode Shapes<a class="headerlink" href="#Normalizing-Mode-Shapes" title="Permalink to this heading"></a></h3>
<p>Once we solve for the mode shapes, our job is not quite done. Due to how the problem is formulated, the particpation factors have some arbitrary scaling and rotation applied to them. This means when the shapes are found, they will also have an arbitrary scaling and rotation applied to them. There is no constraint that the participation factors are identical to the mode shapes at the input locations.</p>
<p>To perform the normalization, we compute the residue matrices for each mode</p>
<div class="math notranslate nohighlight">
\[R_{rij} = \psi_{ir}l_{jr}\]</div>
<p>We recognize the at the drive point, the residue is equal to the mode shape squared or the participation factor squared if the mode shapes are scaled such that the participation factors are the mode shapes.</p>
<div class="math notranslate nohighlight">
\[R_{rii} = \psi_{ir}l_{ir} = \psi_{ir}^2 = l_{ir}^2\]</div>
<p>However, we currently do not have such a scenario. In our case, the fit shapes <span class="math notranslate nohighlight">\(\bar{\psi}_{ir}\)</span> are scaled by some complex coefficient <span class="math notranslate nohighlight">\(c\)</span>, and the participation factors <span class="math notranslate nohighlight">\(\bar{l}_{jr}\)</span> are scaled by some factor <span class="math notranslate nohighlight">\({\frac{1}{c}}\)</span>.</p>
<div class="math notranslate nohighlight">
\[\psi_{ir} = c\bar{\psi}_{ir}\]</div>
<div class="math notranslate nohighlight">
\[l_{jr} = \frac{1}{c}\bar{l}_{jr}\]</div>
<p>We note that due to the reciprocal scale factors, we can still compute the residuals. We can therefore set up a set of equations to solve for the scale factor that gets applied to the mode shapes.</p>
<div class="math notranslate nohighlight">
\[R_{rii} = \psi_{ir}l_{ir} = c\bar{\psi}_{ir}\frac{1}{c}\bar{l}_{ir} = \bar{\psi}_{ir}\bar{l}_{ir}\]</div>
<div class="math notranslate nohighlight">
\[R_{rii} = \psi_{ir}^2 = c^2\bar{\psi}_{ir}^2\]</div>
<div class="math notranslate nohighlight">
\[\sqrt{R_{rii}} = c \bar{\psi}_{ir}\]</div>
<p>Since we have participation factors and shapes at multiple degrees of freedom for a multiple-input solution, we can solve for the scale factor <span class="math notranslate nohighlight">\(c\)</span> in a least-squares sense for each mode.</p>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\sqrt{R_{r11}} \\ \sqrt{R_{r22}} \\ \vdots \\ \sqrt{R_{r{N_i}{N_i}}}\end{bmatrix} = \begin{bmatrix}\bar{\psi}_{1r}\\\bar{\psi}_{2r}\\\vdots\\\bar{\psi}_{{N_i}r}\end{bmatrix}c\end{split}\]</div>
<div class="math notranslate nohighlight">
\[\begin{split}\begin{bmatrix}\bar{\psi}_{1r}\\\bar{\psi}_{2r}\\\vdots\\\bar{\psi}_{{N_i}r}\end{bmatrix}^+\begin{bmatrix}\sqrt{R_{r11}} \\ \sqrt{R_{r22}} \\ \vdots \\ \sqrt{R_{r{N_i}{N_i}}}\end{bmatrix} = c\end{split}\]</div>
<p><strong>BE AWARE:</strong> when taking the square root of the residue matrix terms, there are two values that can be obtained (e.g. <span class="math notranslate nohighlight">\(\sqrt{4} = \pm2\)</span>). In the case of real numbers, most square root algorithms will only return the positive root. However for complex numbers, it is not so obvious which sign the root will have (positive real part? positive imaginary part?). Flipping a sign on one term in the matrix
<span class="math notranslate nohighlight">\(\begin{bmatrix}\sqrt{R_{r11}} \\ \sqrt{R_{r22}} \\ \vdots \\ \sqrt{R_{r{N_i}{N_i}}}\end{bmatrix}\)</span> will make the least squares solution incorrect, therefore we must make sure the signs are consistent between the mode shapes <span class="math notranslate nohighlight">\(\bar{\psi}_{ir}\)</span> and the residue terms <span class="math notranslate nohighlight">\(\sqrt{R_{rii}}\)</span>.</p>
<p>We can do this by dividing the termes <span class="math notranslate nohighlight">\(\sqrt{R_{rii}}\)</span> by <span class="math notranslate nohighlight">\(\bar{\psi}_{ir}\)</span> and looking at the direction of the complex vectors. If the vectors are all pointing nominally the same direction, then the least squares problem will solve for that direction successfully. If some are pointing opposite due to the sign of the output of the square root, then the scale factor found by the least squares solution will be incorrect.</p>
</section>
<section id="id1">
<h3>Back to the Example Problem<a class="headerlink" href="#id1" title="Permalink to this heading"></a></h3>
<p>While the symbolic mathematics in the previous sections was straightforward (though perhaps a bit tedious), the discussion of the construction of a system of equations to solve for each coefficient of the mode shape matrix was perhaps a bit abstract. We will therefore make it more concrete by applying it to our specific example problem. Note that we will take advantage heavily of broadcasting and dimensional manipulation to help us put these equations together. Readers are encouraged to run
these problems themselves to understand exactly what operations are being performed at each step, and the resulting shapes of all of the arrays.</p>
<p>We will first generate the <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> matrix described above. We will start with only the mode shape coefficients, then show how it can be expanded to include residuals. This will involve translating our symbolic code into numeric Numpy code. To help us repeat this process for different sets of modes and frequency ranges when we introduce the residuals later, we will define the process to generate the <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> matrix as a function.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[45]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">P_modal</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span> <span class="n">poles</span><span class="p">,</span> <span class="n">participation_factors</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Construct the mode shape coefficient matrix</span>

<span class="sd">    Constructs the coefficients from the system poles,</span>
<span class="sd">    participation factors, and frequency lines.</span>

<span class="sd">    Arguments should be passed as arrays and will be broadcast</span>
<span class="sd">    together.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># We want the output array to be n_input x n_freq*2 x n_modes*2</span>
    <span class="c1"># So let&#39;s adjust the terms so they have the right shapes</span>
    <span class="c1"># We want frequency lines to be the middle dimension</span>
    <span class="n">omegas</span> <span class="o">=</span> <span class="n">omegas</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># We want inputs to be the first dimension and modes the</span>
    <span class="c1"># last dimension</span>
    <span class="n">participation_factors</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
    <span class="c1"># Split up terms into real and imaginary parts</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="n">poles</span><span class="o">.</span><span class="n">real</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">poles</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">lr</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">real</span>
    <span class="n">li</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">P_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
         <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">+</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)],</span>
        <span class="p">[(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
         <span class="p">(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">+</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)]])</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                     <span class="p">[</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
</pre></div>
</div>
</div>
<p>We can now create our pole vector from the extracted frequencies and damping ratios.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[46]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute poles from the extracted data</span>
<span class="n">poles</span> <span class="o">=</span> <span class="o">-</span><span class="n">omega_general_stab</span><span class="o">*</span><span class="n">zeta_general_stab</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># Compute P with our function</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">P_modal</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">poles</span><span class="p">,</span> <span class="n">lr_stab</span><span class="p">)</span>

<span class="c1"># Check shapes</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  omegas: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  poles: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  participation_factors: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  P: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">omegas</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">poles</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">lr_stab</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  omegas: (778,)
  poles: (3,)
  participation_factors: (3, 2)
  P: (2, 1556, 6)
</pre></div></div>
</div>
<p>We must now set up the frequency response functions to perform the least squares computation.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[47]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">H_LS</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H_LS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">H_LS</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">H_LS</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  H_LS: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
    <span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  H_LS: (2, 1556, 3)
</pre></div></div>
</div>
<p>To construct the least-squares set of equations, we simply squash the first two dimensions into a single dimension, in which case the least-squares solution will solve over all frequency lines and all inputs simultaneously.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[48]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shapes_LS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">H_LS</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>We can reconstruct the FRF by muliplying the output shapes by the coefficient matrix and extracting real and imaginary parts.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[49]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">reconstructed_frfs</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="nd">@shapes_LS</span>
<span class="n">H_recon</span> <span class="o">=</span> <span class="n">reconstructed_frfs</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H_recon</span> <span class="o">=</span> <span class="n">H_recon</span><span class="p">[:</span><span class="n">H_recon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">H_recon</span><span class="p">[</span><span class="n">H_recon</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[50]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_modes</span> <span class="o">=</span> <span class="n">omega_general_stab</span><span class="o">.</span><span class="n">size</span>
<span class="n">omegas_bc</span> <span class="o">=</span> <span class="n">omegas</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="c1"># Compute the laplace variables</span>
<span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span>

<span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_output</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">num_input</span><span class="p">,</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_d</span><span class="p">,</span><span class="n">f_m</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_general</span><span class="p">[</span><span class="n">frequency_lines_to_keep</span><span class="p">,:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_recon</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_d</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_m</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_d</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_m</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Truth&#39;</span><span class="p">,</span><span class="s1">&#39;Reconstructed from</span><span class="se">\n</span><span class="s1">Least-Squares Solution&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_135_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_135_0.png" />
</div>
</div>
<p>We have now solved in a least-squares sense for our modal coefficients. We should extract the shape arrays from the matrix. The top partition will be the real part of the shape, and the bottom part will be the imaginary part of the shape. Remember also that the terms are transposed from the typical mode shape matrix.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[51]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_stab</span> <span class="o">=</span> <span class="p">(</span><span class="n">shapes_LS</span><span class="p">[:</span><span class="n">shapes_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">shapes_LS</span><span class="p">[</span><span class="n">shapes_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:])</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
<p>Note that because the participation factors were arbitrarily rotated, these shapes will also be arbitrarily rotated. Therefore we need to normalize the mode shapes. We will do this by computing the residue matrices.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[52]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">residues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ik,jk-&gt;kij&#39;</span><span class="p">,</span><span class="n">psi_stab</span><span class="p">,</span><span class="n">lr_stab</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>We can get the drive point response indices corresponding to the participation factors and pull out the drive point residues. In general, the drive point residues should have a negative imaginary part, so we can use this to discard ‘bad’ drive point data where the drive point does not excite the mode well.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[53]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">drive_indices_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">drive_indices_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">drive_residues</span> <span class="o">=</span> <span class="n">residues</span><span class="p">[:,</span><span class="n">drive_indices_response</span><span class="p">,</span><span class="n">drive_indices_input</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>We will now go through each mode and compute the correct shape scaling using only the good drive points where the imaginary part is negative and not close to zero. First, let’s go through and make sure that our participation factors and mode shapes that we solved for are actually scaled versions of the true mode shapes. I’m going to mass normalize my mode shapes for better comparisions to the fit data without having to carry around the modal mass term.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[54]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Mass normalize the mode shapes</span>
<span class="n">psi_general</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">ma_general</span><span class="p">)</span>
</pre></div>
</div>
</div>
<p>Let’s find the scale factor between the participation factors and the mode shapes at the participation factors. We will average over all of the degrees of freedom for each mode.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[55]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lr_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psi_general</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span><span class="o">/</span><span class="n">lr_stab</span><span class="o">.</span><span class="n">T</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[56]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lr_scaling</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[56]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([ 0.18452662-0.18416078j,  0.08928666-0.0956242j ,
       -0.093857  +0.08439714j])
</pre></div></div>
</div>
<p>We can then check to see if we reconstruct the mode shape by applying the scaling to the participation factors.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[57]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">lr_stab</span><span class="o">.</span><span class="n">T</span><span class="o">*</span><span class="n">lr_scaling</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[57]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-0.02160023+0.02202919j,  0.03267784-0.03499731j,
        -0.03029502+0.02724158j],
       [-0.04928941+0.04919169j,  0.00092769+0.00092779j,
         0.01686661-0.01714951j]])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[58]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_general</span><span class="p">[:</span><span class="mi">2</span><span class="p">,:]</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[58]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-0.02160023+0.02202919j,  0.03267787-0.03499732j,
        -0.03029503+0.02724158j],
       [-0.04928941+0.04919169j,  0.00092769+0.00092779j,
         0.0168666 -0.01714951j]])
</pre></div></div>
</div>
<p>Now we will do the same thing for the mode shapes.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[59]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_scaling</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">psi_general</span><span class="o">/</span><span class="n">psi_stab</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[60]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_scaling</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[60]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([ 2.70380647+2.72025259j,  5.15973139+5.66778918j,
       -5.88158134-5.30751768j])
</pre></div></div>
</div>
<p>Let’s reconstruct the mode shapes by scaling the fit mode shapes.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[61]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_stab</span><span class="o">*</span><span class="n">psi_scaling</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[61]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-0.02159971+0.02202864j,  0.03316166-0.03473379j,
        -0.03033178+0.02722321j],
       [-0.04928856+0.04919178j,  0.00094139+0.00090236j,
         0.0168663 -0.01716533j],
       [-0.02186329+0.02176496j, -0.03539605+0.03236945j,
        -0.02735936+0.03018341j]])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[62]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_general</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[62]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([[-0.02160023+0.02202919j,  0.03267787-0.03499732j,
        -0.03029503+0.02724158j],
       [-0.04928941+0.04919169j,  0.00092769+0.00092779j,
         0.0168666 -0.01714951j],
       [-0.02186239+0.02176446j, -0.03496025+0.03263839j,
        -0.02739619+0.03019566j]])
</pre></div></div>
</div>
<p>Since the particpation factors times the mode shapes should be equal to the scaled mode shapes squared, we should be able to see that the scale factors are reciprocals of one another.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[63]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_scaling</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[63]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([ 2.70380647+2.72025259j,  5.15973139+5.66778918j,
       -5.88158134-5.30751768j])
</pre></div></div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="mi">1</span><span class="o">/</span><span class="n">lr_scaling</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[64]:
</pre></div>
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
array([ 2.71501354+2.70963081j,  5.2165319 +5.58679996j,
       -5.89109483-5.29733029j])
</pre></div></div>
</div>
<p>This was a sanity check to make sure the mode shapes and participation factors were identified consistently. Unfortunately in a real situation we don’t have the true mode shapes, so we need to compute them from the residue matrices.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[65]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">psi_stab_normalized</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">k</span><span class="p">,</span><span class="n">drive_residue</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">drive_residues</span><span class="p">):</span>
    <span class="c1"># Throw away non-negative imaginary parts</span>
    <span class="n">bad_indices_positive</span> <span class="o">=</span> <span class="n">drive_residue</span><span class="o">.</span><span class="n">imag</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="c1"># Throw away small values compared to the average value (only considering negative imaginary parts)</span>
    <span class="n">bad_indices_small</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">drive_residue</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">0.01</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">drive_residue</span><span class="p">[</span><span class="o">~</span><span class="n">bad_indices_positive</span><span class="p">]))</span>
    <span class="c1"># Combine into a single criteria</span>
    <span class="n">bad_indices</span> <span class="o">=</span> <span class="n">bad_indices_positive</span> <span class="o">|</span> <span class="n">bad_indices_small</span>
    <span class="c1"># Get the good indices that are remaining</span>
    <span class="n">remaining_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="o">~</span><span class="n">bad_indices</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># We will then construct the least squares solution</span>
    <span class="n">shape_coefficients</span> <span class="o">=</span> <span class="n">psi_stab</span><span class="p">[</span><span class="n">drive_indices_response</span><span class="p">[</span><span class="n">remaining_indices</span><span class="p">],</span><span class="n">k</span><span class="p">][:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="n">residue_coefficients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">drive_residue</span><span class="p">[</span><span class="n">remaining_indices</span><span class="p">])[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># Before we compute the scale, we need to make sure that we have all of the signs the same way.</span>
    <span class="c1"># This is because the square root can give you +/- root where root**2 = complex number</span>
    <span class="c1"># This will mess up the least squares at it will try to find something between the</span>
    <span class="c1"># two vectors.</span>
    <span class="n">scale_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">residue_coefficients</span><span class="o">/</span><span class="n">shape_coefficients</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">sign_vector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">scale_vector</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">scale_vector</span><span class="o">.</span><span class="n">imag</span><span class="p">))</span>
    <span class="c1"># Get the signs</span>
    <span class="n">signs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">sign_vector</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span><span class="n">sign_vector</span><span class="p">))</span>
    <span class="n">residue_coefficients</span> <span class="o">=</span> <span class="n">residue_coefficients</span><span class="o">*</span><span class="n">signs</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># Now compute the least-squares solution</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">shape_coefficients</span><span class="p">,</span><span class="n">residue_coefficients</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">squeeze</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Scale for mode </span><span class="si">{:}</span><span class="s1">: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">scale</span><span class="p">))</span>
    <span class="n">psi_stab_normalized</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">psi_stab</span><span class="p">[:,</span><span class="n">k</span><span class="p">]</span><span class="o">*</span><span class="n">scale</span><span class="p">)</span>
<span class="n">psi_stab_normalized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">psi_stab_normalized</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Scale for mode 1: (-2.709418738512416-2.7149722671668157j)
Scale for mode 2: (5.211812790651124+5.590252990269536j)
Scale for mode 3: (5.886705065831037+5.299694143958719j)
</pre></div></div>
</div>
<p>Now that we have our mode shapes, we should resynthesize frequency response functions from them to make sure they fit our original data.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[66]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">num_modes</span> <span class="o">=</span> <span class="n">omega_general_stab</span><span class="o">.</span><span class="n">size</span>
<span class="n">omegas_bc</span> <span class="o">=</span> <span class="n">omegas</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
<span class="c1"># Compute the laplace variables</span>
<span class="n">s</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omegas_bc</span>

<span class="n">H_general_fromUnNormModes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
    <span class="n">psi_stab</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="nd">@lr_stab</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">/</span>
    <span class="p">((</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="o">+</span> <span class="n">psi_stab</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="nd">@lr_stab</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">/</span>
    <span class="p">((</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">H_general_fromFitModes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
    <span class="n">psi_stab_normalized</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="nd">@psi_stab_normalized</span><span class="p">[</span><span class="n">drive_indices_input</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">/</span>
    <span class="p">((</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="o">+</span> <span class="n">psi_stab_normalized</span><span class="p">[:,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="nd">@psi_stab_normalized</span><span class="p">[</span><span class="n">drive_indices_input</span><span class="p">,</span><span class="n">r</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">/</span>
    <span class="p">((</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="n">H_general_fromFitResidues</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">([</span>
    <span class="n">residues</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">/</span>
    <span class="p">((</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="o">+</span> <span class="n">residues</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">/</span>
    <span class="p">((</span><span class="n">s</span><span class="o">-</span>
        <span class="p">(</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">omega_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">zeta_general_stab</span><span class="p">[</span><span class="n">r</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))))</span>
    <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_modes</span><span class="p">)],</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_t</span><span class="p">,</span><span class="n">f_m</span><span class="p">,</span><span class="n">f_r</span><span class="p">,</span><span class="n">f_u</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_general</span><span class="p">[</span><span class="n">frequency_lines_to_keep</span><span class="p">,:</span><span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_general_fromFitModes</span><span class="p">[:,:</span><span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],:</span><span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_general_fromFitResidues</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_general_fromUnNormModes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                      <span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_t</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_u</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_m</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_r</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_t</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_u</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_m</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_r</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Truth&#39;</span><span class="p">,</span><span class="s1">&#39;Unnormalized&#39;</span><span class="p">,</span><span class="s1">&#39;Normalized&#39;</span><span class="p">,</span><span class="s1">&#39;Residues&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_162_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_162_0.png" />
</div>
</div>
<p>The last demonstration will be to understand how residuals can be implemented. To do this, we will truncate the frequency domain to remove the first mode. We will then use residuals to try to fit the effect of this mode while only truly fitting the second two modes. We will assume we have correctly identified the poles and participation factors from the first analysis, and only consider solving the shape problem here.</p>
<p>We will update our function to solve for the <span class="math notranslate nohighlight">\(\mathbf{P}\)</span> matrix to also solve for residual terms.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[67]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">P_modal_w_residuals</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span> <span class="n">poles</span><span class="p">,</span> <span class="n">participation_factors</span><span class="p">,</span> <span class="n">lower_residuals</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">upper_residuals</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;Construct the mode shape coefficient matrix</span>

<span class="sd">    Constructs the coefficients from the system poles,</span>
<span class="sd">    participation factors, and frequency lines.</span>

<span class="sd">    Arguments should be passed as arrays and will be broadcast</span>
<span class="sd">    together.</span>
<span class="sd">    &#39;&#39;&#39;</span>
    <span class="c1"># Get the number of modes and number of inputs from the shape</span>
    <span class="c1"># of the participation factors.</span>
    <span class="n">n_modes</span><span class="p">,</span><span class="n">n_inputs</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">n_freq</span><span class="p">,</span> <span class="o">=</span> <span class="n">omegas</span><span class="o">.</span><span class="n">shape</span>
    <span class="c1"># We want the output array to be n_input x n_freq*2 x n_modes*2</span>
    <span class="c1"># So let&#39;s adjust the terms so they have the right shapes</span>
    <span class="c1"># We want frequency lines to be the middle dimension</span>
    <span class="n">omegas</span> <span class="o">=</span> <span class="n">omegas</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
    <span class="c1"># We want inputs to be the first dimension and modes the</span>
    <span class="c1"># last dimension</span>
    <span class="n">participation_factors</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">T</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
    <span class="c1"># Split up terms into real and imaginary parts</span>
    <span class="n">pr</span> <span class="o">=</span> <span class="n">poles</span><span class="o">.</span><span class="n">real</span>
    <span class="n">pi</span> <span class="o">=</span> <span class="n">poles</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">lr</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">real</span>
    <span class="n">li</span> <span class="o">=</span> <span class="n">participation_factors</span><span class="o">.</span><span class="n">imag</span>
    <span class="n">P_blocks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span>
        <span class="p">[(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
         <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">+</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)],</span>
        <span class="p">[(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">li</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">lr</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">),</span>
         <span class="p">(</span><span class="o">-</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">-</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
          <span class="o">+</span> <span class="p">(</span><span class="n">pr</span><span class="o">*</span><span class="n">lr</span> <span class="o">+</span> <span class="n">pi</span><span class="o">*</span><span class="n">li</span> <span class="o">+</span> <span class="n">li</span><span class="o">*</span><span class="n">omegas</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">pr</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">pi</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">2</span><span class="o">*</span><span class="n">pi</span><span class="o">*</span><span class="n">omegas</span> <span class="o">+</span> <span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">)]])</span>
    <span class="k">if</span> <span class="n">lower_residuals</span><span class="p">:</span>
        <span class="n">RL_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="n">omegas</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">upper_residuals</span><span class="p">:</span>
        <span class="n">RU_block</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span>
            <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">])),</span>
            <span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="mi">1</span><span class="p">)),</span><span class="n">np</span><span class="o">.</span><span class="n">kron</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">n_inputs</span><span class="p">)[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]))],</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">block</span><span class="p">([[</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">]],</span>
                  <span class="p">[</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="n">P_blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">]]])</span>
    <span class="k">if</span> <span class="n">lower_residuals</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">P</span><span class="p">,</span><span class="n">RL_block</span><span class="p">),</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">upper_residuals</span><span class="p">:</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">P</span><span class="p">,</span><span class="n">RU_block</span><span class="p">),</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">P</span>
</pre></div>
</div>
</div>
<p>We can then call the function with a subset of the modes that we aim to solve for.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[68]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">min_freq</span> <span class="o">=</span> <span class="mi">45</span>
<span class="n">mode_indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
<span class="n">P</span> <span class="o">=</span> <span class="n">P_modal_w_residuals</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span> <span class="o">&gt;</span> <span class="n">min_freq</span><span class="p">],</span>
                        <span class="n">poles</span><span class="p">[</span><span class="n">mode_indices</span><span class="p">],</span>
                        <span class="n">lr_stab</span><span class="p">[</span><span class="n">mode_indices</span><span class="p">],</span>
                        <span class="n">lower_residuals</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">upper_residuals</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>

<span class="n">H_LS</span> <span class="o">=</span> <span class="n">H</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">]</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H_LS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">H_LS</span><span class="o">.</span><span class="n">real</span><span class="p">,</span><span class="n">H_LS</span><span class="o">.</span><span class="n">imag</span><span class="p">),</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Shapes:</span><span class="se">\n</span><span class="s1">  P: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">  H_LS: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Shapes:
  P: (2, 778, 12)
  H_LS: (2, 778, 3)
</pre></div></div>
</div>
<p>We can then solve the least squares problem over all frequency lines and inputs.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[69]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">shapes_LS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">lstsq</span><span class="p">(</span><span class="n">P</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                            <span class="n">H_LS</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
</div>
<p>Now at this point, we can reconstruct the portions of the FRFs from the modes and those from the residuals.</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[70]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="n">P_full</span> <span class="o">=</span> <span class="n">P</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="n">P</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
<span class="n">P_modes</span> <span class="o">=</span> <span class="n">P_full</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">2</span><span class="o">*</span><span class="n">poles</span><span class="p">[</span><span class="n">mode_indices</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
<span class="n">P_residuals</span> <span class="o">=</span> <span class="n">P_full</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="mi">2</span><span class="o">*</span><span class="n">poles</span><span class="p">[</span><span class="n">mode_indices</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span>

<span class="n">shapes_modes</span> <span class="o">=</span> <span class="n">shapes_LS</span><span class="p">[:</span><span class="mi">2</span><span class="o">*</span><span class="n">poles</span><span class="p">[</span><span class="n">mode_indices</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">]</span>
<span class="n">shapes_residuals</span> <span class="o">=</span> <span class="n">shapes_LS</span><span class="p">[</span><span class="mi">2</span><span class="o">*</span><span class="n">poles</span><span class="p">[</span><span class="n">mode_indices</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:]</span>

<span class="n">H_modes</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_modes</span><span class="nd">@shapes_modes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H_modes</span> <span class="o">=</span> <span class="n">H_modes</span><span class="p">[:</span><span class="n">H_modes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">H_modes</span><span class="p">[</span><span class="n">H_modes</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

<span class="n">H_residuals</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_residuals</span><span class="nd">@shapes_residuals</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H_residuals</span> <span class="o">=</span> <span class="n">H_residuals</span><span class="p">[:</span><span class="n">H_residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">H_residuals</span><span class="p">[</span><span class="n">H_residuals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>

<span class="n">H_full</span> <span class="o">=</span> <span class="p">(</span><span class="n">P_full</span><span class="nd">@shapes_LS</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">H_LS</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">H_full</span> <span class="o">=</span> <span class="n">H_full</span><span class="p">[:</span><span class="n">H_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">H_full</span><span class="p">[</span><span class="n">H_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="p">:]</span>
</pre></div>
</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[71]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre><span></span><span class="c1"># Now plot them</span>
<span class="n">fig</span><span class="p">,</span><span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">H_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span><span class="n">H_full</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="s1">&#39;row&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">10</span><span class="p">))</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_t</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_general</span><span class="p">[</span><span class="n">frequency_lines_to_keep</span><span class="p">,:,:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_t</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_t</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="k">for</span> <span class="n">ax</span><span class="p">,</span><span class="n">f_r</span><span class="p">,</span><span class="n">f_m</span><span class="p">,</span><span class="n">f_f</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="c1"># Reshape so we pull of a mag and phase plot for each entry</span>
                      <span class="n">H_residuals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_modes</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                      <span class="n">H_full</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
                      <span class="p">):</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_f</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_r</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">f_m</span><span class="p">)</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_f</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_r</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">omegas</span><span class="p">[</span><span class="n">omegas</span><span class="o">&gt;</span><span class="n">min_freq</span><span class="p">],</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">f_m</span><span class="p">),</span><span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">legend</span><span class="p">([</span><span class="s1">&#39;Truth&#39;</span><span class="p">,</span><span class="s1">&#39;Fit&#39;</span><span class="p">,</span><span class="s1">&#39;Residual Contribution&#39;</span><span class="p">,</span><span class="s1">&#39;Mode Contribution&#39;</span><span class="p">])</span>
<span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">ax</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">axes</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]):</span>
    <span class="k">if</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([</span><span class="o">-</span><span class="mi">180</span><span class="p">,</span><span class="o">-</span><span class="mi">90</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">90</span><span class="p">,</span><span class="mi">180</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase (deg)&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="mf">1e-5</span><span class="p">,</span><span class="mf">1e-2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Magnitude (deg)&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<img alt="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_172_0.png" src="../../_images/modal_tutorials_Modal_06_Complex_Modes_Modal_06_Complex_Modes_172_0.png" />
</div>
</div>
<p>We see that the fit matches the measured data very due to the inclusion of the residual terms. If we were to just include the modal contributions, it would not fit as well, but by adding in residual contributions we can get a much better match.</p>
</section>
</section>
<section id="Summary">
<h2>Summary<a class="headerlink" href="#Summary" title="Permalink to this heading"></a></h2>
<p>In this document, we have extensively studied complex modes. We first explored the real-modes case to understand the limitations of that approach. We then derived the state space system of equations from the typical 2nd order differential equation to construct the eigenvalue equation to solve for the complex modes.</p>
<p>We then related the modal parameters to the frequency response function, which allowed us to compute a frequency response function given the modal parameters.</p>
<p>We finally spent a good deal of time discussing how to fit modal parameters to frequency response functions using the PolyMax approach, which is implemented in SDynPy as PolyPy.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Modal_05_Experimental_Modal_Analysis/Modal_05f_Comparing_Test_and_Analysis.html" class="btn btn-neutral float-left" title="Modal Tutorial 05 Part F: Comparing Test and Analysis" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../modules.html" class="btn btn-neutral float-right" title="SDynPy Programming Interface" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
<jinja2.runtime.BlockReference object at 0x7f5a289d3310>
<img src="_images/snl.jpg" alt="Sandia National Laboratories" style="height:40px">

  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>