<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sdynpy.core.sdynpy_data &mdash; SDynPy 0.14.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo_horizontal_light.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sdynpy_showcase.html">SDynPy Showcase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">SDynpy Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modal_tutorials.html">Modal Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">SDynPy Programming Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SDynPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sdynpy.core.sdynpy_data</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sdynpy.core.sdynpy_data</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Defines the NDDataArray, which defines function data such as time histories.</span>

<span class="sd">This module also defines several subclasses of NDDataArray, which contain</span>
<span class="sd">function-type-specific capabilities.  Several Enumerations are also defined</span>
<span class="sd">that connect data fields from the universal file format to the NDDataArray</span>
<span class="sd">subclasses.</span>

<span class="sd">Copyright 2022 National Technology &amp; Engineering Solutions of Sandia,</span>
<span class="sd">LLC (NTESS). Under the terms of Contract DE-NA0003525 with NTESS, the U.S.</span>
<span class="sd">Government retains certain rights in this software.</span>

<span class="sd">This program is free software: you can redistribute it and/or modify</span>
<span class="sd">it under the terms of the GNU General Public License as published by</span>
<span class="sd">the Free Software Foundation, either version 3 of the License, or</span>
<span class="sd">(at your option) any later version.</span>

<span class="sd">This program is distributed in the hope that it will be useful,</span>
<span class="sd">but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="sd">MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="sd">GNU General Public License for more details.</span>

<span class="sd">You should have received a copy of the GNU General Public License</span>
<span class="sd">along with this program.  If not, see &lt;https://www.gnu.org/licenses/&gt;.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">.sdynpy_array</span> <span class="kn">import</span> <span class="n">SdynpyArray</span>
<span class="kn">from</span> <span class="nn">.sdynpy_coordinate</span> <span class="kn">import</span> <span class="n">outer_product</span><span class="p">,</span> <span class="n">CoordinateArray</span><span class="p">,</span> <span class="n">coordinate_array</span>
<span class="kn">from</span> <span class="nn">.sdynpy_matrix</span> <span class="kn">import</span> <span class="n">Matrix</span><span class="p">,</span> <span class="n">matrix</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_correlation</span> <span class="kn">import</span> <span class="n">mac</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_frf</span> <span class="kn">import</span> <span class="n">timedata2frf</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_cpsd</span> <span class="kn">import</span> <span class="p">(</span><span class="n">cpsd</span> <span class="k">as</span> <span class="n">sp_cpsd</span><span class="p">,</span>
                                             <span class="n">cpsd_coherence</span> <span class="k">as</span> <span class="n">sp_coherence</span><span class="p">,</span>
                                             <span class="n">cpsd_to_time_history</span><span class="p">,</span>
                                             <span class="n">cpsd_from_coh_phs</span><span class="p">,</span>
                                             <span class="n">db2scale</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_srs</span> <span class="kn">import</span> <span class="p">(</span><span class="n">srs</span> <span class="k">as</span> <span class="n">sp_srs</span><span class="p">,</span>
                                            <span class="n">octspace</span><span class="p">,</span>
                                            <span class="n">sum_decayed_sines</span> <span class="k">as</span> <span class="n">sp_sds</span><span class="p">,</span>
                                            <span class="n">sum_decayed_sines_reconstruction</span><span class="p">,</span>
                                            <span class="n">sum_decayed_sines_displacement_velocity</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_rotation</span> <span class="kn">import</span> <span class="n">lstsq_rigid_transform</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_generator</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">pseudorandom</span><span class="p">,</span> <span class="n">sine</span><span class="p">,</span> <span class="n">ramp_envelope</span><span class="p">,</span> <span class="n">chirp</span><span class="p">,</span> <span class="n">pulse</span><span class="p">,</span> <span class="n">sine_sweep</span><span class="p">)</span>
<span class="kn">from</span> <span class="nn">..signal_processing.sdynpy_frf_inverse</span> <span class="kn">import</span> <span class="p">(</span><span class="n">frf_inverse</span><span class="p">,</span>
                                                    <span class="n">compute_tikhonov_modified_singular_values</span><span class="p">)</span>

<span class="kn">from</span> <span class="nn">..fem.sdynpy_exodus</span> <span class="kn">import</span> <span class="n">Exodus</span>
<span class="kn">from</span> <span class="nn">scipy.linalg</span> <span class="kn">import</span> <span class="n">eigh</span>
<span class="kn">from</span> <span class="nn">enum</span> <span class="kn">import</span> <span class="n">Enum</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cm</span>
<span class="kn">from</span> <span class="nn">matplotlib.colors</span> <span class="kn">import</span> <span class="n">ListedColormap</span>
<span class="kn">from</span> <span class="nn">matplotlib.backends.backend_qt5agg</span> <span class="kn">import</span> <span class="n">FigureCanvasQTAgg</span> <span class="k">as</span> <span class="n">FigureCanvas</span>
<span class="kn">from</span> <span class="nn">matplotlib.figure</span> <span class="kn">import</span> <span class="n">Figure</span>
<span class="kn">from</span> <span class="nn">matplotlib.patches</span> <span class="kn">import</span> <span class="n">Rectangle</span>
<span class="kn">from</span> <span class="nn">matplotlib.gridspec</span> <span class="kn">import</span> <span class="n">GridSpec</span>
<span class="kn">from</span> <span class="nn">matplotlib.ticker</span> <span class="kn">import</span> <span class="n">MaxNLocator</span>
<span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">copy</span><span class="p">,</span> <span class="n">deepcopy</span>
<span class="kn">from</span> <span class="nn">datetime</span> <span class="kn">import</span> <span class="n">datetime</span>
<span class="kn">from</span> <span class="nn">qtpy</span> <span class="kn">import</span> <span class="n">QtWidgets</span><span class="p">,</span> <span class="n">uic</span><span class="p">,</span> <span class="n">QtGui</span>
<span class="kn">from</span> <span class="nn">qtpy.QtGui</span> <span class="kn">import</span> <span class="n">QIcon</span><span class="p">,</span> <span class="n">QFont</span>
<span class="kn">from</span> <span class="nn">qtpy.QtCore</span> <span class="kn">import</span> <span class="n">Qt</span><span class="p">,</span> <span class="n">QCoreApplication</span><span class="p">,</span> <span class="n">QRect</span>
<span class="kn">from</span> <span class="nn">qtpy.QtWidgets</span> <span class="kn">import</span> <span class="p">(</span><span class="n">QToolTip</span><span class="p">,</span> <span class="n">QLabel</span><span class="p">,</span> <span class="n">QPushButton</span><span class="p">,</span> <span class="n">QApplication</span><span class="p">,</span>
                            <span class="n">QGroupBox</span><span class="p">,</span> <span class="n">QWidget</span><span class="p">,</span> <span class="n">QMessageBox</span><span class="p">,</span> <span class="n">QHBoxLayout</span><span class="p">,</span>
                            <span class="n">QVBoxLayout</span><span class="p">,</span> <span class="n">QSizePolicy</span><span class="p">,</span> <span class="n">QMainWindow</span><span class="p">,</span>
                            <span class="n">QFileDialog</span><span class="p">,</span> <span class="n">QErrorMessage</span><span class="p">,</span> <span class="n">QListWidget</span><span class="p">,</span> <span class="n">QLineEdit</span><span class="p">,</span>
                            <span class="n">QDockWidget</span><span class="p">,</span> <span class="n">QGridLayout</span><span class="p">,</span> <span class="n">QButtonGroup</span><span class="p">,</span> <span class="n">QDialog</span><span class="p">,</span>
                            <span class="n">QCheckBox</span><span class="p">,</span> <span class="n">QRadioButton</span><span class="p">,</span> <span class="n">QMenuBar</span><span class="p">,</span> <span class="n">QMenu</span><span class="p">)</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">qtpy.QtGui</span> <span class="kn">import</span> <span class="n">QAction</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">qtpy.QtWidgets</span> <span class="kn">import</span> <span class="n">QAction</span>
<span class="kn">import</span> <span class="nn">pyqtgraph</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">scipy.signal</span> <span class="k">as</span> <span class="nn">sig</span>
<span class="kn">import</span> <span class="nn">warnings</span>
<span class="kn">import</span> <span class="nn">scipy.fft</span> <span class="k">as</span> <span class="nn">scipyfft</span>
<span class="kn">from</span> <span class="nn">scipy.signal.windows</span> <span class="kn">import</span> <span class="n">exponential</span><span class="p">,</span> <span class="n">get_window</span>
<span class="kn">from</span> <span class="nn">scipy.signal</span> <span class="kn">import</span> <span class="n">oaconvolve</span><span class="p">,</span> <span class="n">convolve</span>
<span class="kn">from</span> <span class="nn">scipy.interpolate</span> <span class="kn">import</span> <span class="n">interp1d</span>
<span class="n">pyqtgraph</span><span class="o">.</span><span class="n">setConfigOption</span><span class="p">(</span><span class="s1">&#39;background&#39;</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span>
<span class="n">pyqtgraph</span><span class="o">.</span><span class="n">setConfigOption</span><span class="p">(</span><span class="s1">&#39;foreground&#39;</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="SpecificDataType"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.SpecificDataType.html#sdynpy.core.sdynpy_data.SpecificDataType">[docs]</a><span class="k">class</span> <span class="nc">SpecificDataType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration containing the types of data in universal files&quot;&quot;&quot;</span>
    <span class="n">UNKNOWN</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">GENERAL</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">STRESS</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">STRAIN</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">TEMPERATURE</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">HEAT_FLUX</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">DISPLACEMENT</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">REACTION_FORCE</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="n">VELOCITY</span> <span class="o">=</span> <span class="mi">11</span>
    <span class="n">ACCELERATION</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">EXCITATION_FORCE</span> <span class="o">=</span> <span class="mi">13</span>
    <span class="n">PRESSURE</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">MASS</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">TIME</span> <span class="o">=</span> <span class="mi">17</span>
    <span class="n">FREQUENCY</span> <span class="o">=</span> <span class="mi">18</span>
    <span class="n">RPM</span> <span class="o">=</span> <span class="mi">19</span>
    <span class="n">ORDER</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">SOUND_PRESSURE</span> <span class="o">=</span> <span class="mi">21</span>
    <span class="n">SOUND_INTENSITY</span> <span class="o">=</span> <span class="mi">22</span>
    <span class="n">SOUND_POWER</span> <span class="o">=</span> <span class="mi">23</span></div>


<span class="n">_specific_data_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">SpecificDataType</span><span class="p">}</span>

<span class="n">_specific_data_names_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_specific_data_names</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>

<span class="c1">#                 Table - Unit Exponents</span>
<span class="c1"># -------------------------------------------------------</span>
<span class="c1">#  Specific                   Direction</span>
<span class="c1">#           ---------------------------------------------</span>
<span class="c1">#    Data       Translational            Rotational</span>
<span class="c1">#           ---------------------------------------------</span>
<span class="c1">#    Type    Length  Force  Temp    Length  Force  Temp</span>
<span class="c1"># -------------------------------------------------------</span>
<span class="c1">#     0        0       0      0       0       0      0</span>
<span class="c1">#     1             (requires input to fields 2,3,4)</span>
<span class="c1">#     2       -2       1      0      -1       1      0</span>
<span class="c1">#     3        0       0      0       0       0      0</span>
<span class="c1">#     5        0       0      1       0       0      1</span>
<span class="c1">#     6        1       1      0       1       1      0</span>
<span class="c1">#     8        1       0      0       0       0      0</span>
<span class="c1">#     9        0       1      0       1       1      0</span>
<span class="c1">#    11        1       0      0       0       0      0</span>
<span class="c1">#    12        1       0      0       0       0      0</span>
<span class="c1">#    13        0       1      0       1       1      0</span>
<span class="c1">#    15       -2       1      0      -1       1      0</span>
<span class="c1">#    16       -1       1      0       1       1      0</span>
<span class="c1">#    17        0       0      0       0       0      0</span>
<span class="c1">#    18        0       0      0       0       0      0</span>
<span class="c1">#    19        0       0      0       0       0      0</span>
<span class="c1"># --------------------------------------------------------</span>

<span class="n">_exponent_table</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">STRESS</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">STRAIN</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">TEMPERATURE</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">HEAT_FLUX</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">DISPLACEMENT</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">REACTION_FORCE</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">VELOCITY</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">ACCELERATION</span><span class="p">:</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">EXCITATION_FORCE</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">PRESSURE</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">MASS</span><span class="p">:</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">TIME</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">FREQUENCY</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
    <span class="n">SpecificDataType</span><span class="o">.</span><span class="n">RPM</span><span class="p">:</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>

<span class="n">_exponent_table_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_exponent_table</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>


<div class="viewcode-block" id="TypeQual"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TypeQual.html#sdynpy.core.sdynpy_data.TypeQual">[docs]</a><span class="k">class</span> <span class="nc">TypeQual</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration containing the quantity type (Rotation or Translation)&quot;&quot;&quot;</span>
    <span class="n">TRANSLATION</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">ROTATION</span> <span class="o">=</span> <span class="mi">1</span></div>


<span class="n">_type_qual_names</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">val</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span><span class="o">.</span><span class="n">title</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">TypeQual</span><span class="p">}</span>
<span class="n">_type_qual_names_vectorized</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">_type_qual_names</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>


<div class="viewcode-block" id="FunctionTypes"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.FunctionTypes.html#sdynpy.core.sdynpy_data.FunctionTypes">[docs]</a><span class="k">class</span> <span class="nc">FunctionTypes</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration containing types of functions found in universal files&quot;&quot;&quot;</span>
    <span class="n">GENERAL</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">TIME_RESPONSE</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">AUTOSPECTRUM</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">CROSSSPECTRUM</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">FREQUENCY_RESPONSE_FUNCTION</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">TRANSMISIBILITY</span> <span class="o">=</span> <span class="mi">5</span>
    <span class="n">COHERENCE</span> <span class="o">=</span> <span class="mi">6</span>
    <span class="n">AUTOCORRELATION</span> <span class="o">=</span> <span class="mi">7</span>
    <span class="n">CROSSCORRELATION</span> <span class="o">=</span> <span class="mi">8</span>
    <span class="n">POWER_SPECTRAL_DENSITY</span> <span class="o">=</span> <span class="mi">9</span>
    <span class="n">ENERGY_SPECTRAL_DENSITY</span> <span class="o">=</span> <span class="mi">10</span>
    <span class="n">PROBABILITY_DENSITY_FUNCTION</span> <span class="o">=</span> <span class="mi">11</span>
    <span class="n">SPECTRUM</span> <span class="o">=</span> <span class="mi">12</span>
    <span class="n">CUMULATIVE_FREQUENCY_DISTRIBUTION</span> <span class="o">=</span> <span class="mi">13</span>
    <span class="n">PEAKS_VALLEY</span> <span class="o">=</span> <span class="mi">14</span>
    <span class="n">STRESS_PER_CYCLE</span> <span class="o">=</span> <span class="mi">15</span>
    <span class="n">STRAIN_PER_CYCLE</span> <span class="o">=</span> <span class="mi">16</span>
    <span class="n">ORBIT</span> <span class="o">=</span> <span class="mi">17</span>
    <span class="n">MODE_INDICATOR_FUNCTION</span> <span class="o">=</span> <span class="mi">18</span>
    <span class="n">FORCE_PATTERN</span> <span class="o">=</span> <span class="mi">19</span>
    <span class="n">PARTIAL_POWER</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">PARTIAL_COHERENCE</span> <span class="o">=</span> <span class="mi">21</span>
    <span class="n">EIGENVALUE</span> <span class="o">=</span> <span class="mi">22</span>
    <span class="n">EIGENVECTOR</span> <span class="o">=</span> <span class="mi">23</span>
    <span class="n">SHOCK_RESPONSE_SPECTRUM</span> <span class="o">=</span> <span class="mi">24</span>
    <span class="n">FINITE_IMPULSE_RESPONSE_FILTER</span> <span class="o">=</span> <span class="mi">25</span>
    <span class="n">MULTIPLE_COHERENCE</span> <span class="o">=</span> <span class="mi">26</span>
    <span class="n">ORDER_FUNCTION</span> <span class="o">=</span> <span class="mi">27</span>
    <span class="n">PHASE_COMPENSATION</span> <span class="o">=</span> <span class="mi">28</span>
    <span class="n">IMPULSE_RESPONSE_FUNCTION</span> <span class="o">=</span> <span class="mi">29</span></div>


<span class="n">_imat_function_type_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;General&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">,</span>
                           <span class="s1">&#39;Time Response&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                           <span class="s1">&#39;Auto Spectrum&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOSPECTRUM</span><span class="p">,</span>
                           <span class="s1">&#39;Cross Spectrum&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSSPECTRUM</span><span class="p">,</span>
                           <span class="s1">&#39;Frequency Response Function&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">,</span>
                           <span class="s1">&#39;Transmissibility&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TRANSMISIBILITY</span><span class="p">,</span>
                           <span class="s1">&#39;Coherence&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span><span class="p">,</span>
                           <span class="s1">&#39;Auto Correlation&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOCORRELATION</span><span class="p">,</span>
                           <span class="s1">&#39;Cross Correlation&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSCORRELATION</span><span class="p">,</span>
                           <span class="s1">&#39;Power Spectral Density&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span>
                           <span class="s1">&#39;Energy Spectral Density&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">ENERGY_SPECTRAL_DENSITY</span><span class="p">,</span>
                           <span class="s1">&#39;Probability Density Function&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">PROBABILITY_DENSITY_FUNCTION</span><span class="p">,</span>
                           <span class="s1">&#39;Spectrum&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SPECTRUM</span><span class="p">,</span>
                           <span class="s1">&#39;Cumulative Frequency Distribution&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CUMULATIVE_FREQUENCY_DISTRIBUTION</span><span class="p">,</span>
                           <span class="s1">&#39;Peaks Valley&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">PEAKS_VALLEY</span><span class="p">,</span>
                           <span class="s1">&#39;Stress/Cycles&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">STRESS_PER_CYCLE</span><span class="p">,</span>
                           <span class="s1">&#39;Strain/Cycles&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">STRAIN_PER_CYCLE</span><span class="p">,</span>
                           <span class="s1">&#39;Orbit&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">ORBIT</span><span class="p">,</span>
                           <span class="s1">&#39;Mode Indicator Function&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MODE_INDICATOR_FUNCTION</span><span class="p">,</span>
                           <span class="s1">&#39;Force Pattern&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FORCE_PATTERN</span><span class="p">,</span>
                           <span class="s1">&#39;Partial Power&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">PARTIAL_POWER</span><span class="p">,</span>
                           <span class="s1">&#39;Partial Coherence&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">PARTIAL_COHERENCE</span><span class="p">,</span>
                           <span class="s1">&#39;Eigenvalue&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">EIGENVALUE</span><span class="p">,</span>
                           <span class="s1">&#39;Eigenvector&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">EIGENVECTOR</span><span class="p">,</span>
                           <span class="s1">&#39;Shock Response Spectrum&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SHOCK_RESPONSE_SPECTRUM</span><span class="p">,</span>
                           <span class="s1">&#39;Finite Impulse Response Filter&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FINITE_IMPULSE_RESPONSE_FILTER</span><span class="p">,</span>
                           <span class="s1">&#39;Multiple Coherence&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MULTIPLE_COHERENCE</span><span class="p">,</span>
                           <span class="s1">&#39;Order Function&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">ORDER_FUNCTION</span><span class="p">,</span>
                           <span class="s1">&#39;Phase Compensation&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">PHASE_COMPENSATION</span><span class="p">,</span>
                           <span class="s1">&#39;Impulse Response Function&#39;</span><span class="p">:</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">IMPULSE_RESPONSE_FUNCTION</span>
                           <span class="p">}</span>

<span class="n">_imat_function_type_inverse_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">val</span><span class="p">:</span> <span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">_imat_function_type_map</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>


<span class="k">def</span> <span class="nf">_flat_frequency_shape</span><span class="p">(</span><span class="n">freq</span><span class="p">):</span>
    <span class="k">return</span> <span class="mi">1</span>


<div class="viewcode-block" id="AbscissaIndexExtractor"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.AbscissaIndexExtractor.html#sdynpy.core.sdynpy_data.AbscissaIndexExtractor">[docs]</a><span class="k">class</span> <span class="nc">AbscissaIndexExtractor</span><span class="p">:</span>
<div class="viewcode-block" id="AbscissaIndexExtractor.__init__"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.AbscissaIndexExtractor.html#sdynpy.core.sdynpy_data.AbscissaIndexExtractor.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">extract_elements</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">extract_elements</span><span class="p">(</span><span class="n">key</span><span class="p">)</span></div>


<div class="viewcode-block" id="AbscissaValueExtractor"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.AbscissaValueExtractor.html#sdynpy.core.sdynpy_data.AbscissaValueExtractor">[docs]</a><span class="k">class</span> <span class="nc">AbscissaValueExtractor</span><span class="p">:</span>
<div class="viewcode-block" id="AbscissaValueExtractor.__init__"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.AbscissaValueExtractor.html#sdynpy.core.sdynpy_data.AbscissaValueExtractor.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span></div>


<span class="k">def</span> <span class="nf">_update_annotations_to_axes_bottom</span><span class="p">(</span><span class="n">axes</span><span class="p">):</span>
    <span class="n">annotations</span> <span class="o">=</span> <span class="p">[</span><span class="n">child</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">axes</span><span class="o">.</span><span class="n">get_children</span><span class="p">()</span> <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">child</span><span class="p">,</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">Annotation</span><span class="p">)]</span>
    <span class="k">for</span> <span class="n">annotation</span> <span class="ow">in</span> <span class="n">annotations</span><span class="p">:</span>
        <span class="n">new_position</span> <span class="o">=</span> <span class="p">(</span><span class="n">annotation</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">axes</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">annotation</span><span class="o">.</span><span class="n">xy</span> <span class="o">=</span> <span class="n">new_position</span>

<div class="viewcode-block" id="NDDataArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray">[docs]</a><span class="k">class</span> <span class="nc">NDDataArray</span><span class="p">(</span><span class="n">SdynpyArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Generic N-Dimensional data structure</span>

<span class="sd">    This data structure can contain real or complex data.  More specific</span>
<span class="sd">    SDynPy data arrays inherit from this superclass.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">data_dimension</span><span class="p">,</span> <span class="n">ordinate_dtype</span><span class="o">=</span><span class="s1">&#39;float64&#39;</span><span class="p">,</span>
                <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Create the ndarray instance of our type, given the usual</span>
        <span class="c1"># ndarray input arguments.  This will call the standard</span>
        <span class="c1"># ndarray constructor, but return an object of our type.</span>
        <span class="c1"># It also triggers a call to __array_finalize__</span>
        <span class="n">data_dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;abscissa&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="p">(</span><span class="n">nelements</span><span class="p">,)),</span>
            <span class="p">(</span><span class="s1">&#39;ordinate&#39;</span><span class="p">,</span> <span class="n">ordinate_dtype</span><span class="p">,</span> <span class="p">(</span><span class="n">nelements</span><span class="p">,)),</span>
            <span class="p">(</span><span class="s1">&#39;comment1&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment2&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment3&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment4&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment5&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;coordinate&#39;</span><span class="p">,</span> <span class="n">CoordinateArray</span><span class="o">.</span><span class="n">data_dtype</span><span class="p">,</span>
             <span class="p">()</span> <span class="k">if</span> <span class="n">data_dimension</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="p">(</span><span class="n">data_dimension</span><span class="p">,))</span>
        <span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">,</span> <span class="n">subtype</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                                                  <span class="n">data_dtype</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="c1"># Finally, we must return the newly created object:</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array as a FunctionTypes Enum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">GENERAL</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">response_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CoordinateArray corresponding to the response coordinates&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>

    <span class="nd">@response_coordinate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">response_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the response coordinate of the data array&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">reference_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;CoordinateArray corresponding to the response coordinates&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1"> has no reference coordinate&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="nd">@reference_coordinate</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">reference_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set the reference coordinate of the data array&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1"> has no reference coordinate&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of elements in each data array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;ordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">num_coordinates</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of coordinates defining the data array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">data_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of dimensions to the data&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idx_by_el</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        AbscissaIndexExtractor that can be indexed to extract specific elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AbscissaIndexExtractor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">idx_by_ab</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        AbscissaValueExtractor that can be indexed to extract an abscissa range</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">AbscissaValueExtractor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">abscissa_spacing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The spacing of the abscissa in the function.  Returns ValueError if</span>
<span class="sd">        abscissa are not evenly spaced.&quot;&quot;&quot;</span>
        <span class="c1"># Look at the spacing between abscissa</span>
        <span class="n">spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">mean_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">spacing</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">spacing</span><span class="p">,</span> <span class="n">mean_spacing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{:}</span><span class="s1"> do not have evenly spaced abscissa&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">mean_spacing</span>

<div class="viewcode-block" id="NDDataArray.plot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">one_axis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">subplots_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
             <span class="n">plot_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">abscissa_markers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
             <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">abscissa_marker_type</span> <span class="o">=</span> <span class="s1">&#39;vline&#39;</span><span class="p">,</span>
             <span class="n">abscissa_marker_plot_kwargs</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        one_axis : bool, optional</span>
<span class="sd">            Set to True to plot all data on one axis.  Set to False to plot</span>
<span class="sd">            data on multiple subplots.  one_axis can also be set to a</span>
<span class="sd">            matplotlib axis to plot data on an existing axis.  The default is</span>
<span class="sd">            True.</span>
<span class="sd">        subplots_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib subplots function to create the</span>
<span class="sd">            figure and axes. The default is {}.</span>
<span class="sd">        plot_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib plot function. The default is {}.</span>
<span class="sd">        abscissa_markers : ndarray, optional</span>
<span class="sd">            Array containing abscissa values to mark on the plot to denote</span>
<span class="sd">            significant events.</span>
<span class="sd">        abscissa_marker_labels : str or ndarray</span>
<span class="sd">            Array of strings to label the abscissa_markers with, or</span>
<span class="sd">            alternatively a format string that accepts index and abscissa</span>
<span class="sd">            inputs (e.g. &#39;{index:}: {abscissa:0.2f}&#39;).  By default no label</span>
<span class="sd">            will be applied.</span>
<span class="sd">        abscissa_marker_type : str</span>
<span class="sd">            The type of marker to use.  This can either be the string &#39;vline&#39;</span>
<span class="sd">            or a valid matplotlib symbol specifier (e.g. &#39;o&#39;, &#39;x&#39;, &#39;.&#39;).</span>
<span class="sd">        abscissa_marker_plot_kwargs : dict</span>
<span class="sd">            Additional keyword arguments used when plotting the abscissa label</span>
<span class="sd">            markers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib axis or array of axes</span>
<span class="sd">             On which the data were plotted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">abscissa_marker_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abscissa_markers</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">abscissa_marker_labels</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">abscissa</span> <span class="o">=</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">)]</span>
        
        <span class="k">if</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">())):</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">()]))</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">one_axis</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="NDDataArray.plot_image"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.plot_image">[docs]</a>    <span class="k">def</span> <span class="nf">plot_image</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">reduction_function</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">colorbar_scale</span> <span class="o">=</span> <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                   <span class="n">colorbar_min</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">colorbar_max</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="n">image_data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="n">colorbar_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">image_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">image_data</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">colorbar_min</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">colorbar_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">colorbar_min</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">colorbar_max</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">colorbar_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">colorbar_max</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">dof_formatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pos</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">x</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span>
            <span class="k">elif</span> <span class="n">x</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="nb">int</span><span class="p">(</span><span class="n">x</span><span class="p">)]</span><span class="o">.</span><span class="n">coordinate</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ax</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span> <span class="n">layout</span><span class="o">=</span><span class="s1">&#39;constrained&#39;</span><span class="p">)</span>
        <span class="n">im_data</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">image_data</span><span class="p">,</span><span class="n">vmin</span><span class="o">=</span><span class="n">colorbar_min</span><span class="p">,</span><span class="n">vmax</span><span class="o">=</span><span class="n">colorbar_max</span><span class="p">,</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                            <span class="n">interpolation</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="p">[</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="mf">0.5</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mf">0.5</span><span class="p">,</span><span class="o">-</span><span class="mf">0.5</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_locator</span><span class="p">(</span><span class="n">MaxNLocator</span><span class="p">(</span><span class="n">min_n_ticks</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">integer</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_major_formatter</span><span class="p">(</span><span class="n">dof_formatter</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">colorbar_scale</span> <span class="o">==</span> <span class="s1">&#39;log&#39;</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                <span class="n">im_data</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="k">lambda</span> <span class="n">x</span><span class="p">,</span><span class="n">pos</span><span class="p">:</span> <span class="s1">&#39;$10^</span><span class="si">{:}</span><span class="s1">$&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span>
                <span class="n">im_data</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="NDDataArray.reshape_to_matrix"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.reshape_to_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">reshape_to_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">error_if_missing</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reshapes a data array to a matrix with response coordinates along the</span>
<span class="sd">        rows and reference coordinates along the columns</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        error_if_missing : bool</span>
<span class="sd">            If True, an error will be thrown if there are missing data objects</span>
<span class="sd">            when trying to make a matrix of functions (i.e. if a response</span>
<span class="sd">            degree of freedom is missing from one reference).  If False,</span>
<span class="sd">            response coordinates will simply be discarded if they do not exist</span>
<span class="sd">            for all references.  Default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_array : Data Aarray</span>
<span class="sd">            2D Array of NDDataArray</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flattened_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">response_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">)</span>
        <span class="n">reference_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">)</span>
        <span class="n">output_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="p">(</span><span class="n">response_coords</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">reference_coords</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">error_if_missing</span><span class="p">:</span>
            <span class="n">keep_response_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">response_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span><span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">row_index</span><span class="p">,</span> <span class="n">response_coord</span> <span class="ow">in</span> <span class="n">response_coords</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">col_index</span><span class="p">,</span> <span class="n">reference_coord</span> <span class="ow">in</span> <span class="n">reference_coords</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
                <span class="n">current_function</span> <span class="o">=</span> <span class="n">flattened_functions</span><span class="p">[</span>
                    <span class="p">(</span><span class="n">flattened_functions</span><span class="o">.</span><span class="n">response_coordinate</span> <span class="o">==</span> <span class="n">response_coord</span><span class="p">)</span>
                    <span class="o">&amp;</span>
                    <span class="p">(</span><span class="n">flattened_functions</span><span class="o">.</span><span class="n">reference_coordinate</span> <span class="o">==</span> <span class="n">reference_coord</span><span class="p">)]</span>
                <span class="k">if</span> <span class="n">current_function</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">error_if_missing</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;No function exists with reference coordinate </span><span class="si">{:}</span><span class="s1"> and response coordinate </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">str</span><span class="p">(</span><span class="n">reference_coord</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">response_coord</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">keep_response_indices</span><span class="p">[</span><span class="n">row_index</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
                        <span class="k">continue</span>
                <span class="k">if</span> <span class="n">current_function</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Multiple functions exist (</span><span class="si">{:}</span><span class="s1">) with reference coordinate </span><span class="si">{:}</span><span class="s1"> and response coordinate </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="n">current_function</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">reference_coord</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">response_coord</span><span class="p">)))</span>
                <span class="n">output_array</span><span class="p">[</span><span class="n">row_index</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">col_index</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">current_function</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">error_if_missing</span><span class="p">:</span>
            <span class="n">output_array</span> <span class="o">=</span> <span class="n">output_array</span><span class="p">[</span><span class="n">keep_response_indices</span><span class="p">,:]</span>
        <span class="k">return</span> <span class="n">output_array</span></div>

<div class="viewcode-block" id="NDDataArray.extract_elements"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.extract_elements">[docs]</a>    <span class="k">def</span> <span class="nf">extract_elements</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Parses elements from the data array specified by the passed indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices :</span>
<span class="sd">            Any type of indices into a np.ndarray to select the elements to keep</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray</span>
<span class="sd">            Array reduced to specified elements</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_ordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">new_abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">,</span> <span class="n">new_abscissa</span><span class="p">,</span> <span class="n">new_ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.extract_elements_by_abscissa"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.extract_elements_by_abscissa">[docs]</a>    <span class="k">def</span> <span class="nf">extract_elements_by_abscissa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_abscissa</span><span class="p">,</span> <span class="n">max_abscissa</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Extracts elements with abscissa values within the specified range</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_abscissa : float</span>
<span class="sd">            Minimum abscissa value to keep</span>
<span class="sd">        max_abscissa : float</span>
<span class="sd">            Maximum abscissa value to keep.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray</span>
<span class="sd">            Array reduced to specified elements.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">abscissa_indices</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">&gt;=</span> <span class="n">min_abscissa</span><span class="p">)</span> <span class="o">&amp;</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">&lt;=</span> <span class="n">max_abscissa</span><span class="p">)</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">abscissa_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="nb">tuple</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">abscissa_indices</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="n">new_ordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span>
        <span class="n">new_abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">indices</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">,</span> <span class="n">new_abscissa</span><span class="p">,</span> <span class="n">new_ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.join"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.join">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">join</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">data_arrays</span><span class="p">,</span> <span class="n">increment_abscissa</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Joins several data arrays together by concatenating their ordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data_arrays : NDDataArray</span>
<span class="sd">            Arrays to concatenate</span>
<span class="sd">        increment_abscissa : bool, optional</span>
<span class="sd">            Determines how the abscissa concatenation is handled.  If False,</span>
<span class="sd">            the abscissa is left as it was in the original functions.  If True,</span>
<span class="sd">            it will be incremented so it is continuous.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray subclass</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">func_type</span> <span class="o">=</span> <span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">function_type</span>
        <span class="c1"># Verify that coordinates are consistent</span>
        <span class="n">all_coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">array</span><span class="o">.</span><span class="n">coordinate</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">])</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CoordinateArray</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">all_coordinate</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">all_coordinate</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Signals do not have equivalent coordinates&#39;</span><span class="p">)</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coordinate</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">array</span><span class="o">.</span><span class="n">ordinate</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">increment_abscissa</span><span class="p">:</span>
            <span class="n">delta_abscissa</span> <span class="o">=</span> <span class="n">data_arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa_spacing</span>
            <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">*</span><span class="n">delta_abscissa</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">([</span><span class="n">array</span><span class="p">[</span><span class="n">coordinate</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">data_arrays</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">func_type</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.downsample"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.downsample">[docs]</a>    <span class="k">def</span> <span class="nf">downsample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">factor</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Downsample a signal by keeping only every n-th abscissa/ordinate pair.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        factor : int</span>
<span class="sd">            Downsample factor.  Only the factor-th abcissa will be kept.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray</span>
<span class="sd">            The downsampled data object</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new_ordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="n">factor</span><span class="p">]</span>
        <span class="n">new_abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">::</span><span class="n">factor</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">,</span> <span class="n">new_abscissa</span><span class="p">,</span> <span class="n">new_ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.validate_common_abscissa"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.validate_common_abscissa">[docs]</a>    <span class="k">def</span> <span class="nf">validate_common_abscissa</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">allclose_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if all functions have the same abscissa</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **allclose_kwargs : various</span>
<span class="sd">            Arguments to np.allclose to specify tolerances</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        bool</span>
<span class="sd">            True if all functions have the same abscissa</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="o">**</span><span class="n">allclose_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.transform_coordinate_system"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.transform_coordinate_system">[docs]</a>    <span class="k">def</span> <span class="nf">transform_coordinate_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_geometry</span><span class="p">,</span> <span class="n">new_geometry</span><span class="p">,</span> <span class="n">node_id_map</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rotations</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs coordinate system transformations on the data</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        original_geometry : Geometry</span>
<span class="sd">            The Geometry in which the shapes are currently defined</span>
<span class="sd">        new_geometry : Geometry</span>
<span class="sd">            The Geometry in which the shapes are desired to be defined</span>
<span class="sd">        node_id_map : id_map, optional</span>
<span class="sd">            If the original and new geometries do not have common</span>
<span class="sd">            node ids, an id_map can be specified to map the original geometry</span>
<span class="sd">            node ids to new geometry node ids.  The default is None, which means no</span>
<span class="sd">            mapping will occur, and the geometries have common id numbers.</span>
<span class="sd">        rotations : bool, optional</span>
<span class="sd">            If True, also transform rotational degrees of freedom. The default</span>
<span class="sd">            is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray or Subclass</span>
<span class="sd">            A NDDataArray that can now be plotted with the new geometry</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dimension</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">node_id_map</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">original_geometry</span> <span class="o">=</span> <span class="n">original_geometry</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">node_id_map</span><span class="o">.</span><span class="n">from_ids</span><span class="p">)</span>
                <span class="n">original_geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">node_id_map</span><span class="p">(</span><span class="n">original_geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
                <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()[</span><span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">node</span><span class="p">,</span> <span class="n">node_id_map</span><span class="o">.</span><span class="n">from_ids</span><span class="p">)]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">node</span> <span class="o">=</span> <span class="n">node_id_map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
            <span class="n">common_nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">original_geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span> <span class="n">new_geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">),</span>
                                          <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">node</span><span class="p">))</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span>
                <span class="n">common_nodes</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span> <span class="k">if</span> <span class="n">rotations</span> <span class="k">else</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">transform_from_original</span> <span class="o">=</span> <span class="n">original_geometry</span><span class="o">.</span><span class="n">global_deflection</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">transform_to_new</span> <span class="o">=</span> <span class="n">new_geometry</span><span class="o">.</span><span class="n">global_deflection</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span>
            <span class="n">new_data_array</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">new_data_array</span><span class="o">.</span><span class="n">ordinate</span>
            <span class="n">new_shape_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;nij,nkj,nkl-&gt;nil&#39;</span><span class="p">,</span> <span class="n">transform_to_new</span><span class="p">,</span>
                                         <span class="n">transform_from_original</span><span class="p">,</span> <span class="n">shape_matrix</span><span class="p">)</span>
            <span class="n">new_data_array</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">new_shape_matrix</span>
            <span class="k">return</span> <span class="n">new_data_array</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;2D Data not Implemented Yet&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.to_shape_array"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.to_shape_array">[docs]</a>    <span class="k">def</span> <span class="nf">to_shape_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abscissa_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts an NDDataArray to a ShapeArray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        abscissa_values : ndarray, optional</span>
<span class="sd">            Abscissa values at which the shapes will be created. The default is</span>
<span class="sd">            to create shapes at all abscissa values.  If an entry in</span>
<span class="sd">            abscissa_values does not match a value in abscissa, the closest</span>
<span class="sd">            abscissa value will be selected</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the data does not have common abscissa across all functions or if</span>
<span class="sd">            duplicate response coordinates occur in the NDDataArray</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ShapeArray</span>
<span class="sd">            ShapeArray containing the NDDataArray&#39;s ordinate as its shape_matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flat_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_common_abscissa</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data must have common abscissa to transform to `ShapeArray`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">abscissa_values</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">abscissa_indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">abscissa_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">flat_self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">abscissa_values</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Check if there are repeated responses</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data has duplicate response coordinates.  Please ensure that there is only one of each response coordinate in the data.&#39;</span><span class="p">)</span>
        <span class="c1"># Extract the shape matrix</span>
        <span class="n">shape_matrix</span> <span class="o">=</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[:,</span> <span class="n">abscissa_indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="c1"># Create the new shape</span>
        <span class="kn">from</span> <span class="nn">.sdynpy_shape</span> <span class="kn">import</span> <span class="n">shape_array</span>
        <span class="k">return</span> <span class="n">shape_array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">shape_matrix</span><span class="p">,</span> <span class="n">flat_self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="n">abscissa_indices</span><span class="p">])</span></div>

<div class="viewcode-block" id="NDDataArray.zero_pad"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.zero_pad">[docs]</a>    <span class="k">def</span> <span class="nf">zero_pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_samples</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">update_abscissa</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">left</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                 <span class="n">use_next_fast_len</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add zeros to the beginning or end of a signal</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        num_samples : int, optional</span>
<span class="sd">            Number of zeros to add to the function.  If not specified, no zeros</span>
<span class="sd">            are added unless `use_next_fast_len` is `True`</span>
<span class="sd">        update_abscissa : bool, optional</span>
<span class="sd">            If True, modify the abscissa to keep the same abscissa spacing.</span>
<span class="sd">            The function must have equally spaced abscissa for this to work.</span>
<span class="sd">            If False, the added abscissa will have a value of zero.</span>
<span class="sd">            The default is True.</span>
<span class="sd">        left : bool, optional</span>
<span class="sd">            Add zeros to the left side (beginning) of the function. The default</span>
<span class="sd">            is False.  If both `left` and `right` are specified, the zeros will</span>
<span class="sd">            be split half on the left and half on the right.</span>
<span class="sd">        right : bool, optional</span>
<span class="sd">            Add zeros to the right side (end) of the function. The default is</span>
<span class="sd">            True.  If both `left` and `right` are specified, the zeros will be</span>
<span class="sd">            split half on the left and half on the right</span>
<span class="sd">        use_next_fast_len : bool, optional</span>
<span class="sd">            If True, potentially add additional zeros to the value specified by</span>
<span class="sd">            `num_samples` to allow the total length of the final signal to reach</span>
<span class="sd">            fast values for FFT as specified by `scipy.fft.next_fast_len`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray subclass</span>
<span class="sd">            The zero-padded version of the function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">use_next_fast_len</span><span class="p">:</span>
            <span class="n">total_samples</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">next_fast_len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">+</span> <span class="n">num_samples</span><span class="p">)</span>
            <span class="n">num_samples</span> <span class="o">=</span> <span class="n">total_samples</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span>
        <span class="c1"># Create the additional zeros vectors</span>
        <span class="k">if</span> <span class="n">left</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">right</span><span class="p">):</span>
            <span class="n">left_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
            <span class="n">right_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">left</span><span class="p">)</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">right_samples</span> <span class="o">=</span> <span class="n">num_samples</span>
            <span class="n">left_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">left</span> <span class="ow">and</span> <span class="n">right</span><span class="p">:</span>
            <span class="n">left_samples</span> <span class="o">=</span> <span class="n">num_samples</span><span class="o">//</span><span class="mi">2</span>
            <span class="n">right_samples</span> <span class="o">=</span> <span class="n">num_samples</span> <span class="o">-</span> <span class="n">left_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">left_samples</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">right_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">added_zeros_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">left_samples</span><span class="p">,))</span>
        <span class="n">added_zeros_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">right_samples</span><span class="p">,))</span>

        <span class="n">new_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">added_zeros_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">added_zeros_right</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">update_abscissa</span><span class="p">:</span>
            <span class="n">new_abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">new_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">added_zeros_left</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">new_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">added_zeros_left</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">added_zeros_right</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">,</span> <span class="n">new_abscissa</span><span class="p">,</span> <span class="n">new_ordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.interpolate"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.interpolate">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interpolated_abscissa</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates the NDDataArray using SciPy&#39;s interp1d.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        interpolated_abscissa : ndarray</span>
<span class="sd">            Abscissa values at which to interpolate the function.  If</span>
<span class="sd">            multi-dimensional, it will be flattened.</span>
<span class="sd">        kind : str or int, optional</span>
<span class="sd">            Specifies the kind of interpolation as a string or as an integer</span>
<span class="sd">            specifying the order of the spline interpolator to use. The string</span>
<span class="sd">            has to be one of &#39;linear&#39;, &#39;nearest&#39;, &#39;nearest-up&#39;, &#39;zero&#39;,</span>
<span class="sd">            &#39;slinear&#39;, &#39;quadratic&#39;, &#39;cubic&#39;, &#39;previous&#39;, or &#39;next&#39;.</span>
<span class="sd">            &#39;zero&#39;, &#39;slinear&#39;, &#39;quadratic&#39; and &#39;cubic&#39; refer to a spline</span>
<span class="sd">            interpolation of zeroth, first, second or third order; &#39;previous&#39;</span>
<span class="sd">            and &#39;next&#39; simply return the previous or next value of the point;</span>
<span class="sd">            &#39;nearest-up&#39; and &#39;nearest&#39; differ when interpolating half-integers</span>
<span class="sd">            (e.g. 0.5, 1.5) in that &#39;nearest-up&#39; rounds up and &#39;nearest&#39; rounds</span>
<span class="sd">            down. Default is &#39;linear&#39;.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            Additional arguments to scipy.interpolate.interp1d.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray :</span>
<span class="sd">            Array with interpolated arguments</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Flatten the abscissa</span>
        <span class="n">interpolated_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">interpolated_abscissa</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Create the output class</span>
        <span class="n">output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">interpolated_abscissa</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">output</span><span class="o">.</span><span class="n">coordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span>
        <span class="n">output</span><span class="o">.</span><span class="n">comment1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span>
        <span class="n">output</span><span class="o">.</span><span class="n">comment2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span>
        <span class="n">output</span><span class="o">.</span><span class="n">comment3</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span>
        <span class="n">output</span><span class="o">.</span><span class="n">comment4</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span>
        <span class="n">output</span><span class="o">.</span><span class="n">comment5</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span>
        <span class="n">output</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">=</span> <span class="n">interpolated_abscissa</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_common_abscissa</span><span class="p">():</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span>
            <span class="n">interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">interpolated_ordinate</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">interpolated_abscissa</span><span class="p">)</span>
            <span class="n">output</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">interpolated_ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">function</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">abscissa</span>
                <span class="n">y</span> <span class="o">=</span> <span class="n">function</span><span class="o">.</span><span class="n">ordinate</span>
                <span class="n">interp</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="n">kind</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">interpolated_ordinate</span> <span class="o">=</span> <span class="n">interp</span><span class="p">(</span><span class="n">interpolated_abscissa</span><span class="p">)</span>
                <span class="n">output</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">interpolated_ordinate</span>
        <span class="k">return</span> <span class="n">output</span></div>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Selects specific data items by index or by coordinate</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        key : CoordinateArray or indices</span>
<span class="sd">            If key is a CoordinateArray, the returned NDDataArray will have the</span>
<span class="sd">            specified coordinates.  Otherwise, any form of indices can be passed</span>
<span class="sd">            to select specific data arrays.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray</span>
<span class="sd">            Data Array partitioned to the selected arrays.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">CoordinateArray</span><span class="p">):</span>
            <span class="n">coordinate_dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">ndim</span>
            <span class="n">output_shape</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="n">coordinate_dim</span><span class="p">]</span>
            <span class="n">flat_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">index_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">output_shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">positive_coordinates</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">flat_self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">output_shape</span><span class="p">):</span>
                <span class="n">positive_key</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">index</span><span class="p">])</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index_array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
                        <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">positive_coordinates</span> <span class="o">==</span> <span class="n">positive_key</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">IndexError</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Coordinate </span><span class="si">{:}</span><span class="s1"> not found in data array&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="n">index</span><span class="p">])))</span>
            <span class="n">return_shape</span> <span class="o">=</span> <span class="n">flat_self</span><span class="p">[</span><span class="n">index_array</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MULTIPLE_COHERENCE</span><span class="p">]:</span>
                <span class="n">ordinate_multiplication_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ordinate_multiplication_array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">return_shape</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">direction</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">direction</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Set up for broadcasting</span>
            <span class="n">ordinate_multiplication_array</span> <span class="o">=</span> <span class="n">ordinate_multiplication_array</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="c1"># Remove zeros and replace with 1s because we don&#39;t flip signs if</span>
            <span class="c1"># there is no direction associated with the coordinate</span>
            <span class="n">ordinate_multiplication_array</span><span class="p">[</span><span class="n">ordinate_multiplication_array</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">return_shape</span><span class="o">.</span><span class="n">coordinate</span> <span class="o">=</span> <span class="n">key</span>
            <span class="n">return_shape</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">ordinate_multiplication_array</span>
            <span class="k">return</span> <span class="n">return_shape</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">output</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;coordinate&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CoordinateArray</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">output</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{:}</span><span class="s1"> with shape </span><span class="si">{:}</span><span class="s1"> and </span><span class="si">{:}</span><span class="s1"> elements per function&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="s1">&#39; x &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">+=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">+=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">-=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">-=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">/=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">/=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__pow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">**=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">**=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">+=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">+=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">-</span> <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">val</span> <span class="o">-</span> <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">val</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__rtruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">/</span> <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">val</span> <span class="o">/</span> <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__rpow__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">NDDataArray</span><span class="p">):</span>
            <span class="c1"># Check if abscissa are equivalent</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">==</span> <span class="n">val</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s1">&#39;Binary operations on NDDataArrays require equivalent or broadcastably equivalent abscissa&#39;</span><span class="p">)</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">val</span><span class="o">.</span><span class="n">ordinate</span><span class="o">**</span><span class="n">this</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">val</span><span class="o">**</span><span class="n">this</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">return</span> <span class="n">this</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">this</span> <span class="o">=</span> <span class="n">deepcopy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">this</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">this</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">this</span>

<div class="viewcode-block" id="NDDataArray.min"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.min">[docs]</a>    <span class="k">def</span> <span class="nf">min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">min_args</span><span class="p">,</span> <span class="o">**</span><span class="n">min_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the minimum ordinate in the data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduction : function, optional</span>
<span class="sd">            Optional function to modify the data, e.g. to select minimum of the</span>
<span class="sd">            absolute value. The default is None.</span>
<span class="sd">        *min_args : various</span>
<span class="sd">            Additional arguments passed to np.min</span>
<span class="sd">        **min_kwargs : various</span>
<span class="sd">            Additional keyword arguments passed to np.min</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Value</span>
<span class="sd">            Minimum value in the ordinate.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reduction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">*</span><span class="n">min_args</span><span class="p">,</span> <span class="o">**</span><span class="n">min_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">reduction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span> <span class="o">*</span><span class="n">min_args</span><span class="p">,</span> <span class="o">**</span><span class="n">min_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.max"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.max">[docs]</a>    <span class="k">def</span> <span class="nf">max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">max_args</span><span class="p">,</span> <span class="o">**</span><span class="n">max_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum ordinate in the data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduction : function, optional</span>
<span class="sd">            Optional function to modify the data, e.g. to select maximum of the</span>
<span class="sd">            absolute value. The default is None.</span>
<span class="sd">        *max_args : various</span>
<span class="sd">            Additional arguments passed to np.max</span>
<span class="sd">        **max_kwargs : various</span>
<span class="sd">            Additional keyword arguments passed to np.max</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Value</span>
<span class="sd">            Maximum value in the ordinate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reduction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">*</span><span class="n">max_args</span><span class="p">,</span> <span class="o">**</span><span class="n">max_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">reduction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span> <span class="o">*</span><span class="n">max_args</span><span class="p">,</span> <span class="o">**</span><span class="n">max_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.argmin"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.argmin">[docs]</a>    <span class="k">def</span> <span class="nf">argmin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">argmin_args</span><span class="p">,</span> <span class="o">**</span><span class="n">argmin_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of the minimum ordinate in the data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduction : function, optional</span>
<span class="sd">            Optional function to modify the data, e.g. to select minimum of the</span>
<span class="sd">            absolute value. The default is None.</span>
<span class="sd">        *argmin_args : various</span>
<span class="sd">            Additional arguments passed to np.argmax</span>
<span class="sd">        **argmin_kwargs : various</span>
<span class="sd">            Additional keyword arguments passed to np.argmax</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Index of the minimum of the flattened ordinate.  Use</span>
<span class="sd">            np.unravel_index with self.ordinate.shape to get the unflattened</span>
<span class="sd">            index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reduction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">*</span><span class="n">argmin_args</span><span class="p">,</span> <span class="o">**</span><span class="n">argmin_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">reduction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span> <span class="o">*</span><span class="n">argmin_args</span><span class="p">,</span> <span class="o">**</span><span class="n">argmin_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.argmax"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.argmax">[docs]</a>    <span class="k">def</span> <span class="nf">argmax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reduction</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">argmax_args</span><span class="p">,</span> <span class="o">**</span><span class="n">argmax_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the index of the maximum ordinate in the data array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reduction : function, optional</span>
<span class="sd">            Optional function to modify the data, e.g. to select maximum of the</span>
<span class="sd">            absolute value. The default is None.</span>
<span class="sd">        *argmax_args : various</span>
<span class="sd">            Additional arguments passed to np.argmax</span>
<span class="sd">        **argmax_kwargs : various</span>
<span class="sd">            Additional keyword arguments passed to np.argmax</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            Index of the maximum of the flattened ordinate.  Use</span>
<span class="sd">            np.unravel_index with self.ordinate.shape to get the unflattened</span>
<span class="sd">            index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reduction</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">*</span><span class="n">argmax_args</span><span class="p">,</span> <span class="o">**</span><span class="n">argmax_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">reduction</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span> <span class="o">*</span><span class="n">argmax_args</span><span class="p">,</span> <span class="o">**</span><span class="n">argmax_kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.to_imat_struct_array"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.to_imat_struct_array">[docs]</a>    <span class="k">def</span> <span class="nf">to_imat_struct_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Version</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">SetRecord</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">CreateDate</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ModifyDate</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                             <span class="n">OwnerName</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">AbscissaDataType</span><span class="o">=</span><span class="n">SpecificDataType</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">,</span> <span class="n">AbscissaTypeQual</span><span class="o">=</span><span class="n">TypeQual</span><span class="o">.</span><span class="n">TRANSLATION</span><span class="p">,</span>
                             <span class="n">AbscissaAxisLab</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">AbscissaUnitsLab</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                             <span class="n">OrdNumDataType</span><span class="o">=</span><span class="n">SpecificDataType</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">,</span> <span class="n">OrdNumTypeQual</span><span class="o">=</span><span class="n">TypeQual</span><span class="o">.</span><span class="n">TRANSLATION</span><span class="p">,</span>
                             <span class="n">OrdDenDataType</span><span class="o">=</span><span class="n">SpecificDataType</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">,</span> <span class="n">OrdDenTypeQual</span><span class="o">=</span><span class="n">TypeQual</span><span class="o">.</span><span class="n">TRANSLATION</span><span class="p">,</span>
                             <span class="n">OrdinateAxisLab</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">OrdinateUnitsLab</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                             <span class="n">ZAxisDataType</span><span class="o">=</span><span class="n">SpecificDataType</span><span class="o">.</span><span class="n">UNKNOWN</span><span class="p">,</span> <span class="n">ZAxisTypeQual</span><span class="o">=</span><span class="n">TypeQual</span><span class="o">.</span><span class="n">TRANSLATION</span><span class="p">,</span>
                             <span class="n">ZGeneralValue</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ZRPMValue</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ZOrderValue</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ZTimeValue</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">UserValue1</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">UserValue2</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">UserValue3</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">UserValue4</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">SamplingType</span><span class="o">=</span><span class="s1">&#39;Dynamic&#39;</span><span class="p">,</span> <span class="n">WeightingType</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">WindowType</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span>
                             <span class="n">AmplitudeUnits</span><span class="o">=</span><span class="s1">&#39;Unknown&#39;</span><span class="p">,</span> <span class="n">Normalization</span><span class="o">=</span><span class="s1">&#39;Unknown&#39;</span><span class="p">,</span> <span class="n">OctaveFormat</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">OctaveAvgType</span><span class="o">=</span><span class="s1">&#39;None&#39;</span><span class="p">,</span> <span class="n">ExpDampingFact</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">PulsesPerRev</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">MeasurementRun</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                             <span class="n">LoadCase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">IRIGTime</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span>
                             <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Matlab structure that can be read the IMAT toolbox.</span>

<span class="sd">        This structure can be read by the IMAT toolbox in Matlab to create an</span>
<span class="sd">        imat_fn object.  Note this is generally a slower function than</span>
<span class="sd">        to_imat_struct.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Version : int, optional</span>
<span class="sd">            The version number of the function. The default is 1.</span>
<span class="sd">        SetRecord : int, optional</span>
<span class="sd">            The set record of the function. The default is 0.</span>
<span class="sd">        CreateDate : datetime, optional</span>
<span class="sd">            The date that the function was created. The default is Now.</span>
<span class="sd">        ModifyDate : datetime, optional</span>
<span class="sd">            The date that the function was modified. The default is Now.</span>
<span class="sd">        OwnerName : str, optional</span>
<span class="sd">            The owner of the dataset. The default is &#39;&#39;.</span>
<span class="sd">        AbscissaDataType : SpecificDataType, optional</span>
<span class="sd">            The type of data associated with the Abscissa of the function.</span>
<span class="sd">            The default is SpecificDataType.UNKNOWN.</span>
<span class="sd">        AbscissaTypeQual : TypeQual, optional</span>
<span class="sd">            The qualifier associated with the abscissa of the function. The</span>
<span class="sd">            default is TypeQual.TRANSLATION.</span>
<span class="sd">        AbscissaAxisLab : str, optional</span>
<span class="sd">            String used to label the abscissa axis. The default is &#39;&#39;.</span>
<span class="sd">        AbscissaUnitsLab : str, optional</span>
<span class="sd">            String used to label the units on the abscissa axis. The default is &#39;&#39;.</span>
<span class="sd">        OrdNumDataType : SpecificDataType, optional</span>
<span class="sd">            The type of data associated with the numerator of the ordinate of</span>
<span class="sd">            the function. The default is SpecificDataType.UNKNOWN.</span>
<span class="sd">        OrdNumTypeQual : TypeQual, optional</span>
<span class="sd">            The qualifier associated with the numerator of the ordinate of the</span>
<span class="sd">            function. The default is TypeQual.TRANSLATION.</span>
<span class="sd">        OrdDenDataType : SpecificDataType, optional</span>
<span class="sd">            The type of data associated with the denominator of the ordinate of</span>
<span class="sd">            the function. The default is SpecificDataType.UNKNOWN.</span>
<span class="sd">        OrdDenTypeQual : TypeQual, optional</span>
<span class="sd">            The qualifier associated with the denominator of the ordinate of the</span>
<span class="sd">            function. The default is TypeQual.TRANSLATION.</span>
<span class="sd">        OrdinateAxisLab : str, optional</span>
<span class="sd">            String used to label the ordinate axis. The default is &#39;&#39;.</span>
<span class="sd">        OrdinateUnitsLab : TYPE, optional</span>
<span class="sd">            String used to label the units on the ordinate axis. The default is &#39;&#39;.</span>
<span class="sd">        ZAxisDataType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is SpecificDataType.UNKNOWN.</span>
<span class="sd">        ZAxisTypeQual : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is TypeQual.TRANSLATION.</span>
<span class="sd">        ZGeneralValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        ZRPMValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        ZOrderValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        ZTimeValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        UserValue1 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        UserValue2 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        UserValue3 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        UserValue4 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        SamplingType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;Dynamic&#39;.</span>
<span class="sd">        WeightingType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;None&#39;.</span>
<span class="sd">        WindowType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;None&#39;.</span>
<span class="sd">        AmplitudeUnits : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;Unknown&#39;.</span>
<span class="sd">        Normalization : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;Unknown&#39;.</span>
<span class="sd">        OctaveFormat : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        OctaveAvgType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;None&#39;.</span>
<span class="sd">        ExpDampingFact : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        PulsesPerRev : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        MeasurementRun : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        LoadCase : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is 0.</span>
<span class="sd">        IRIGTime : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is &#39;&#39;.</span>
<span class="sd">        verbose : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is False.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_struct : np.ndarray</span>
<span class="sd">            A numpy structured array that can be saved to a mat file using</span>
<span class="sd">            scipy.io.savemat.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">flat_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="p">[(</span><span class="s1">&#39;FunctionType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;Version&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;SetRecord&#39;</span><span class="p">,</span> <span class="s1">&#39;int&#39;</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ResponseCoord&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ReferenceCoord&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;IDLine1&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;IDLine2&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;IDLine3&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;IDLine4&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;CreateDate&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ModifyDate&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OwnerName&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;Abscissa&#39;</span><span class="p">,</span> <span class="s1">&#39;float&#39;</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="p">,)),</span>
                 <span class="p">(</span><span class="s1">&#39;Ordinate&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaDataType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaTypeQual&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaExpLength&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaExpForce&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaExpTemp&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaExpTime&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaAxisLab&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AbscissaUnitsLab&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdinateType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdNumDataType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdNumTypeQual&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdNumExpLength&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdNumExpForce&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdNumExpTemp&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdNumExpTime&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdDenDataType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdDenTypeQual&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdDenExpLength&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdDenExpForce&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdDenExpTemp&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdDenExpTime&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdinateAxisLab&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OrdinateUnitsLab&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZAxisDataType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZAxisTypeQual&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZAxisExpLength&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZAxisExpForce&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZAxisExpTemp&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZAxisExpTime&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZGeneralValue&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZRPMValue&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZTimeValue&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ZOrderValue&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;UserValue1&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;UserValue2&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;UserValue3&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;UserValue4&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;SamplingType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;WeightingType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;WindowType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;AmplitudeUnits&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;Normalization&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OctaveFormat&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;OctaveAvgType&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;ExpDampingFact&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;PulsesPerRev&#39;</span><span class="p">,</span> <span class="nb">float</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;MeasurementRun&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;LoadCase&#39;</span><span class="p">,</span> <span class="nb">int</span><span class="p">),</span>
                 <span class="p">(</span><span class="s1">&#39;IRIGTime&#39;</span><span class="p">,</span> <span class="nb">object</span><span class="p">)</span>
                 <span class="p">]</span>
        <span class="n">output_struct</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                                 <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Looping through functions for initial data&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">flat_self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">():</span>
                <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ResponseCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span>
                <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ReferenceCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ResponseCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ReferenceCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;ReferenceCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Abscissa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">abscissa</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;Ordinate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">ordinate</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;IDLine1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">comment1</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;IDLine2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">comment2</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;IDLine3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">comment3</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;IDLine4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">comment4</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="s1">&#39;FunctionType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_imat_function_type_inverse_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning Version&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;Version&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">Version</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning SetRecord&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;SetRecord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">SetRecord</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">CreateDate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">CreateDate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%b-%y    %H:%M:%S&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning CreateDate&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;CreateDate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">CreateDate</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ModifyDate</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ModifyDate</span> <span class="o">=</span> <span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">()</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%b-%y    %H:%M:%S&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning Modify Date&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ModifyDate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ModifyDate</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning OwnerName&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OwnerName&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OwnerName</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Abscissa</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning Abscissa Data&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaDataType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_specific_data_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaTypeQual&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_type_qual_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">qual</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))):</span>
            <span class="n">exponents</span> <span class="o">=</span> <span class="n">_exponent_table</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span>
            <span class="p">(</span><span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaExpLength&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaExpForce&#39;</span><span class="p">],</span>
             <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaExpTemp&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaExpTime&#39;</span><span class="p">]</span>
             <span class="p">)</span> <span class="o">=</span> <span class="n">exponents</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="k">if</span> <span class="n">qual</span> <span class="o">==</span> <span class="n">TypeQual</span><span class="o">.</span><span class="n">ROTATION</span> <span class="k">else</span> <span class="n">exponents</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaAxisLab&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaAxisLab</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AbscissaUnitsLab&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaUnitsLab</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning Ordinate Numerator Data&#39;</span><span class="p">)</span>
        <span class="c1"># Ordinate Numerator</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdNumDataType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_specific_data_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OrdNumDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdNumTypeQual&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_type_qual_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OrdNumTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">qual</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))):</span>
            <span class="n">exponents</span> <span class="o">=</span> <span class="n">_exponent_table</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span>
            <span class="p">(</span><span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdNumExpLength&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdNumExpForce&#39;</span><span class="p">],</span>
             <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdNumExpTemp&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdNumExpTime&#39;</span><span class="p">]</span>
             <span class="p">)</span> <span class="o">=</span> <span class="n">exponents</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="k">if</span> <span class="n">qual</span> <span class="o">==</span> <span class="n">TypeQual</span><span class="o">.</span><span class="n">ROTATION</span> <span class="k">else</span> <span class="n">exponents</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="c1"># Ordinate Denominator</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning Ordinate Denominator Data&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdDenDataType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_specific_data_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OrdDenDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdDenTypeQual&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_type_qual_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OrdDenTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">qual</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))):</span>
            <span class="n">exponents</span> <span class="o">=</span> <span class="n">_exponent_table</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span>
            <span class="p">(</span><span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdDenExpLength&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdDenExpForce&#39;</span><span class="p">],</span>
             <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdDenExpTemp&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdDenExpTime&#39;</span><span class="p">]</span>
             <span class="p">)</span> <span class="o">=</span> <span class="n">exponents</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="k">if</span> <span class="n">qual</span> <span class="o">==</span> <span class="n">TypeQual</span><span class="o">.</span><span class="n">ROTATION</span> <span class="k">else</span> <span class="n">exponents</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdinateAxisLab&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OrdinateAxisLab</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdinateUnitsLab&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OrdinateUnitsLab</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;complex128&#39;</span><span class="p">:</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdinateType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="s1">&#39;Complex Double&#39;</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;complex64&#39;</span><span class="p">:</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdinateType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="s1">&#39;Complex Single&#39;</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float64&#39;</span><span class="p">:</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdinateType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="s1">&#39;Real Double&#39;</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="s1">&#39;float32&#39;</span><span class="p">:</span>
            <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OrdinateType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="s1">&#39;Real Single&#39;</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="c1"># Z Axis</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning ZAxis Data&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZAxisDataType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_specific_data_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ZAxisDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZAxisTypeQual&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_type_qual_names_vectorized</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ZAxisTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">qual</span><span class="p">,</span> <span class="n">datatype</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaTypeQual</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AbscissaDataType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">))):</span>
            <span class="n">exponents</span> <span class="o">=</span> <span class="n">_exponent_table</span><span class="p">[</span><span class="n">datatype</span><span class="p">]</span>
            <span class="p">(</span><span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZAxisExpLength&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZAxisExpForce&#39;</span><span class="p">],</span>
             <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZAxisExpTemp&#39;</span><span class="p">],</span> <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZAxisExpTime&#39;</span><span class="p">]</span>
             <span class="p">)</span> <span class="o">=</span> <span class="n">exponents</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="k">if</span> <span class="n">qual</span> <span class="o">==</span> <span class="n">TypeQual</span><span class="o">.</span><span class="n">ROTATION</span> <span class="k">else</span> <span class="n">exponents</span><span class="p">[:</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZGeneralValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ZGeneralValue</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZRPMValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ZRPMValue</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZOrderValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ZOrderValue</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ZTimeValue&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ZTimeValue</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning User Values&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;UserValue1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">UserValue1</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;UserValue2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">UserValue2</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;UserValue3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">UserValue3</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;UserValue4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">UserValue4</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">verbose</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Assigning Misc Data&#39;</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;SamplingType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">SamplingType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;WeightingType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">WeightingType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;WindowType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">WindowType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;AmplitudeUnits&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">AmplitudeUnits</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;Normalization&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">Normalization</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OctaveFormat&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OctaveFormat</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;OctaveAvgType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">OctaveAvgType</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;ExpDampingFact&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">ExpDampingFact</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;PulsesPerRev&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">PulsesPerRev</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;MeasurementRun&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">MeasurementRun</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;LoadCase&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">LoadCase</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">output_struct</span><span class="p">[</span><span class="s1">&#39;IRIGTime&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">IRIGTime</span><span class="p">,</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">output_struct</span></div>

<div class="viewcode-block" id="NDDataArray.save"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.save">[docs]</a>    <span class="k">def</span> <span class="nf">save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Save the array to a numpy file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename that the array will be saved to.  Will be appended with</span>
<span class="sd">            .npz if not specified in the filename</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">data</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">),</span>
                 <span class="n">function_type</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="o">.</span><span class="n">value</span><span class="p">)</span></div>

<div class="viewcode-block" id="NDDataArray.load"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.load">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">load</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Load in the specified file into a SDynPy array object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename : str</span>
<span class="sd">            Filename specifying the file to load.  If the filename has</span>
<span class="sd">            extension .unv or .uff, it will be loaded as a universal file.</span>
<span class="sd">            Otherwise, it will be loaded as a NumPy file.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        AttributeError</span>
<span class="sd">            Raised if a unv file is loaded from a class that does not have a</span>
<span class="sd">            from_unv attribute defined.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cls</span>
<span class="sd">            SDynpy array of the appropriate type from the loaded file.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span><span class="p">[</span><span class="o">-</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;.unv&#39;</span><span class="p">,</span> <span class="s1">&#39;.uff&#39;</span><span class="p">]:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">..fileio.sdynpy_uff</span> <span class="kn">import</span> <span class="n">readunv</span>
                <span class="n">unv_dict</span> <span class="o">=</span> <span class="n">readunv</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">from_unv</span><span class="p">(</span><span class="n">unv_dict</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Class </span><span class="si">{:}</span><span class="s1"> has no from_unv attribute defined&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">cls</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fn_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">allow_pickle</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">fn_data</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span>
                <span class="n">_function_type_class_map</span><span class="p">[</span><span class="n">FunctionTypes</span><span class="p">(</span><span class="n">fn_data</span><span class="p">[</span><span class="s1">&#39;function_type&#39;</span><span class="p">])])</span></div>

<div class="viewcode-block" id="NDDataArray.to_imat_struct"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.to_imat_struct">[docs]</a>    <span class="k">def</span> <span class="nf">to_imat_struct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Version</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">SetRecord</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">CreateDate</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">ModifyDate</span><span class="p">:</span> <span class="n">datetime</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">OwnerName</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">AbscissaDataType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">AbscissaTypeQual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">AbscissaAxisLab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">AbscissaUnitsLab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">OrdNumDataType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OrdNumTypeQual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">OrdDenDataType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OrdDenTypeQual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">OrdinateAxisLab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OrdinateUnitsLab</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">ZAxisDataType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ZAxisTypeQual</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">ZGeneralValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ZRPMValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ZOrderValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ZTimeValue</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">UserValue1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">UserValue2</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">UserValue3</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">UserValue4</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">SamplingType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">WeightingType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">WindowType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">AmplitudeUnits</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">Normalization</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">OctaveFormat</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">OctaveAvgType</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ExpDampingFact</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">PulsesPerRev</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">MeasurementRun</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                       <span class="n">LoadCase</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">IRIGTime</span><span class="o">=</span><span class="kc">None</span>
                       <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Matlab structure that can be read the IMAT toolbox.</span>

<span class="sd">        This structure can be read by the IMAT toolbox in Matlab to create an</span>
<span class="sd">        imat_fn object.  Note this is generally a faster function than</span>
<span class="sd">        to_imat_struct_array.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Version : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        SetRecord : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        CreateDate : datetime, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ModifyDate : datetime, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OwnerName : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        AbscissaDataType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        AbscissaTypeQual : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        AbscissaAxisLab : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        AbscissaUnitsLab : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OrdNumDataType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OrdNumTypeQual : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OrdDenDataType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OrdDenTypeQual : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OrdinateAxisLab : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OrdinateUnitsLab : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ZAxisDataType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ZAxisTypeQual : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ZGeneralValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ZRPMValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ZOrderValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ZTimeValue : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        UserValue1 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        UserValue2 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        UserValue3 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        UserValue4 : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        SamplingType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        WeightingType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        WindowType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        AmplitudeUnits : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        Normalization : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OctaveFormat : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        OctaveAvgType : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        ExpDampingFact : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        PulsesPerRev : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        MeasurementRun : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        LoadCase : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>
<span class="sd">        IRIGTime : TYPE, optional</span>
<span class="sd">            DESCRIPTION. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        data_dict : TYPE</span>
<span class="sd">            DESCRIPTION.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">locals</span><span class="p">()</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="o">==</span>
                     <span class="s1">&#39;self&#39;</span><span class="p">}</span>  <span class="c1"># Get all the local variables that have been defined</span>
        <span class="n">data_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;Ordinate&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;Abscissa&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;IDLine1&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;IDLine2&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;IDLine3&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;IDLine4&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;ResponseCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">response_coordinate</span><span class="o">.</span><span class="n">string_array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;ReferenceCoord&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="o">.</span><span class="n">string_array</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="n">data_dict</span><span class="p">[</span><span class="s1">&#39;FunctionType&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_imat_function_type_inverse_map</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">argument</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">arguments</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">datetime</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">strftime</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%d</span><span class="s1">-%b-%y    %H:%M:%S&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">SpecificDataType</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="n">data_dict</span><span class="p">[</span><span class="n">argument</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>
        <span class="k">return</span> <span class="n">data_dict</span></div>

    <span class="c1"># def to_unv(self,function_id=1,version_number=1,load_case = 0,</span>
    <span class="c1">#            response_entity_name = None,reference_entity_name = None,</span>
    <span class="c1">#            abscissa_data_type = None,abscissa_length_exponent = None,</span>
    <span class="c1">#            abscissa_force_exponent = None, abscissa_temp_exponent = None,</span>
    <span class="c1">#            abscissa_axis_label = None,abscissa_units_label = None,</span>
    <span class="c1">#            ordinate_num_data_type = None,ordinate_num_length_exponent = None,</span>
    <span class="c1">#            ordinate_num_force_exponent = None,ordinate_num_temp_exponent = None,</span>
    <span class="c1">#            ordinate_num_axis_label = None,ordinate_num_units_label = None,</span>
    <span class="c1">#            ordinate_den_data_type = None,ordinate_den_length_exponent = None,</span>
    <span class="c1">#            ordinate_den_force_exponent = None,ordinate_den_temp_exponent = None,</span>
    <span class="c1">#            ordinate_den_axis_label = None,ordinate_den_units_label = None,</span>
    <span class="c1">#            zaxis_data_type = None,zaxis_length_exponent = None,</span>
    <span class="c1">#            zaxis_force_exponent = None,zaxis_temp_exponent = None,</span>
    <span class="c1">#            zaxis_axis_label = None,zaxis_units_label = None,zaxis_value= None):</span>
    <span class="c1">#     unv_data_dict = {58:[]}</span>
    <span class="c1">#     for key,func in self.ndenumerate():</span>
    <span class="c1">#         dataset_58 = sdpy.unv.dataset_58.Sdynpy_UFF_Dataset_58(</span>
    <span class="c1">#             func.comment1,func.comment2,func.comment3,func.comment4,</span>
    <span class="c1">#             func.comment5,func.function_type.value,)</span>

<div class="viewcode-block" id="NDDataArray.from_unv"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.from_unv">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_unv</span><span class="p">(</span><span class="n">unv_data_dict</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a data array from a unv dictionary from read_unv</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        unv_data_dict : dict</span>
<span class="sd">            Dictionary containing data from read_unv</span>
<span class="sd">        squeeze : bool, optional</span>
<span class="sd">            Automatically reduce dimension of the read data if possible.</span>
<span class="sd">            The default is True.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        return_functions : NDDataArray</span>
<span class="sd">            Data read from unv</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">fn_datasets</span> <span class="o">=</span> <span class="n">unv_data_dict</span><span class="p">[</span><span class="mi">58</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NDDataArray</span><span class="p">((</span><span class="mi">0</span><span class="p">,),</span><span class="n">nelements</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="n">data_dimension</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">fn_types</span> <span class="o">=</span> <span class="p">[</span><span class="n">dataset</span><span class="o">.</span><span class="n">function_type</span> <span class="k">for</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">fn_datasets</span><span class="p">]</span>
        <span class="n">function_type_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">fn_dataset</span><span class="p">,</span> <span class="n">fn_type</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">fn_datasets</span><span class="p">,</span> <span class="n">fn_types</span><span class="p">):</span>
            <span class="n">fn_type_enum</span> <span class="o">=</span> <span class="n">FunctionTypes</span><span class="p">(</span><span class="n">fn_type</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fn_type_enum</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">function_type_dict</span><span class="p">:</span>
                <span class="n">function_type_dict</span><span class="p">[</span><span class="n">fn_type_enum</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">function_type_dict</span><span class="p">[</span><span class="n">fn_type_enum</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">fn_dataset</span><span class="p">)</span>
        <span class="n">return_functions</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">function_list</span> <span class="ow">in</span> <span class="n">function_type_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">abscissa</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">coordinate</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">comment1</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">comment2</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">comment3</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">comment4</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">comment5</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">function_list</span><span class="p">:</span>
                <span class="n">abscissa</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span>
                <span class="n">ordinate</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span>
                <span class="n">coordinate</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">response_node</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">response_direction</span><span class="p">),</span>
                                   <span class="n">coordinate_array</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">reference_node</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">reference_direction</span><span class="p">)))</span>
                <span class="n">comment1</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">idline1</span><span class="p">)</span>
                <span class="n">comment2</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">idline2</span><span class="p">)</span>
                <span class="n">comment3</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">idline3</span><span class="p">)</span>
                <span class="n">comment4</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">idline4</span><span class="p">)</span>
                <span class="n">comment5</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">idline5</span><span class="p">)</span>
            <span class="n">return_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">data_array</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">abscissa</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ordinate</span><span class="p">),</span>
                           <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CoordinateArray</span><span class="p">),</span>
                           <span class="n">comment1</span><span class="p">,</span>
                           <span class="n">comment2</span><span class="p">,</span>
                           <span class="n">comment3</span><span class="p">,</span>
                           <span class="n">comment4</span><span class="p">,</span>
                           <span class="n">comment5</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_functions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">squeeze</span><span class="p">:</span>
            <span class="n">return_functions</span> <span class="o">=</span> <span class="n">return_functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">return_functions</span></div>

    <span class="n">from_uff</span> <span class="o">=</span> <span class="n">from_unv</span>
    
<div class="viewcode-block" id="NDDataArray.get_reciprocal_data"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.get_reciprocal_data">[docs]</a>    <span class="k">def</span> <span class="nf">get_reciprocal_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_indices</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets reciprocal pairs of data from an NDDataArray.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_indices : bool, optional</span>
<span class="sd">            If True, it will return a set of indices into the original array</span>
<span class="sd">            that extract the reciprocal functions. If False, then the</span>
<span class="sd">            reciprocal functions are returned directly.  The default is False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the data does not have reference and response coordinates, the</span>
<span class="sd">            method will raise a ValueError.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray or NDDataArray subclass</span>
<span class="sd">            If return_indices is True, this will return the indices into the</span>
<span class="sd">            original array that extract the reciprocal data.  If return_indices</span>
<span class="sd">            is False, this will return the reciprocal NDDataArrays directly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if there are references and responses</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute reciprocal data of functions with only one coordinate&#39;</span><span class="p">)</span>
        <span class="c1"># Get all of the degrees of freedom that are both in references and</span>
        <span class="c1"># responses</span>
        <span class="n">references</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">))</span>
        <span class="c1"># Get common references and responses</span>
        <span class="n">common_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">references</span><span class="p">,</span><span class="n">responses</span><span class="p">)</span>
        <span class="c1"># Get pairs of those degrees of freedom</span>
        <span class="n">dof_combos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">combo</span> <span class="k">for</span> <span class="n">combo</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">combinations</span><span class="p">(</span><span class="n">common_dofs</span><span class="p">,</span><span class="mi">2</span><span class="p">)])</span>
        <span class="c1"># Now we need to select the reciprocal degrees of freedom</span>
        <span class="n">reciprocal_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">dof_combos</span><span class="p">,</span><span class="n">dof_combos</span><span class="p">[</span><span class="o">...</span><span class="p">,::</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CoordinateArray</span><span class="p">)</span>
        <span class="n">reciprocal_slice</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">([</span><span class="bp">Ellipsis</span><span class="p">]</span><span class="o">+</span><span class="bp">self</span><span class="o">.</span><span class="n">ndim</span><span class="o">*</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">+</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)])</span>
        <span class="n">equal_logical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span> <span class="o">==</span> <span class="n">reciprocal_dofs</span><span class="p">[</span><span class="n">reciprocal_slice</span><span class="p">],</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">equal_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">equal_logical</span><span class="p">)</span>
        <span class="n">equal_indices</span> <span class="o">=</span>  <span class="nb">tuple</span><span class="p">([</span><span class="n">inds</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">inds</span> <span class="ow">in</span> <span class="n">equal_indices</span><span class="p">[</span><span class="mi">2</span><span class="p">:]])</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">equal_indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">equal_indices</span><span class="p">]</span></div>
        
<div class="viewcode-block" id="NDDataArray.get_drive_points"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.get_drive_points">[docs]</a>    <span class="k">def</span> <span class="nf">get_drive_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">return_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns data arrays where the reference is equal to the response</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        return_indices : bool, optional</span>
<span class="sd">            If True, it will return a set of indices into the original array</span>
<span class="sd">            that extract the drive point functions. If False, then the</span>
<span class="sd">            drive point functions are returned directly.  The default is False.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the data does not have reference and response coordinates, the</span>
<span class="sd">            method will raise a ValueError.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray or NDDataArray subclass</span>
<span class="sd">            If return_indices is True, this will return the indices into the</span>
<span class="sd">            original array that extract the drive point data.  If return_indices</span>
<span class="sd">            is False, this will return the drive point NDDataArrays directly.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check if there are references and responses</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="p">(</span><span class="mi">2</span><span class="p">,):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot compute drive point data of functions with only one coordinate&#39;</span><span class="p">)</span>
        <span class="n">equal_logical</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">)</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_indices</span><span class="p">:</span>
            <span class="n">equal_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">equal_logical</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">equal_indices</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">equal_logical</span><span class="p">]</span></div></div>

<div class="viewcode-block" id="TimeHistoryArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray">[docs]</a><span class="k">class</span> <span class="nc">TimeHistoryArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store time history data&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span>

<div class="viewcode-block" id="TimeHistoryArray.from_exodus"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.from_exodus">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">from_exodus</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">exo</span><span class="p">,</span> <span class="n">x_disp</span><span class="o">=</span><span class="s1">&#39;DispX&#39;</span><span class="p">,</span> <span class="n">y_disp</span><span class="o">=</span><span class="s1">&#39;DispY&#39;</span><span class="p">,</span> <span class="n">z_disp</span><span class="o">=</span><span class="s1">&#39;DispZ&#39;</span><span class="p">,</span> <span class="n">x_rot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y_rot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">z_rot</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">timesteps</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads time data from displacements in an Exodus file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        exo : Exodus or ExodusInMemory</span>
<span class="sd">            The exodus data from which geometry will be created.</span>
<span class="sd">        x_disp : str, optional</span>
<span class="sd">            String denoting the nodal variable in the exodus file from which</span>
<span class="sd">            the X-direction displacement should be read. The default is &#39;DispX&#39;.</span>
<span class="sd">        y_disp : str, optional</span>
<span class="sd">            String denoting the nodal variable in the exodus file from which</span>
<span class="sd">            the Y-direction displacement should be read. The default is &#39;DispY&#39;.</span>
<span class="sd">        z_disp : str, optional</span>
<span class="sd">            String denoting the nodal variable in the exodus file from which</span>
<span class="sd">            the Z-direction displacement should be read. The default is &#39;DispZ&#39;.</span>
<span class="sd">        timesteps : iterable, optional</span>
<span class="sd">            A list of timesteps from which data should be read. The default is</span>
<span class="sd">            None, which reads all timesteps.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TYPE</span>
<span class="sd">            DESCRIPTION.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">exo</span><span class="p">,</span> <span class="n">Exodus</span><span class="p">):</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="n">exo</span><span class="o">.</span><span class="n">get_node_num_map</span><span class="p">()</span>
            <span class="n">variables</span> <span class="o">=</span> <span class="p">[(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([</span><span class="n">x_disp</span><span class="p">,</span> <span class="n">y_disp</span><span class="p">,</span>
                                                           <span class="n">z_disp</span><span class="p">,</span> <span class="n">x_rot</span><span class="p">,</span> <span class="n">y_rot</span><span class="p">,</span> <span class="n">z_rot</span><span class="p">])</span> <span class="k">if</span> <span class="n">v</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">abscissa</span> <span class="o">=</span> <span class="n">exo</span><span class="o">.</span><span class="n">get_times</span><span class="p">()</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">[</span><span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span>
                               <span class="n">exo</span><span class="o">.</span><span class="n">get_node_variable_values</span><span class="p">(</span><span class="n">variable</span><span class="p">,</span> <span class="n">timesteps</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                               <span class="n">coordinate_array</span><span class="p">(</span><span class="n">node_ids</span><span class="p">,</span> <span class="n">index</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">variable</span> <span class="ow">in</span> <span class="n">variables</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO need to add in rotations</span>
            <span class="n">node_ids</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span>
                <span class="n">exo</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">exo</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">node_num_map</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">exo</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">node_num_map</span>
            <span class="n">x_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">exo</span><span class="o">.</span><span class="n">nodal_vars</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">x_disp</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span>
            <span class="p">)][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">timesteps</span><span class="p">)</span> <span class="k">if</span> <span class="n">timesteps</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">timesteps</span><span class="p">]</span>
            <span class="n">y_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">exo</span><span class="o">.</span><span class="n">nodal_vars</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">y_disp</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span>
            <span class="p">)][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">timesteps</span><span class="p">)</span> <span class="k">if</span> <span class="n">timesteps</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">timesteps</span><span class="p">]</span>
            <span class="n">z_var</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">exo</span><span class="o">.</span><span class="n">nodal_vars</span> <span class="k">if</span> <span class="n">var</span><span class="o">.</span><span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">z_disp</span><span class="o">.</span><span class="n">lower</span><span class="p">(</span>
            <span class="p">)][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">timesteps</span><span class="p">)</span> <span class="k">if</span> <span class="n">timesteps</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">timesteps</span><span class="p">]</span>
            <span class="n">abscissa</span> <span class="o">=</span> <span class="n">exo</span><span class="o">.</span><span class="n">time</span><span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="n">timesteps</span><span class="p">)</span> <span class="k">if</span> <span class="n">timesteps</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">timesteps</span><span class="p">]</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">x_var</span><span class="p">,</span> <span class="n">y_var</span><span class="p">,</span> <span class="n">z_var</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span>
                <span class="n">node_ids</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">))[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeHistoryArray.fft"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.fft">[docs]</a>    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;backward&quot;</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span>
            <span class="o">**</span><span class="n">scipy_rfft_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the frequency spectra of the time signal</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples_per_frame : int, optional</span>
<span class="sd">            Number of samples per measurement frame.  If this is specified, then</span>
<span class="sd">            the signal will be split up into frames and averaged together.  Be</span>
<span class="sd">            aware that if the time signal is not periodic, averaging it may have</span>
<span class="sd">            the effect of zeroing out the spectrum (because the average time</span>
<span class="sd">            signal is zero). The default is no averaging, the frame size is the</span>
<span class="sd">            length of the signal.</span>
<span class="sd">        norm : str, optional</span>
<span class="sd">            The type of normalization applied to the fft computation.</span>
<span class="sd">            The default is &quot;backward&quot;.</span>
<span class="sd">        rtol : float, optional</span>
<span class="sd">            Relative tolerance used in the abcsissa spacing check.</span>
<span class="sd">            The default is 1e-5.</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            Relative tolerance used in the abscissa spacing check.</span>
<span class="sd">            The default is 1e-8.</span>
<span class="sd">        scipy_rfft_kwargs :</span>
<span class="sd">            Additional keywords that will be passed to SciPy&#39;s rfft function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if the time signal passed to this function does not have</span>
<span class="sd">            equally spaced abscissa.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpectrumArray</span>
<span class="sd">            The frequency spectra of the TimeHistoryArray.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa must have identical spacing to perform the FFT&#39;</span><span class="p">)</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="n">samples_per_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frame_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ordinate</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span>
                                                                     <span class="n">samples_per_frame</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">samples_per_frame</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame_indices</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diffs</span><span class="p">)</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># frequencies = np.fft.rfftfreq(n, dt)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
        <span class="c1"># ordinate = np.fft.rfft(ordinate, axis=-1)</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span>
                                 <span class="o">**</span><span class="n">scipy_rfft_kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">samples_per_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">)</span>
        <span class="c1"># Create the output signal</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SPECTRUM</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeHistoryArray.cpsd"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.cpsd">[docs]</a>    <span class="k">def</span> <span class="nf">cpsd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">window</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
             <span class="n">averages_to_keep</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
             <span class="n">only_asds</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a CPSD matrix from the time histories</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples_per_frame : int</span>
<span class="sd">            Number of samples per frame</span>
<span class="sd">        overlap : float</span>
<span class="sd">            Overlap fraction (not percent, e.g. 0.5 not 50)</span>
<span class="sd">        window : str</span>
<span class="sd">            Name of a window function in scipy.signal.windows</span>
<span class="sd">        averages_to_keep : int, optional</span>
<span class="sd">            Optional number of averages to use, otherwise as many as possible</span>
<span class="sd">            will be used.</span>
<span class="sd">        only_asds : bool, optional</span>
<span class="sd">            If True, only compute autospectral densities (diagonal of the</span>
<span class="sd">            CPSD matrix)</span>
<span class="sd">        rtol : float, optional</span>
<span class="sd">            Tolerance used to check abscissa spacing. The default is 1.</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            Tolerance used to check abscissa spacing. The default is 1e-8.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If time history abscissa are not equally spaced.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        cpsd_array : PowerSpectralDensityArray</span>
<span class="sd">            Cross Power Spectral Density Array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa must have identical spacing to perform the cpsd&#39;</span><span class="p">)</span>
        <span class="n">flat_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">flat_self</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">diffs</span><span class="p">),</span> <span class="n">samples_per_frame</span><span class="p">,</span>
                                  <span class="n">overlap</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">averages_to_keep</span><span class="p">,</span> <span class="n">only_asds</span><span class="p">)</span>
        <span class="c1">#  Construct the spectrum array</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cpsd_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">*</span> <span class="n">df</span>
        <span class="n">cpsd_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">cpsd_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span> <span class="k">if</span> <span class="n">only_asds</span>
                                <span class="k">else</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">coords</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">cpsd_array</span></div>

<div class="viewcode-block" id="TimeHistoryArray.srs"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.srs">[docs]</a>    <span class="k">def</span> <span class="nf">srs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">damping</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">num_points</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">points_per_octave</span><span class="o">=</span><span class="mi">12</span><span class="p">,</span>
            <span class="n">srs_type</span><span class="o">=</span><span class="s1">&#39;MMAA&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a shock response spectrum (SRS) from the time history</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Minimum frequency to compute the SRS. Either `frequencies` or</span>
<span class="sd">            `min_frequency` and `max_frequency` must be specified.</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency to compute the SRS. Either `frequencies` or</span>
<span class="sd">            `min_frequency` and `max_frequency` must be specified.</span>
<span class="sd">        frequencies : np.ndarray, optional</span>
<span class="sd">            Frequency lines at which to compute the SRS. Either `frequencies` or</span>
<span class="sd">            `min_frequency` and `max_frequency` must be specified.</span>
<span class="sd">        damping : float, optional</span>
<span class="sd">            Fraction of critical damping to use in the SRS calculation (e.g. you</span>
<span class="sd">            should specify 0.03 to represent 3%, not 3). The default is 0.03.</span>
<span class="sd">        num_points : int, optional</span>
<span class="sd">            Number of frequency lines to compute from `min_frequency` to</span>
<span class="sd">            `max_frequency`, log spaced between these two values.  If</span>
<span class="sd">            `min_frequency` and `max_frequency` are specified, then either</span>
<span class="sd">            `num_points` or `points_per_octave` must be specified.  If</span>
<span class="sd">            `frequencies` is specified, this argument is ignored.</span>
<span class="sd">        points_per_octave : float, optional</span>
<span class="sd">            Number of frequency lines per octave to compute from `min_frequency`</span>
<span class="sd">            to `max_frequency`.  If `min_frequency` and `max_frequency` are</span>
<span class="sd">            specified, then either `num_points` or `points_per_octave` must be</span>
<span class="sd">            specified.  If `frequencies` is specified, this argument is ignored.</span>
<span class="sd">            The default is 12.</span>
<span class="sd">        srs_type : str, optional</span>
<span class="sd">            A string encoding for the type of SRS to be computed.  See notes for</span>
<span class="sd">            more information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ShockResponseSpectrumArray</span>
<span class="sd">            SRSs representing the current time histories.  If `srs_type` is</span>
<span class="sd">            `&#39;all&#39;`, then an extra dimension of 9 will be added to the front of</span>
<span class="sd">            the array, and the indices in that dimension will be different SRS</span>
<span class="sd">            types.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The `srs_type` argument takes a 4 character string that specifies how</span>
<span class="sd">        the SRS is computed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute default parameters</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">srs_type_val</span> <span class="o">=</span> <span class="n">ShockResponseSpectrumArray</span><span class="o">.</span><span class="n">_srs_type_map</span><span class="p">[</span><span class="n">srs_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid `srs_type` specified, should be one of </span><span class="si">{:}</span><span class="s1"> (case insensitive)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ShockResponseSpectrumArray</span><span class="o">.</span><span class="n">_srs_type_map</span><span class="p">]))</span>

        <span class="k">if</span> <span class="n">frequencies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`min_frequency` and `max_frequency` must be provided if `frequencies` is not&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">frequencies</span> <span class="o">=</span> <span class="n">octspace</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">,</span> <span class="n">points_per_octave</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logspace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">max_frequency</span><span class="p">),</span> <span class="n">num_points</span><span class="p">)</span>

        <span class="n">srss</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">sp_srs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">damping</span><span class="p">,</span> <span class="n">srs_type_val</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">srs_type_val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">srss</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Now construct the output object</span>
        <span class="n">srs</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SHOCK_RESPONSE_SPECTRUM</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                         <span class="n">srss</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">srs</span></div>

<div class="viewcode-block" id="TimeHistoryArray.split_into_frames"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.split_into_frames">[docs]</a>    <span class="k">def</span> <span class="nf">split_into_frames</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">check_cola</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_fractional_frames</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Splits a time history into measurement frames with a given overlap and</span>
<span class="sd">        window function applied.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples_per_frame : int, optional</span>
<span class="sd">            Number of samples in each measurement frame. Either this argument</span>
<span class="sd">            or `frame_length` must be specified.  If both or neither are</span>
<span class="sd">            specified, a `ValueError` is raised.</span>
<span class="sd">        frame_length : float, optional</span>
<span class="sd">            Length of each measurement frame in the same units as the `abscissa`</span>
<span class="sd">            field (`samples_per_frame` = `frame_length`/`self.abscissa_spacing`).</span>
<span class="sd">            Either this argument or `samples_per_frame` must be specified.  If</span>
<span class="sd">            both or neither are specified, a `ValueError` is raised.</span>
<span class="sd">        overlap : float, optional</span>
<span class="sd">            Fraction of the measurement frame to overlap (i.e. 0.25 not 25 to</span>
<span class="sd">            overlap a quarter of the frame). Either this argument or</span>
<span class="sd">            `overlap_samples` must be specified.  If both are</span>
<span class="sd">            specified, a `ValueError` is raised.  If neither are specified, no</span>
<span class="sd">            overlap is used.</span>
<span class="sd">        overlap_samples : int, optional</span>
<span class="sd">            Number of samples in the measurement frame to overlap. Either this</span>
<span class="sd">            argument or `overlap_samples` must be specified.  If both</span>
<span class="sd">            are specified, a `ValueError` is raised.  If neither are specified,</span>
<span class="sd">            no overlap is used.</span>
<span class="sd">        window : str or tuple or array_like, optional</span>
<span class="sd">            Desired window to use. If window is a string or tuple, it is passed</span>
<span class="sd">            to `scipy.signal.get_window` to generate the window values, which</span>
<span class="sd">            are DFT-even by default. See `get_window` for a list of windows and</span>
<span class="sd">            required parameters. If window is array_like it will be used</span>
<span class="sd">            directly as the window and its length must be `samples_per_frame`.</span>
<span class="sd">            If not specified, no window will be applied.</span>
<span class="sd">        check_cola : bool, optional</span>
<span class="sd">            If `True`, raise a `ValueError` if the specified overlap and window</span>
<span class="sd">            function are not compatible with COLA. The default is False.</span>
<span class="sd">        allow_fractional_frames : bool, optional</span>
<span class="sd">            If `False` (default), the signal will be split into a number of</span>
<span class="sd">            full frames, and any remaining fractional frame will be discarded.</span>
<span class="sd">            This will not allow COLA to be satisfied.</span>
<span class="sd">            If `True`, fractional frames will be retained and zero padded to</span>
<span class="sd">            create a full frames.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray</span>
<span class="sd">            Returns a new TimeHistoryArray with shape [num_frames,...] where</span>
<span class="sd">            ... is the shape of the original array.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check to see that the arguments were specified correctly</span>
        <span class="k">if</span> <span class="n">samples_per_frame</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frame_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;One of `samples_per_frame` or `frame_length` must be specified&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">samples_per_frame</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frame_length</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`samples_per_frame` can not be specified along with `frame_length`&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">overlap_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overlap_samples</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">overlap</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">overlap_samples</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`overlap` can not be specified along with `overlap_samples`&#39;</span><span class="p">)</span>
        <span class="c1"># Compute samples_per_frame and overlap_samples</span>
        <span class="k">if</span> <span class="n">samples_per_frame</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">samples_per_frame</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">frame_length</span><span class="o">/</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">))</span>
        <span class="c1"># Make sure that we have an even number of samples per frame.</span>
        <span class="k">if</span> <span class="n">samples_per_frame</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`samples_per_frame` must be an even number&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">overlap_samples</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">overlap_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="o">*</span><span class="n">overlap</span><span class="p">))</span>

        <span class="c1"># If partial frames, then we will zero pad to make it the right length</span>
        <span class="k">if</span> <span class="n">allow_fractional_frames</span><span class="p">:</span>
            <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">num_frames</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="o">-</span><span class="n">overlap_samples</span><span class="p">)</span><span class="o">/</span><span class="p">(</span><span class="n">samples_per_frame</span> <span class="o">-</span> <span class="n">overlap_samples</span><span class="p">)))</span>
        <span class="n">frame_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_frames</span><span class="p">)[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="o">-</span><span class="n">overlap_samples</span><span class="p">)</span>
        <span class="c1"># See if we need to truncate empty frames</span>
        <span class="k">if</span> <span class="n">allow_fractional_frames</span><span class="p">:</span>
            <span class="c1"># Get rid of the first frame which is all zeros</span>
            <span class="n">frame_indices</span> <span class="o">=</span> <span class="n">frame_indices</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="c1"># See if we need to get rid of the last frame, which could be all</span>
            <span class="c1"># zeros</span>
            <span class="k">if</span> <span class="n">frame_indices</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="p">:</span>
                <span class="n">frame_indices</span> <span class="o">=</span> <span class="n">frame_indices</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Put the &quot;frame&quot; axis at the front of the new array so all other parameters</span>
        <span class="c1"># can broadcast out across measurement frames</span>
        <span class="n">new_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame_indices</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">new_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">frame_indices</span><span class="p">],</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Now apply the window</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="s1">&#39;boxcar&#39;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">new_ordinate</span> <span class="o">*=</span> <span class="n">window</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Could Not Multiply Window Function (shape </span><span class="si">{:}</span><span class="s1">) by Ordinate (shape </span><span class="si">{:}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">window</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">new_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">check_cola</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">sig</span><span class="o">.</span><span class="n">check_COLA</span><span class="p">(</span><span class="n">window</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="p">,</span> <span class="n">overlap_samples</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;COLA Check Failed: specified window and overlap do not result in a constant overlap-add condition, see scipy.check_COLA for more information&#39;</span><span class="p">)</span>
                
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">new_abscissa</span><span class="p">,</span> <span class="n">new_ordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>
    

<div class="viewcode-block" id="TimeHistoryArray.mimo_forward"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.mimo_forward">[docs]</a>    <span class="k">def</span> <span class="nf">mimo_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transfer_function</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the forward mimo calculation via convolution.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transfer_function : TransferFunctionArray or ImpulseResponseFunctionArray</span>
<span class="sd">            This is the FRFs that will be used in the forward problem. A matrix of IRFs</span>
<span class="sd">            is prefered, but FRFs can also be used, although the FRFs will be immediately</span>
<span class="sd">            converted to IRFs.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the sampling rates for the data and IRFs/FRFs don&#39;t match.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the references in the IRFs/FRFs don&#39;t match the supplied input</span>
<span class="sd">            data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray</span>
<span class="sd">            Response time histories</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Converting FRFs to IRFs, if required</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transfer_function</span><span class="p">,</span> <span class="n">TransferFunctionArray</span><span class="p">):</span>
            <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>

        <span class="c1"># Some initial organization</span>
        <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">reference_dofs</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">response_dofs</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">reference_dofs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">transfer_function</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">num_references</span><span class="p">,</span> <span class="n">number_responses</span><span class="p">,</span> <span class="n">model_order</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">signal_length</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span>

        <span class="c1"># Checking to see if the sampling rates are the same for both data sets</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The transfer function sampling rate does not match the time data.&#39;</span><span class="p">)</span>

        <span class="c1"># Setting up and doing the convolution</span>
        <span class="n">convolved_response</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_responses</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">reference_irfs</span><span class="p">,</span> <span class="n">inputs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">irfs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">):</span>
            <span class="n">convolved_response</span> <span class="o">+=</span> <span class="n">oaconvolve</span><span class="p">(</span><span class="n">reference_irfs</span><span class="p">,</span> <span class="n">inputs</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:])[:,</span> <span class="p">:</span><span class="n">signal_length</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">convolved_response</span><span class="p">,</span> <span class="n">response_dofs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span></div>

<div class="viewcode-block" id="TimeHistoryArray.mimo_inverse"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.mimo_inverse">[docs]</a>    <span class="k">def</span> <span class="nf">mimo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transfer_function</span><span class="p">,</span>
                     <span class="n">time_method</span><span class="o">=</span><span class="s1">&#39;single_frame&#39;</span><span class="p">,</span>
                     <span class="n">cola_frame_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">cola_window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
                     <span class="n">cola_overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">zero_pad_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">inverse_method</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                     <span class="n">response_weighting_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">reference_weighting_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">regularization_weighting_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">regularization_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">cond_num_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">num_retained_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs the inverse source estimation for time domain (transient) problems</span>
<span class="sd">        using Fourier deconvolution. The response nodes used in the inverse source</span>
<span class="sd">        estimation are the ones contained in the supplied FRF matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transer_function : TransferFunctionArray or ImpulseResponseFunctionArray</span>
<span class="sd">            This is the FRFs that will be used in the inverse source estimation</span>
<span class="sd">        time_method : str, optional</span>
<span class="sd">            The method to used to handle the time data for the inverse source</span>
<span class="sd">            estimation. The available options are:</span>
<span class="sd">                - single_frame - this method performs the Fourier deconvolution</span>
<span class="sd">                  via an FFT on a single frame that encompases the entire time</span>
<span class="sd">                  signal.</span>
<span class="sd">                - COLA - this method performs the Fourier deconvolution via a</span>
<span class="sd">                  series of FFTs on relatively small frames of the time signal</span>
<span class="sd">                  using a &quot;constant overlap and add&quot; method. This method may be</span>
<span class="sd">                  faster than the single_frame method.</span>
<span class="sd">        cola_frame_length : float, optional</span>
<span class="sd">            The frame length (in samples) if the COLA method is being used. The</span>
<span class="sd">            default frame length is Fs/df from the transfer function.</span>
<span class="sd">        cola_window : str, optional</span>
<span class="sd">            The desired window for the COLA procedure, must exist in the scipy</span>
<span class="sd">            window library. The default is a hann window.</span>
<span class="sd">        cola_overlap : int, optional</span>
<span class="sd">            The number of overlapping samples between measurement frames in the</span>
<span class="sd">            COLA procedure.  If not specified, a default value of half the</span>
<span class="sd">            cola_frame_length is used.</span>
<span class="sd">        zero_pad_length : int, optional</span>
<span class="sd">            The number of zeros used to pre and post pad the response data, to</span>
<span class="sd">            avoid convolution wrap-around error. The default is to use the</span>
<span class="sd">            &quot;determine_zero_pad_length&quot; function to determine the zero_pad_length.</span>
<span class="sd">        inverse_method : str, optional</span>
<span class="sd">            The method to be used for the FRF matrix inversions. The available</span>
<span class="sd">            methods are:</span>
<span class="sd">                - standard - basic pseudo-inverse via numpy.linalg.pinv with the</span>
<span class="sd">                  default rcond parameter, this is the default method</span>
<span class="sd">                - threshold - pseudo-inverse via numpy.linalg.pinv with a specified</span>
<span class="sd">                  condition number threshold</span>
<span class="sd">                - tikhonov - pseudo-inverse using the Tikhonov regularization method</span>
<span class="sd">                - truncation - pseudo-inverse where a fixed number of singular values</span>
<span class="sd">                  are retained for the inverse</span>
<span class="sd">        response_weighting_matrix : sdpy.Matrix or np.ndarray, optional</span>
<span class="sd">            Not currently implemented</span>
<span class="sd">        reference_weighting_matrix : sdpy.Matrix or np.ndarray, optional</span>
<span class="sd">            Not currently implemented</span>
<span class="sd">        regularization_weighting_matrix : sdpy.Matrix, optional</span>
<span class="sd">            Matrix used to weight input degrees of freedom via Tikhonov regularization.</span>
<span class="sd">        regularization_parameter : float or np.ndarray, optional</span>
<span class="sd">            Scaling parameter used on the regularization weighting matrix when the tikhonov</span>
<span class="sd">            method is chosen. A vector of regularization parameters can be provided so the</span>
<span class="sd">            regularization is different at each frequency line. The vector must match the</span>
<span class="sd">            length of the FRF abscissa in this case (either be size [num_lines,] or [num_lines, 1]).</span>
<span class="sd">        cond_num_threshold : float or np.ndarray, optional</span>
<span class="sd">            Condition number used for SVD truncation when the threshold method is chosen.</span>
<span class="sd">            A vector of condition numbers can be provided so it varies as a function of</span>
<span class="sd">            frequency. The vector must match the length of the FRF abscissa in this case</span>
<span class="sd">            (either be size [num_lines,] or [num_lines, 1]).</span>
<span class="sd">        num_retained_values : float or np.ndarray, optional</span>
<span class="sd">            Number of singular values to retain in the pseudo-inverse when the truncation</span>
<span class="sd">            method is chosen. A vector of can be provided so the number of retained values</span>
<span class="sd">            can change as a function of frequency. The vector must match the length of the</span>
<span class="sd">            FRF abscissa in this case (either be size [num_lines,] or [num_lines, 1]).</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If a response weighting matrix is supplied</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            If a reference weighting matrix is supplied</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the sampling rates for the data and FRFs don&#39;t match.</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the number of responses in the FRFs don&#39;t match the supplied response</span>
<span class="sd">            data.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray</span>
<span class="sd">            Time history array of the estimated sources</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function computes the time domain inputs required to match the target time traces</span>
<span class="sd">        using Fourier deconvolution, which is essentially a frequency domain problem. The general</span>
<span class="sd">        method is to compute the frequency spectrum of the target time traces, then solve the</span>
<span class="sd">        inverse problem in the time domain using the supplied FRFs (H^+ * X). The inverse of the</span>
<span class="sd">        FRF matrix is found using the same methods as the mimo_inverse function for the</span>
<span class="sd">        PowerSpectralDensityArray class. The input spectrum is then converted back to the time</span>
<span class="sd">        domain via a inverse fourier transform.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Wikipedia, &quot;Moore-Penrose inverse&quot;.</span>
<span class="sd">               https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse</span>
<span class="sd">        .. [2] A.N. Tithe, D.J. Thompson, The quantification of structure-borne transmission pathsby inverse methods. Part 2: Use of regularization techniques,</span>
<span class="sd">               Journal of Sound and Vibration, Volume 264, Issue 2, 2003, Pages 433-451, ISSN 0022-460X,</span>
<span class="sd">               https://doi.org/10.1016/S0022-460X(02)01203-8.</span>
<span class="sd">        .. [3] Wikipedia, &quot;Ridge regression&quot;.</span>
<span class="sd">               https://en.wikipedia.org/wiki/Ridge_regression</span>
<span class="sd">        .. [4] Wikipedia, &quot;Overlap-add Method&quot;.</span>
<span class="sd">               https://en.wikipedia.org/wiki/Overlap-add_method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Converting IRFs to FRFs, if required</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">transfer_function</span><span class="p">,</span> <span class="n">ImpulseResponseFunctionArray</span><span class="p">):</span>
            <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>

        <span class="c1"># Initial orginization of the data</span>
        <span class="n">indexed_transfer_function</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">irf</span> <span class="o">=</span> <span class="n">indexed_transfer_function</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
        <span class="n">response_dofs</span> <span class="o">=</span> <span class="n">indexed_transfer_function</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="n">reference_dofs</span> <span class="o">=</span> <span class="n">indexed_transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reference_coordinate</span>

        <span class="n">indexed_response_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">response_dofs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span>

        <span class="n">number_responses</span><span class="p">,</span> <span class="n">number_references</span> <span class="o">=</span> <span class="n">indexed_transfer_function</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">model_order</span> <span class="o">=</span> <span class="n">irf</span><span class="o">.</span><span class="n">num_elements</span>

        <span class="c1"># Checking to see if the sampling rates are the same for both data sets</span>
        <span class="n">fs_inputs</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">indexed_response_data</span><span class="o">.</span><span class="n">abscissa_spacing</span>
        <span class="n">fs_frf</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">irf</span><span class="o">.</span><span class="n">abscissa_spacing</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">fs_frf</span><span class="p">,</span> <span class="n">fs_inputs</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;The transfer function sampling rate does not match the time data.&#39;</span><span class="p">)</span>

        <span class="c1"># Preparing the response data and FRFs for the source estimation</span>
        <span class="k">if</span> <span class="n">time_method</span> <span class="o">==</span> <span class="s1">&#39;single_frame&#39;</span><span class="p">:</span>
            <span class="c1"># Zero pad for convolution wrap-around</span>
            <span class="k">if</span> <span class="n">zero_pad_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">padded_response</span> <span class="o">=</span> <span class="n">indexed_response_data</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">model_order</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                                                 <span class="n">use_next_fast_len</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">padded_response</span> <span class="o">=</span> <span class="n">indexed_response_data</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span><span class="n">zero_pad_length</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">actual_zero_pad</span> <span class="o">=</span> <span class="n">padded_response</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="n">indexed_response_data</span><span class="o">.</span><span class="n">num_elements</span>
            <span class="c1"># Now make the FRFs the same size</span>
            <span class="n">modified_frfs</span> <span class="o">=</span> <span class="n">indexed_transfer_function</span><span class="o">.</span><span class="n">interpolate_by_zero_pad</span><span class="p">(</span><span class="n">padded_response</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)</span>
            <span class="n">padded_frequency_domain_data</span> <span class="o">=</span> <span class="n">padded_response</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">time_method</span> <span class="o">==</span> <span class="s1">&#39;cola&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cola_frame_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cola_frame_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">fs_frf</span><span class="o">/</span><span class="n">indexed_transfer_function</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cola_overlap</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cola_overlap</span> <span class="o">=</span> <span class="n">cola_frame_length</span><span class="o">//</span><span class="mi">2</span>
            <span class="c1"># Split into measurement frames</span>
            <span class="n">segmented_data</span> <span class="o">=</span> <span class="n">indexed_response_data</span><span class="o">.</span><span class="n">split_into_frames</span><span class="p">(</span>
                <span class="n">samples_per_frame</span><span class="o">=</span><span class="n">cola_frame_length</span><span class="p">,</span>
                <span class="n">overlap_samples</span><span class="o">=</span><span class="n">cola_overlap</span><span class="p">,</span>
                <span class="n">window</span><span class="o">=</span><span class="n">cola_window</span><span class="p">,</span>
                <span class="n">check_cola</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                <span class="n">allow_fractional_frames</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Zero pad</span>
            <span class="k">if</span> <span class="n">zero_pad_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">zero_padded_data</span> <span class="o">=</span> <span class="n">segmented_data</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span>
                    <span class="mi">2</span><span class="o">*</span><span class="n">model_order</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">use_next_fast_len</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">zero_padded_data</span> <span class="o">=</span> <span class="n">segmented_data</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span>
                    <span class="n">zero_pad_length</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">actual_zero_pad</span> <span class="o">=</span> <span class="n">zero_padded_data</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="n">segmented_data</span><span class="o">.</span><span class="n">num_elements</span>
            <span class="n">modified_frfs</span> <span class="o">=</span> <span class="n">indexed_transfer_function</span><span class="o">.</span><span class="n">interpolate_by_zero_pad</span><span class="p">(</span><span class="n">zero_padded_data</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)</span>
            <span class="n">padded_frequency_domain_data</span> <span class="o">=</span> <span class="n">zero_padded_data</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NameError</span><span class="p">(</span><span class="s1">&#39;The selected time method is not available&#39;</span><span class="p">)</span>

        <span class="c1"># Need to interpolate the conditioning parameters to match the length of the padded</span>
        <span class="c1"># FRFs</span>
        <span class="k">if</span> <span class="n">cond_num_threshold</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cond_num_threshold</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">cond_num_threshold</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">cond_num_threshold</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cond_num_threshold</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">indexed_transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                    <span class="n">cond_num_threshold</span><span class="p">,</span>
                    <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">cond_num_threshold</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cond_num_threshold</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">modified_frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">num_retained_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">num_retained_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">num_retained_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">num_retained_values</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">num_retained_values</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">indexed_transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                    <span class="n">num_retained_values</span><span class="p">,</span>
                    <span class="s1">&#39;previous&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">num_retained_values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">num_retained_values</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">modified_frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regularization_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regularization_parameter</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">regularization_parameter</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">regularization_parameter</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">regularization_parameter</span> <span class="o">=</span> <span class="n">interp1d</span><span class="p">(</span>
                    <span class="n">indexed_transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                    <span class="n">regularization_parameter</span><span class="p">,</span>
                    <span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                    <span class="n">fill_value</span><span class="o">=</span><span class="p">(</span><span class="n">regularization_parameter</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">regularization_parameter</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span>
                    <span class="n">assume_sorted</span><span class="o">=</span><span class="kc">True</span><span class="p">)(</span><span class="n">modified_frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span>

        <span class="c1"># Set up weighting matrices</span>
        <span class="k">if</span> <span class="n">response_weighting_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Response weighting has not been implemented yet&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reference_weighting_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Reference weighting has not been implemented yet&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regularization_weighting_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">regularization_weighting_matrix</span> <span class="o">=</span> <span class="n">regularization_weighting_matrix</span><span class="p">[</span><span class="n">reference_dofs</span><span class="p">,</span> <span class="n">reference_dofs</span><span class="p">]</span><span class="o">.</span><span class="n">matrix</span>

        <span class="c1"># Now solve the inverse problem</span>
        <span class="n">frf_pinv</span> <span class="o">=</span> <span class="n">frf_inverse</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">modified_frfs</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                               <span class="n">method</span><span class="o">=</span><span class="n">inverse_method</span><span class="p">,</span>
                               <span class="n">response_weighting_matrix</span><span class="o">=</span><span class="n">response_weighting_matrix</span><span class="p">,</span>
                               <span class="n">reference_weighting_matrix</span><span class="o">=</span><span class="n">reference_weighting_matrix</span><span class="p">,</span>
                               <span class="n">regularization_weighting_matrix</span><span class="o">=</span><span class="n">regularization_weighting_matrix</span><span class="p">,</span>
                               <span class="n">regularization_parameter</span><span class="o">=</span><span class="n">regularization_parameter</span><span class="p">,</span>
                               <span class="n">cond_num_threshold</span><span class="o">=</span><span class="n">cond_num_threshold</span><span class="p">,</span>
                               <span class="n">num_retained_values</span><span class="o">=</span><span class="n">num_retained_values</span><span class="p">)</span>
        <span class="n">method_statement_start</span> <span class="o">=</span> <span class="s1">&#39;The FRFs are being inverted using the &#39;</span>
        <span class="n">method_statement_end</span> <span class="o">=</span> <span class="s1">&#39; method&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">method_statement_start</span><span class="o">+</span><span class="n">inverse_method</span><span class="o">+</span><span class="n">method_statement_end</span><span class="p">)</span>

        <span class="c1"># Get the first modified frequency line above the original starting point of the FRF</span>
        <span class="n">inverse_start_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">modified_frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">&gt;=</span> <span class="n">indexed_transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># Doing the source estimation</span>
        <span class="n">padded_frequency_domain_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">padded_frequency_domain_data</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">forces_frequency_domain</span> <span class="o">=</span> <span class="n">frf_pinv</span><span class="nd">@padded_frequency_domain_data</span>
        <span class="n">forces_frequency_domain</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">inverse_start_index</span><span class="p">,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">forces_time_domain_with_padding</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">forces_frequency_domain</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">2</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">)</span>
        <span class="c1"># Compute the zero padding used</span>
        <span class="n">pre_pad_length</span> <span class="o">=</span> <span class="n">actual_zero_pad</span><span class="o">//</span><span class="mi">2</span>
        <span class="n">post_pad_length</span> <span class="o">=</span> <span class="n">actual_zero_pad</span> <span class="o">-</span> <span class="n">pre_pad_length</span>
        <span class="k">if</span> <span class="n">time_method</span> <span class="o">==</span> <span class="s1">&#39;single_frame&#39;</span><span class="p">:</span>
            <span class="n">forces_time_domain</span> <span class="o">=</span> <span class="n">forces_time_domain_with_padding</span><span class="p">[</span><span class="n">pre_pad_length</span><span class="p">:</span><span class="o">-</span><span class="n">post_pad_length</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">return_val</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">indexed_response_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">forces_time_domain</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                                    <span class="n">reference_dofs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">time_method</span> <span class="o">==</span> <span class="s1">&#39;cola&#39;</span><span class="p">:</span>
            <span class="n">forces_time_domain_with_padding</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span>
                <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                <span class="n">zero_padded_data</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="mi">1</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">forces_time_domain_with_padding</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">),</span>
                <span class="n">reference_dofs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>

            <span class="c1"># Assemble the COLA</span>
            <span class="n">forces_time_domain_with_padding</span> <span class="o">=</span> <span class="n">TimeHistoryArray</span><span class="o">.</span><span class="n">overlap_and_add</span><span class="p">(</span>
                <span class="n">forces_time_domain_with_padding</span><span class="p">,</span>
                <span class="n">overlap_samples</span><span class="o">=</span><span class="n">actual_zero_pad</span> <span class="o">+</span> <span class="n">cola_overlap</span><span class="p">)</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="n">cola_frame_length</span> <span class="o">-</span> <span class="n">cola_overlap</span> <span class="o">+</span> <span class="n">pre_pad_length</span>
            <span class="n">end_index</span> <span class="o">=</span> <span class="n">start_index</span> <span class="o">+</span> <span class="n">indexed_response_data</span><span class="o">.</span><span class="n">num_elements</span>
            <span class="n">return_val</span> <span class="o">=</span> <span class="n">forces_time_domain_with_padding</span><span class="o">.</span><span class="n">idx_by_el</span><span class="p">[</span><span class="n">start_index</span><span class="p">:</span><span class="n">end_index</span><span class="p">]</span>

            <span class="c1"># Compute COLA weighting</span>
            <span class="n">window_fn</span> <span class="o">=</span> <span class="n">get_window</span><span class="p">(</span><span class="n">cola_window</span><span class="p">,</span> <span class="n">cola_frame_length</span><span class="p">)</span>
            <span class="n">step</span> <span class="o">=</span> <span class="n">cola_frame_length</span> <span class="o">-</span> <span class="n">cola_overlap</span>
            <span class="n">weighting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">window_fn</span><span class="p">[</span><span class="n">ii</span><span class="o">*</span><span class="n">step</span><span class="p">:(</span><span class="n">ii</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">step</span><span class="p">]</span> <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">cola_frame_length</span><span class="o">//</span><span class="n">step</span><span class="p">)))</span>
            <span class="n">return_val</span> <span class="o">=</span> <span class="n">return_val</span> <span class="o">/</span> <span class="n">weighting</span>

        <span class="k">return</span> <span class="n">return_val</span></div>

<div class="viewcode-block" id="TimeHistoryArray.rms"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.rms">[docs]</a>    <span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span></div>

<div class="viewcode-block" id="TimeHistoryArray.to_rattlesnake_specification"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.to_rattlesnake_specification">[docs]</a>    <span class="k">def</span> <span class="nf">to_rattlesnake_specification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">coordinate_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">min_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">max_time</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">coordinate_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">coordinate_order</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">coordinate_order</span> <span class="o">=</span> <span class="n">coordinate_order</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
            <span class="n">reshaped_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coordinate_order</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">reshaped_data</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="n">min_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_time</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_time</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">max_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">reshaped_data</span> <span class="o">=</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">min_time</span><span class="p">,</span> <span class="n">max_time</span><span class="p">)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span>
                 <span class="n">t</span><span class="o">=</span><span class="n">reshaped_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">-</span> <span class="n">reshaped_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
                 <span class="n">signal</span><span class="o">=</span><span class="n">reshaped_data</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeHistoryArray.find_signal_shift"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.find_signal_shift">[docs]</a>    <span class="k">def</span> <span class="nf">find_signal_shift</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other_signal</span><span class="p">,</span>
                          <span class="n">compute_subsample_shift</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                          <span class="n">good_line_threshold</span><span class="o">=</span><span class="mf">0.01</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the shift between two sets of time signals</span>

<span class="sd">        This is the amount that `other_signal` leads `self`.  If the time shift</span>
<span class="sd">        is positive, it means that features in `other_signal` occur earlier in</span>
<span class="sd">        time compared to `self`.  If the time shift is negative, it means that</span>
<span class="sd">        features in `other_signal` occur later in time compared to `self`.</span>

<span class="sd">        To align two signals, you can take the time shift from this function and</span>
<span class="sd">        pass it into the `shift_signal` method of `other_signal`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other_signal : TimeHistoryArray</span>
<span class="sd">            The signal against which this signal should be compared in time.</span>
<span class="sd">            It should have the same coordinate ordering and the same number of</span>
<span class="sd">            abscissa as this signal.</span>
<span class="sd">        compute_subsample_shift : bool, optional</span>
<span class="sd">            If False, this function will simply align to the nearest sample.</span>
<span class="sd">            If True, this function will attempt to use FFT phases to compute a</span>
<span class="sd">            subsample shift between the signals.  Default is True.</span>
<span class="sd">        good_line_threshold : float, optional</span>
<span class="sd">            Threshold to use to compute &quot;good&quot; frequency lines.  This function</span>
<span class="sd">            uses phase to compute subsample shifts.  If there are frequency</span>
<span class="sd">            lines without content, they should be ignored.  Frequency lines less</span>
<span class="sd">            than `good_line_threshold` times the maximum of the spectra are</span>
<span class="sd">            ignored. The default is 0.01.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        time_shift : float</span>
<span class="sd">            The time difference between the two signals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">this_fft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>

        <span class="n">this_ordinate</span> <span class="o">=</span> <span class="n">this_fft</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">other_ordinate</span> <span class="o">=</span> <span class="n">other_signal</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span>

        <span class="n">correlation</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">this_ordinate</span><span class="o">*</span><span class="n">other_ordinate</span><span class="o">.</span><span class="n">conj</span><span class="p">())</span>
        <span class="n">time_shift_indices</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">correlation</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)))</span>

        <span class="c1"># Roll the arrays to get them to align</span>
        <span class="n">shifted_signal</span> <span class="o">=</span> <span class="n">other_signal</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">shifted_signal</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">other_signal</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">time_shift_indices</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">time_shift</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">time_shift_indices</span>

        <span class="k">if</span> <span class="n">compute_subsample_shift</span><span class="p">:</span>
            <span class="c1"># Now compute the subsample shift</span>
            <span class="n">shifted_ordinate</span> <span class="o">=</span> <span class="n">shifted_signal</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span>

            <span class="c1"># Only compute at frequency lines where there&#39;s signal</span>
            <span class="n">good_lines</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shifted_ordinate</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">shifted_ordinate</span><span class="p">),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">good_line_threshold</span>
            <span class="n">good_lines</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="n">phase_difference</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">this_ordinate</span><span class="o">/</span><span class="n">shifted_ordinate</span><span class="p">)</span>

            <span class="n">phase_slope</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">phase_difference</span><span class="p">[</span><span class="n">good_lines</span><span class="p">]</span><span class="o">/</span><span class="n">this_fft</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="n">good_lines</span><span class="p">])</span>

            <span class="n">time_shift</span> <span class="o">-=</span> <span class="n">phase_slope</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="c1"># Wrap so it&#39;s negative if that&#39;s the smaller distance</span>
        <span class="k">if</span> <span class="n">time_shift</span> <span class="o">&gt;</span> <span class="n">dt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span><span class="o">/</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">time_shift</span> <span class="o">-=</span> <span class="n">dt</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span>

        <span class="k">return</span> <span class="n">time_shift</span></div>

<div class="viewcode-block" id="TimeHistoryArray.shift_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.shift_signal">[docs]</a>    <span class="k">def</span> <span class="nf">shift_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_shift</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Shift a signal in time by a specified amount.</span>

<span class="sd">        Utilizes the FFT shift theorem to move a signal in time.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_shift : float</span>
<span class="sd">            The time shift to apply to the signal.  A negative value will cause</span>
<span class="sd">            features to occur earlier in time.  A positive value will cause</span>
<span class="sd">            features to occur later in time.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted_signal : TimeHistoryArray</span>
<span class="sd">            A shifted version of the original signal.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">phase_shift_slope</span> <span class="o">=</span> <span class="o">-</span><span class="n">time_shift</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">signal_fft</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>

        <span class="n">signal_fft</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="mi">1</span><span class="n">j</span><span class="o">*</span><span class="n">phase_shift_slope</span><span class="o">*</span><span class="n">signal_fft</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span>

        <span class="n">shifted_signal</span> <span class="o">=</span> <span class="n">signal_fft</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">shifted_signal</span></div>

<div class="viewcode-block" id="TimeHistoryArray.overlap_and_add"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.overlap_and_add">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">overlap_and_add</span><span class="p">(</span><span class="n">functions_to_overlap</span><span class="p">,</span> <span class="n">overlap_samples</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a time history by overlapping and adding other time histories.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        functions_to_overlap : TimeHistoryArray or list of TimeHistoryArray</span>
<span class="sd">            A set of TimeHistoryArrays to overlap and add together.  If a single</span>
<span class="sd">            TimeHistoryArray is specified, then the first dimension will be used</span>
<span class="sd">            to split the signal into segments.  All TimeHistoryArrays must have</span>
<span class="sd">            the same shape and metadata, but need not have the same number of</span>
<span class="sd">            elements.</span>
<span class="sd">        overlap_samples : int</span>
<span class="sd">            Number of samples to overlap the segments as they are added together</span>


<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray</span>
<span class="sd">            A TimeHistoryArray consisting of the signals overlapped and added</span>
<span class="sd">            together.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        All metadata is taken from the first signal.  No checks are performed to</span>
<span class="sd">        make sure that the subsequent functions have common coordinates or</span>
<span class="sd">        abscissa spacing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First compute the final length of the signal</span>
        <span class="n">num_samples</span> <span class="o">=</span> <span class="n">functions_to_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">num_elements</span>
        <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">functions_to_overlap</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">num_samples</span> <span class="o">+=</span> <span class="n">signal</span><span class="o">.</span><span class="n">num_elements</span><span class="o">-</span><span class="n">overlap_samples</span>
        <span class="c1"># Set up the ordinate</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">functions_to_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">num_samples</span><span class="p">,))</span>
        <span class="c1"># Go through each frame and add it to the function</span>
        <span class="n">starting_index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">signal</span> <span class="ow">in</span> <span class="n">functions_to_overlap</span><span class="p">:</span>
            <span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">starting_index</span><span class="p">:</span><span class="n">starting_index</span><span class="o">+</span><span class="n">signal</span><span class="o">.</span><span class="n">num_elements</span><span class="p">]</span> <span class="o">+=</span> <span class="n">signal</span><span class="o">.</span><span class="n">ordinate</span>
            <span class="n">starting_index</span> <span class="o">+=</span> <span class="n">signal</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="n">overlap_samples</span>
        <span class="c1"># Now set up the rest of the metadata</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">functions_to_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_samples</span><span class="p">)</span> <span class="o">+</span> <span class="n">functions_to_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">,</span>
                          <span class="n">functions_to_overlap</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="TimeHistoryArray.remove_rigid_body_motion"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.remove_rigid_body_motion">[docs]</a>    <span class="k">def</span> <span class="nf">remove_rigid_body_motion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Removes rigid body displacements from time data.</span>

<span class="sd">        This function assumes the current TimeHistoryArray is a displacement</span>
<span class="sd">        signal and adds it to the geometry to create node positions over time,</span>
<span class="sd">        then it fits a rigid coordinate transformation to each time step and</span>
<span class="sd">        subtracts off that portion of the motion from the displacement signal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : Geometry</span>
<span class="sd">            Geometry with which the node positions are computed</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray</span>
<span class="sd">            A TimeHistoryArray with the rigid body component of motion removed</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">node</span><span class="p">)</span>
        <span class="n">dofs</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">nodes</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">sorted_self</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">dofs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]]</span>
        <span class="n">displacements</span> <span class="o">=</span> <span class="n">sorted_self</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">sorted_self</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="n">starting_positions</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="p">(</span><span class="n">nodes</span><span class="p">)</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">positions_over_time</span> <span class="o">=</span> <span class="n">displacements</span> <span class="o">+</span> <span class="n">starting_positions</span>
        <span class="c1"># Rearrange indices to match the rigid transformation code</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">positions_over_time</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">starting_positions</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">R</span><span class="p">,</span> <span class="n">t</span> <span class="o">=</span> <span class="n">lstsq_rigid_transform</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">y_rigid</span> <span class="o">=</span> <span class="n">R</span><span class="nd">@x</span><span class="o">+</span><span class="n">t</span>
        <span class="n">nonrigid_displacements</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span>
            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
            <span class="n">abscissa</span><span class="p">,</span>
            <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">y</span> <span class="o">-</span> <span class="n">y_rigid</span><span class="p">,</span> <span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span>
            <span class="n">dofs</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
            <span class="n">sorted_self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span>
            <span class="n">sorted_self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span>
            <span class="n">sorted_self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
            <span class="n">sorted_self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span>
            <span class="n">sorted_self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nonrigid_displacements</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">]</span></div>

<div class="viewcode-block" id="TimeHistoryArray.stft"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.stft">[docs]</a>    <span class="k">def</span> <span class="nf">stft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">frame_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">overlap</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">overlap_samples</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
             <span class="n">check_cola</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">allow_fractional_frames</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
             <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a Short-Time Fourier Transform (STFT)</span>

<span class="sd">        The time history is split up into frames with specified length and</span>
<span class="sd">        computes the spectra for each frame.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        samples_per_frame : int, optional</span>
<span class="sd">            Number of samples in each measurement frame. Either this argument</span>
<span class="sd">            or `frame_length` must be specified.  If both or neither are</span>
<span class="sd">            specified, a `ValueError` is raised.</span>
<span class="sd">        frame_length : float, optional</span>
<span class="sd">            Length of each measurement frame in the same units as the `abscissa`</span>
<span class="sd">            field (`samples_per_frame` = `frame_length`/`self.abscissa_spacing`).</span>
<span class="sd">            Either this argument or `samples_per_frame` must be specified.  If</span>
<span class="sd">            both or neither are specified, a `ValueError` is raised.</span>
<span class="sd">        overlap : float, optional</span>
<span class="sd">            Fraction of the measurement frame to overlap (i.e. 0.25 not 25 to</span>
<span class="sd">            overlap a quarter of the frame). Either this argument or</span>
<span class="sd">            `overlap_samples` must be specified.  If both are</span>
<span class="sd">            specified, a `ValueError` is raised.  If neither are specified, no</span>
<span class="sd">            overlap is used.</span>
<span class="sd">        overlap_samples : int, optional</span>
<span class="sd">            Number of samples in the measurement frame to overlap. Either this</span>
<span class="sd">            argument or `overlap_samples` must be specified.  If both</span>
<span class="sd">            are specified, a `ValueError` is raised.  If neither are specified,</span>
<span class="sd">            no overlap is used.</span>
<span class="sd">        window : str or tuple or array_like, optional</span>
<span class="sd">            Desired window to use. If window is a string or tuple, it is passed</span>
<span class="sd">            to `scipy.signal.get_window` to generate the window values, which</span>
<span class="sd">            are DFT-even by default. See `get_window` for a list of windows and</span>
<span class="sd">            required parameters. If window is array_like it will be used</span>
<span class="sd">            directly as the window and its length must be `samples_per_frame`.</span>
<span class="sd">            If not specified, no window will be applied.</span>
<span class="sd">        check_cola : bool, optional</span>
<span class="sd">            If `True`, raise a `ValueError` if the specified overlap and window</span>
<span class="sd">            function are not compatible with COLA. The default is False.</span>
<span class="sd">        allow_fractional_frames : bool, optional</span>
<span class="sd">            If `False` (default), the signal will be split into a number of</span>
<span class="sd">            full frames, and any remaining fractional frame will be discarded.</span>
<span class="sd">            This will not allow COLA to be satisfied.</span>
<span class="sd">            If `True`, fractional frames will be retained and zero padded to</span>
<span class="sd">            create a full frames.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        frame_abscissa : np.ndarray</span>
<span class="sd">             The abscissa values at the center of each of the STFT frames</span>
<span class="sd">        stft : SpectrumArray</span>
<span class="sd">            A spectrum array with the first axis corresponding to the time</span>
<span class="sd">            values in `frame_abscissa`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">split_frames</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">split_into_frames</span><span class="p">(</span>
            <span class="n">samples_per_frame</span><span class="p">,</span> <span class="n">frame_length</span><span class="p">,</span>
            <span class="n">overlap</span><span class="p">,</span> <span class="n">overlap_samples</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span>
            <span class="n">check_cola</span><span class="p">,</span> <span class="n">allow_fractional_frames</span><span class="p">)</span>
        <span class="n">frame_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">split_frames</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">stft</span> <span class="o">=</span> <span class="n">split_frames</span><span class="o">.</span><span class="n">fft</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frame_abscissa</span><span class="p">,</span> <span class="n">stft</span></div>

<div class="viewcode-block" id="TimeHistoryArray.pseudorandom_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.pseudorandom_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">pseudorandom_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                            <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">signal_rms</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">different_realizations</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                            <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                            <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a pseudorandom signal at the specified coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Minimum frequency content in the signal. The default is the lowest</span>
<span class="sd">            nonzero frequency line.</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency content in the signal. The default is the highest</span>
<span class="sd">            frequency content in the signal, e.g. the Nyquist frequency.</span>
<span class="sd">        signal_rms : float or np.ndarray, optional</span>
<span class="sd">            RMS value for the generated signals. The default is 1.  The shape of</span>
<span class="sd">            this value should be broadcastable with the size of the</span>
<span class="sd">            generated TimeHistoryArray if different RMS values are desired for</span>
<span class="sd">            each signal.</span>
<span class="sd">        frames : int, optional</span>
<span class="sd">            Number of frames to generate.  These will essentially be repeats of</span>
<span class="sd">            the first frame for the number of frames specified. The default is 1.</span>
<span class="sd">        frequency_shape : function, optional</span>
<span class="sd">            An optional function that should accept a frequency value and return</span>
<span class="sd">            an amplitude at that frequency. The default is constant scaling</span>
<span class="sd">            across all frequency lines.</span>
<span class="sd">        different_realizations : bool</span>
<span class="sd">            An optional argument that specifies whether or not different</span>
<span class="sd">            functions should have different realizations of the pseudorandom</span>
<span class="sd">            signal, or if they should all be identical.</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified pseudorandom signal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Compute signal processing parameters</span>
        <span class="n">total_frame_length</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">signal_length</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">total_frame_length</span>
        <span class="n">f_nyquist</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">dt</span><span class="p">)</span>
        <span class="n">fft_lines</span> <span class="o">=</span> <span class="n">f_nyquist</span><span class="o">/</span><span class="n">df</span>
        <span class="k">if</span> <span class="n">frequency_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frequency_shape</span> <span class="o">=</span> <span class="n">_flat_frequency_shape</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">different_realizations</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndindex</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">ordinate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">pseudorandom</span><span class="p">(</span><span class="n">fft_lines</span><span class="p">,</span> <span class="n">f_nyquist</span><span class="p">,</span>
                                               <span class="n">min_freq</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">,</span>
                                               <span class="n">max_freq</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">,</span>
                                               <span class="n">averages</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span>
                                               <span class="n">shape_function</span><span class="o">=</span><span class="n">frequency_shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">pseudorandom</span><span class="p">(</span><span class="n">fft_lines</span><span class="p">,</span> <span class="n">f_nyquist</span><span class="p">,</span>
                                         <span class="n">min_freq</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">,</span>
                                         <span class="n">max_freq</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">,</span>
                                         <span class="n">averages</span><span class="o">=</span><span class="n">frames</span><span class="p">,</span>
                                         <span class="n">shape_function</span><span class="o">=</span><span class="n">frequency_shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Apply the RMS</span>
        <span class="n">current_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ordinate</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ordinate</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal_rms</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">/</span><span class="n">current_rms</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Now create the object</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.random_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.random_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">random_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                      <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">signal_rms</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                      <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a random signal with the specified parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Minimum frequency content in the signal. The default is the lowest</span>
<span class="sd">            nonzero frequency line.</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency content in the signal. The default is the highest</span>
<span class="sd">            frequency content in the signal, e.g. the Nyquist frequency.</span>
<span class="sd">        signal_rms : float or np.ndarray, optional</span>
<span class="sd">            RMS value for the generated signals. The default is 1.  The shape of</span>
<span class="sd">            this value should be broadcastable with the size of the</span>
<span class="sd">            generated TimeHistoryArray if different RMS values are desired for</span>
<span class="sd">            each signal.</span>
<span class="sd">        frames : int, optional</span>
<span class="sd">            Number of frames to generate.  These will essentially be repeats of</span>
<span class="sd">            the first frame for the number of frames specified. The default is 1.</span>
<span class="sd">        frequency_shape : function, optional</span>
<span class="sd">            An optional function that should accept a frequency value and return</span>
<span class="sd">            an amplitude at that frequency. The default is constant scaling</span>
<span class="sd">            across all frequency lines.</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified random signal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">frequency_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frequency_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">frequency_shape</span> <span class="o">=</span> <span class="n">_flat_frequency_shape</span>
            <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frequencies</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frequency</span> <span class="o">&lt;</span> <span class="n">min_frequency</span><span class="p">:</span>
                    <span class="n">fft</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frequency</span> <span class="o">&gt;</span> <span class="n">max_frequency</span><span class="p">:</span>
                    <span class="n">fft</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fft</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">frequency_shape</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">fft</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Now set RMS</span>
        <span class="n">current_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ordinate</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ordinate</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal_rms</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">/</span><span class="n">current_rms</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Now create the object</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.sine_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.sine_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sine_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                    <span class="n">frequency</span><span class="p">,</span> <span class="n">amplitude</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">phase</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                    <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                    <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a sinusoidal signal with the specified parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        frequency : float or np.ndarray</span>
<span class="sd">            Frequency of signal that will be generated.  If multiple frequencies</span>
<span class="sd">            are specified, they must broadcast with the final size of the</span>
<span class="sd">            TimeHistoryArray.</span>
<span class="sd">        amplitude : TYPE, optional</span>
<span class="sd">            Amplitude of signal that will be generated.  If multiple amplitudes</span>
<span class="sd">            are specified, they must broadcast with the final size of the</span>
<span class="sd">            TimeHistoryArray. The default is 1.</span>
<span class="sd">        phase : TYPE, optional</span>
<span class="sd">            Phase of signal that will be generated.  If multiple phases</span>
<span class="sd">            are specified, they must broadcast with the final size of the</span>
<span class="sd">            TimeHistoryArray.. The default is 0.</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified sine signal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">signal_length</span><span class="p">,))</span>
        <span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">sine</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">phase</span><span class="p">)</span>
        <span class="c1"># Now create the object</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="p">)</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.burst_random_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.burst_random_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">burst_random_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                            <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">signal_rms</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frequency_shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                            <span class="n">on_fraction</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">delay_fraction</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span>
                            <span class="n">ramp_fraction</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                            <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                            <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a burst random signal with the specified parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Minimum frequency content in the signal. The default is the lowest</span>
<span class="sd">            nonzero frequency line.</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency content in the signal. The default is the highest</span>
<span class="sd">            frequency content in the signal, e.g. the Nyquist frequency.</span>
<span class="sd">        signal_rms : float or np.ndarray, optional</span>
<span class="sd">            RMS value for the generated signals. The default is 1.  The shape of</span>
<span class="sd">            this value should be broadcastable with the size of the</span>
<span class="sd">            generated TimeHistoryArray if different RMS values are desired for</span>
<span class="sd">            each signal.  Note that the RMS will be computed for the &quot;burst&quot;</span>
<span class="sd">            part of the signal and not include the zero portion of the signal.</span>
<span class="sd">        frames : int, optional</span>
<span class="sd">            Number of frames to generate.  These will essentially be repeats of</span>
<span class="sd">            the first frame for the number of frames specified. The default is 1.</span>
<span class="sd">        frequency_shape : function, optional</span>
<span class="sd">            An optional function that should accept a frequency value and return</span>
<span class="sd">            an amplitude at that frequency. The default is constant scaling</span>
<span class="sd">            across all frequency lines.</span>
<span class="sd">        on_fraction : float, optional</span>
<span class="sd">            The fraction of the frame that the signal is active, default is 0.5.</span>
<span class="sd">            This portion includes the ramp_fraction, so an on_fraction of 0.5 with</span>
<span class="sd">            a ramp_fraction of 0.05 will be at full level for 0.5-2*0.05 = 0.4</span>
<span class="sd">            fraction of the full measurement frame.</span>
<span class="sd">        delay_fraction : float, optional</span>
<span class="sd">            The fraction of the frame that is empty before the signal starts,</span>
<span class="sd">            default is 0.0</span>
<span class="sd">        ramp_fraction : float, optional</span>
<span class="sd">            The fraction of the frame that is used to ramp between the off</span>
<span class="sd">            and active signal</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified burst random signal</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randn</span><span class="p">(</span><span class="o">*</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">frequency_shape</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">frequency_shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">frequency_shape</span> <span class="o">=</span> <span class="n">_flat_frequency_shape</span>
            <span class="n">frequencies</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>
            <span class="n">fft</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">frequency</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">frequencies</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frequency</span> <span class="o">&lt;</span> <span class="n">min_frequency</span><span class="p">:</span>
                    <span class="n">fft</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">elif</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">frequency</span> <span class="o">&gt;</span> <span class="n">max_frequency</span><span class="p">:</span>
                    <span class="n">fft</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">fft</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">index</span><span class="p">]</span> <span class="o">*=</span> <span class="n">frequency_shape</span><span class="p">(</span><span class="n">frequency</span><span class="p">)</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">fft</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Now set RMS</span>
        <span class="n">current_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ordinate</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ordinate</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">signal_rms</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">/</span><span class="n">current_rms</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Apply the window</span>
        <span class="n">delay_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">delay_fraction</span> <span class="o">*</span> <span class="n">signal_length</span><span class="p">)</span>
        <span class="n">ramp_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ramp_fraction</span> <span class="o">*</span> <span class="n">signal_length</span><span class="p">)</span>
        <span class="n">on_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">on_fraction</span> <span class="o">*</span> <span class="n">signal_length</span><span class="p">)</span>
        <span class="n">burst_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">signal_length</span><span class="p">,))</span>
        <span class="n">burst_window</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">delay_samples</span><span class="p">:</span><span class="n">delay_samples</span> <span class="o">+</span>
                     <span class="n">on_samples</span><span class="p">]</span> <span class="o">=</span> <span class="n">ramp_envelope</span><span class="p">(</span><span class="n">on_samples</span><span class="p">,</span> <span class="n">ramp_samples</span><span class="p">)</span>
        <span class="n">burst_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">burst_window</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>
        <span class="n">ordinate</span> <span class="o">*=</span> <span class="n">burst_window</span>
        <span class="c1"># Now create the object</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.chirp_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.chirp_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">chirp_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                     <span class="n">start_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">end_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">frames</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">amplitude_function</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">force_integer_cycles</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                     <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                     <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a chirp (sine sweep) signal with the specified parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        start_frequency : TYPE, optional</span>
<span class="sd">            Starting frequency content in the signal. The default is the lowest</span>
<span class="sd">            nonzero frequency line.</span>
<span class="sd">        end_frequency : TYPE, optional</span>
<span class="sd">            Stopping frequency content in the signal. The default is the highest</span>
<span class="sd">            non-nyquist frequency line.</span>
<span class="sd">        frames : int, optional</span>
<span class="sd">            Number of frames to generate.  These will essentially be repeats of</span>
<span class="sd">            the first frame for the number of frames specified. The default is 1.</span>
<span class="sd">        amplitude_function : function, optional</span>
<span class="sd">            An optional function that should accept a frequency value and return</span>
<span class="sd">            an amplitude at that frequency. The default is constant scaling</span>
<span class="sd">            across all frequencies.  Multiple amplitudes can be returned as long</span>
<span class="sd">            as they broadcast with the shape of the final TimeHistoryArray.</span>
<span class="sd">        force_integer_cycles : bool, optional</span>
<span class="sd">            If True, it will force an integer number of cycles, which will</span>
<span class="sd">            adjust the maximum frequency of the signal.  This will ensure the</span>
<span class="sd">            signal is continuous if repeated.  If False, the</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified chirp signal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="c1"># Create the chirp</span>
        <span class="n">signal_length_in_time</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">signal_length</span>
        <span class="n">df</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">signal_length_in_time</span>
        <span class="k">if</span> <span class="n">start_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">start_frequency</span> <span class="o">=</span> <span class="n">df</span>
        <span class="k">if</span> <span class="n">end_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_frequency</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="o">/</span><span class="mi">2</span><span class="o">-</span><span class="n">df</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">signal_length</span><span class="p">,))</span>
        <span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">chirp</span><span class="p">(</span><span class="n">start_frequency</span><span class="p">,</span> <span class="n">end_frequency</span><span class="p">,</span> <span class="n">signal_length_in_time</span><span class="p">,</span>
                              <span class="n">dt</span><span class="p">,</span> <span class="n">force_integer_cycles</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">amplitude_function</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">force_integer_cycles</span><span class="p">:</span>
                <span class="n">n_cycles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">end_frequency</span> <span class="o">*</span> <span class="n">signal_length_in_time</span><span class="p">)</span>
                <span class="n">end_frequency</span> <span class="o">=</span> <span class="n">n_cycles</span> <span class="o">/</span> <span class="n">signal_length_in_time</span>
            <span class="n">frequency_slope</span> <span class="o">=</span> <span class="p">(</span><span class="n">end_frequency</span> <span class="o">-</span> <span class="n">start_frequency</span><span class="p">)</span> <span class="o">/</span> <span class="n">signal_length</span>
            <span class="n">frequency_over_time</span> <span class="o">=</span> <span class="n">start_frequency</span> <span class="o">+</span> <span class="n">frequency_slope</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="p">)</span>
            <span class="n">amplitude_over_time</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">amplitude_function</span><span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">frequency_over_time</span><span class="p">])</span>
            <span class="n">ordinate</span> <span class="o">*=</span> <span class="n">amplitude_over_time</span>
        <span class="c1"># Create the measurement frames</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>
        <span class="c1"># Now create the object</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.pulse_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.pulse_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">pulse_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                     <span class="n">pulse_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pulse_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pulse_peak</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">sine_exponent</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">frames</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                     <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                     <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a pulse using a cosine function raised to a specified exponent</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        pulse_width : float, optional</span>
<span class="sd">            With of the pulse in the same units as `dt`. The default is 5*dt.</span>
<span class="sd">        pulse_time : float, optional</span>
<span class="sd">            The time of the pulse&#39;s occurance in the same units as `dt`.</span>
<span class="sd">            The default is 5*dt.</span>
<span class="sd">        pulse_peak : float, optional</span>
<span class="sd">            The peak amplitude of the pulse. The default is 1.</span>
<span class="sd">        sine_exponent : float, optional</span>
<span class="sd">            The exponent that the cosine function is raised to. The default is 1.</span>
<span class="sd">        frames : int, optional</span>
<span class="sd">            Number of frames to generate.  These will essentially be repeats of</span>
<span class="sd">            the first frame for the number of frames specified. The default is 1.</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified pulse signal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">signal_length</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">pulse_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pulse_time</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="mi">5</span>
        <span class="k">if</span> <span class="n">pulse_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pulse_width</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="mi">5</span>
        <span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">pulse</span><span class="p">(</span><span class="n">signal_length</span><span class="p">,</span> <span class="n">pulse_time</span><span class="p">,</span> <span class="n">pulse_width</span><span class="p">,</span> <span class="n">pulse_peak</span><span class="p">,</span>
                              <span class="n">dt</span><span class="p">,</span> <span class="n">sine_exponent</span><span class="p">)</span>
        <span class="c1"># Create the measurement frames</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>
        <span class="c1"># Now create the object</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.haversine_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.haversine_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">haversine_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">signal_length</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                         <span class="n">pulse_width</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pulse_time</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">pulse_peak</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">frames</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
                         <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a haversine pulse with the specified parameters</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Abscissa spacing in the final signal.</span>
<span class="sd">        signal_length : int</span>
<span class="sd">            Number of samples in the signal</span>
<span class="sd">        coordinates : CoordinateArray, optional</span>
<span class="sd">            Coordinate array used to generate the signal.  If the last dimension</span>
<span class="sd">            of coordinates is not shape 1, then a new axis will be added to make</span>
<span class="sd">            it shape 1.  The shape of the resulting TimeHistoryArray will be</span>
<span class="sd">            determined by the shape of the input coordinates.</span>
<span class="sd">        pulse_width : float, optional</span>
<span class="sd">            With of the pulse in the same units as `dt`. The default is 5*dt.</span>
<span class="sd">        pulse_time : float, optional</span>
<span class="sd">            The time of the pulse&#39;s peak occurance in the same units as `dt`.</span>
<span class="sd">            The default is 5*dt.</span>
<span class="sd">        pulse_peak : float, optional</span>
<span class="sd">            The peak amplitude of the pulse. The default is 1.</span>
<span class="sd">        frames : int, optional</span>
<span class="sd">            Number of frames to generate.  These will essentially be repeats of</span>
<span class="sd">            the first frame for the number of frames specified. The default is 1.</span>
<span class="sd">        comment1 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment2 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment3 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment4 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">        comment5 : np.ndarray, optional</span>
<span class="sd">            Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray :</span>
<span class="sd">            A time history containing the specified haversine pulse signal</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coordinates</span><span class="p">)</span><span class="o">.</span><span class="n">dtype</span><span class="o">.</span><span class="n">type</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">str_</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">coordinates</span><span class="p">)</span>
        <span class="c1"># Get coordinate size</span>
        <span class="k">if</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">coordinates</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">abscissa_frame</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">+</span><span class="p">(</span><span class="n">signal_length</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">pulse_time</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pulse_time</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="mi">5</span>
        <span class="k">if</span> <span class="n">pulse_width</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">pulse_width</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="mi">5</span>
        <span class="n">pulse_time</span><span class="p">,</span> <span class="n">pulse_width</span><span class="p">,</span> <span class="n">pulse_peak</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_arrays</span><span class="p">(</span><span class="n">pulse_time</span><span class="p">,</span> <span class="n">pulse_width</span><span class="p">,</span> <span class="n">pulse_peak</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">time</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">peak</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pulse_time</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">pulse_width</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">pulse_peak</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">width</span>
            <span class="n">argument</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">period</span> <span class="o">*</span> <span class="p">(</span><span class="n">abscissa_frame</span> <span class="o">-</span> <span class="n">time</span><span class="p">)</span>
            <span class="n">ordinate</span> <span class="o">+=</span> <span class="n">peak</span><span class="o">/</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">argument</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">argument</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
        <span class="c1"># Create the measurement frames</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">frames</span><span class="p">)</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">signal_length</span><span class="o">*</span><span class="n">frames</span><span class="p">)</span>
        <span class="c1"># Now create the object</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">coordinates</span><span class="p">,</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="TimeHistoryArray.sine_sweep_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray.sine_sweep_signal">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">sine_sweep_signal</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span>
                         <span class="n">frequency_breakpoints</span><span class="p">,</span> <span class="n">sweep_types</span><span class="p">,</span> <span class="n">sweep_rates</span><span class="p">,</span>
                         <span class="n">amplitudes</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">phases</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
                         <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span>
                         <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
        <span class="n">frequency_breakpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">frequency_breakpoints</span><span class="p">)</span>
        <span class="n">broadcast_to_shape</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span> <span class="o">+</span> <span class="p">(</span><span class="n">frequency_breakpoints</span><span class="o">.</span><span class="n">size</span><span class="p">,)</span>
        <span class="n">full_amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">amplitudes</span><span class="p">,</span><span class="n">broadcast_to_shape</span><span class="p">)</span>
        <span class="n">full_phases</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">phases</span><span class="p">,</span><span class="n">broadcast_to_shape</span><span class="p">)</span>
        <span class="n">full_sweep_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">sweep_types</span><span class="p">,</span> <span class="n">frequency_breakpoints</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">full_sweep_rates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">sweep_rates</span><span class="p">,</span> <span class="n">frequency_breakpoints</span><span class="o">.</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">output_signals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span><span class="n">coordinate</span> <span class="ow">in</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="n">output_signals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                <span class="n">sine_sweep</span><span class="p">(</span>
                    <span class="n">dt</span><span class="p">,</span> <span class="n">frequency_breakpoints</span><span class="p">,</span> <span class="n">full_sweep_rates</span><span class="p">,</span> <span class="n">full_sweep_types</span><span class="p">,</span>
                    <span class="n">full_amplitudes</span><span class="p">[</span><span class="n">key</span><span class="p">],</span><span class="n">full_phases</span><span class="p">[</span><span class="n">key</span><span class="p">]))</span>
        <span class="n">output_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">output_signals</span><span class="p">)</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">dt</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">output_signals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Create a time history array</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">abscissa</span><span class="p">,</span><span class="n">output_signals</span><span class="p">,</span><span class="n">coordinates</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                  <span class="n">comment1</span><span class="p">,</span> <span class="n">comment2</span><span class="p">,</span> <span class="n">comment3</span><span class="p">,</span> <span class="n">comment4</span><span class="p">,</span> <span class="n">comment5</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">time_history</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div></div>
        
        

<span class="c1"># def time_history_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="SpectrumArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.SpectrumArray.html#sdynpy.core.sdynpy_data.SpectrumArray">[docs]</a><span class="k">class</span> <span class="nc">SpectrumArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store linear spectra (for example scaled FFT results)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;complex128&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SPECTRUM</span>

<div class="viewcode-block" id="SpectrumArray.ifft"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.SpectrumArray.html#sdynpy.core.sdynpy_data.SpectrumArray.ifft">[docs]</a>    <span class="k">def</span> <span class="nf">ifft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;backward&quot;</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">,</span> <span class="o">**</span><span class="n">scipy_irfft_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a time signal from the frequency spectrum</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        norm : str, optional</span>
<span class="sd">            The type of normalization applied to the fft computation.</span>
<span class="sd">            The default is &quot;backward&quot;.</span>
<span class="sd">        rtol : float, optional</span>
<span class="sd">            Relative tolerance used in the abcsissa spacing check.</span>
<span class="sd">            The default is 1e-5.</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            Relative tolerance used in the abscissa spacing check.</span>
<span class="sd">            The default is 1e-8.</span>
<span class="sd">        scipy_irfft_kwargs :</span>
<span class="sd">            Additional keywords that will be passed to SciPy&#39;s irfft function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if the spectra passed to this function do not have</span>
<span class="sd">            equally spaced abscissa.</span>
<span class="sd">        NotImplementedError</span>
<span class="sd">            Raised if the user specifies scaling.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TimeHistoryArray</span>
<span class="sd">            The time history of the SpectrumArray.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">diffs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">diffs</span><span class="p">,</span> <span class="n">diffs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa must have identical spacing to perform the FFT&#39;</span><span class="p">)</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="o">**</span><span class="n">scipy_irfft_kwargs</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="n">dt</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="SpectrumArray.interpolate_by_zero_pad"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.SpectrumArray.html#sdynpy.core.sdynpy_data.SpectrumArray.interpolate_by_zero_pad">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_by_zero_pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_response_padded_length</span><span class="p">,</span>
                                <span class="n">return_time_response</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates a spectrum by zero padding or truncating its</span>
<span class="sd">        time response</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_response_padded_length : int</span>
<span class="sd">            Length of the final zero-padded time response</span>
<span class="sd">        return_time_response : bool, optional</span>
<span class="sd">            If True, the zero-padded impulse response function will be returned.</span>
<span class="sd">            If False, it will be transformed back to a transfer function prior</span>
<span class="sd">            to being returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SpectrumArray or TimeHistoryArray:</span>
<span class="sd">            Spectrum array with appropriately spaced abscissa</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function will automatically set the last frequency line of the</span>
<span class="sd">        SpectrumArray to zero because it won&#39;t be accurate anyway.</span>
<span class="sd">        If `time_response_padded_length` is less than the current function&#39;s</span>
<span class="sd">        `num_elements`, then it will be truncated instead of zero-padded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">time_response</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">time_response_padded_length</span> <span class="o">&lt;</span> <span class="n">time_response</span><span class="o">.</span><span class="n">num_elements</span><span class="p">:</span>
            <span class="n">time_response</span> <span class="o">=</span> <span class="n">time_response</span><span class="o">.</span><span class="n">idx_by_el</span><span class="p">[:</span><span class="n">time_response_padded_length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">time_response</span> <span class="o">=</span> <span class="n">time_response</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span>
                <span class="n">time_response_padded_length</span> <span class="o">-</span> <span class="n">time_response</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_time_response</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">time_response</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">spectrum</span> <span class="o">=</span> <span class="n">time_response</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>
            <span class="n">spectrum</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">spectrum</span></div>

<div class="viewcode-block" id="SpectrumArray.plot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.SpectrumArray.html#sdynpy.core.sdynpy_data.SpectrumArray.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">one_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">subplots_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{},</span>
             <span class="n">abscissa_markers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
             <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">abscissa_marker_type</span> <span class="o">=</span> <span class="s1">&#39;vline&#39;</span><span class="p">,</span>
             <span class="n">abscissa_marker_plot_kwargs</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the spectra</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        one_axis : bool, optional</span>
<span class="sd">            Set to True to plot all data on one axis.  Set to False to plot</span>
<span class="sd">            data on multiple subplots.  one_axis can also be set to a</span>
<span class="sd">            matplotlib axis to plot data on an existing axis.  The default is</span>
<span class="sd">            True.</span>
<span class="sd">        subplots_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib subplots function to create the</span>
<span class="sd">            figure and axes. The default is {}.</span>
<span class="sd">        plot_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib plot function. The default is {}.</span>
<span class="sd">        abscissa_markers : ndarray, optional</span>
<span class="sd">            Array containing abscissa values to mark on the plot to denote</span>
<span class="sd">            significant events.</span>
<span class="sd">        abscissa_marker_labels : str or ndarray</span>
<span class="sd">            Array of strings to label the abscissa_markers with, or</span>
<span class="sd">            alternatively a format string that accepts index and abscissa</span>
<span class="sd">            inputs (e.g. &#39;{index:}: {abscissa:0.2f}&#39;).  By default no label</span>
<span class="sd">            will be applied.</span>
<span class="sd">        abscissa_marker_type : str</span>
<span class="sd">            The type of marker to use.  This can either be the string &#39;vline&#39;</span>
<span class="sd">            or a valid matplotlib symbol specifier (e.g. &#39;o&#39;, &#39;x&#39;, &#39;.&#39;).</span>
<span class="sd">        abscissa_marker_plot_kwargs : dict</span>
<span class="sd">            Additional keyword arguments used when plotting the abscissa label</span>
<span class="sd">            markers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib axis or array of axes</span>
<span class="sd">             On which the data were plotted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">abscissa_marker_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abscissa_markers</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">abscissa_marker_labels</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">abscissa</span> <span class="o">=</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">)]</span>
                
        <span class="k">if</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">())):</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">()]))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">one_axis</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="SpectrumArray.plot_spectrogram"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.SpectrumArray.html#sdynpy.core.sdynpy_data.SpectrumArray.plot_spectrogram">[docs]</a>    <span class="k">def</span> <span class="nf">plot_spectrogram</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">abscissa</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">subplots_kwargs</span><span class="o">=</span><span class="p">{},</span>
                         <span class="n">pcolormesh_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;shading&#39;</span><span class="p">:</span> <span class="s1">&#39;auto&#39;</span><span class="p">},</span>
                         <span class="n">log_scale</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots a spectrogram</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        abscissa : np.ndarray</span>
<span class="sd">            Optional argument to specify as the abscissa values.  If not</span>
<span class="sd">            specified, this will be the index of the flattened SpectrumArray.</span>
<span class="sd">        axis : matplotlib.axis, optional</span>
<span class="sd">            An optional argument that specifies the axis to plot the spectrogram</span>
<span class="sd">            on</span>
<span class="sd">        subplots_kwargs : dict, optional</span>
<span class="sd">            Optional keywords to specify to the subplots function that creates</span>
<span class="sd">            a new figure if `axis` is not specified.</span>
<span class="sd">        pcolormesh_kwargs : dict, optional</span>
<span class="sd">            Optional arguments to pass to the pcolormesh function</span>
<span class="sd">        log_scale : bool</span>
<span class="sd">            If True, the colormap will be applied logarithmically</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ax : matplotlib.axis</span>
<span class="sd">            The axis on which the spectrogram was plotted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure the abscissa are common</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">validate_common_abscissa</span><span class="p">()</span>
        <span class="n">flat_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">data</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">log_scale</span><span class="p">:</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
        <span class="n">y_coords</span> <span class="o">=</span> <span class="n">flat_self</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="k">if</span> <span class="n">abscissa</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">fig</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">pcolormesh</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">y_coords</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">pcolormesh_kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axis</span></div></div>


<span class="c1"># def spectrum_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="PowerSpectralDensityArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray">[docs]</a><span class="k">class</span> <span class="nc">PowerSpectralDensityArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store power spectral density arrays&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;complex128&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span>

<div class="viewcode-block" id="PowerSpectralDensityArray.from_time_data"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.from_time_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_time_data</span><span class="p">(</span><span class="n">response_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span><span class="p">,</span>
                       <span class="n">samples_per_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.0</span><span class="p">,)),</span> 
                       <span class="n">reference_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">only_asds</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a PSD matrix from reference and response time histories</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        response_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as responses</span>
<span class="sd">        samples_per_average : int, optional</span>
<span class="sd">            Number of samples used to split up the signals into averages.  The</span>
<span class="sd">            default is None, meaning the data is treated as a single measurement</span>
<span class="sd">            frame.</span>
<span class="sd">        overlap : float, optional</span>
<span class="sd">            The overlap as a fraction of the frame (e.g. 0.5 specifies 50% overlap).</span>
<span class="sd">            The default is 0.0, meaning no overlap is used.</span>
<span class="sd">        window : np.ndarray or str, optional</span>
<span class="sd">            A 1D ndarray with length samples_per_average that specifies the</span>
<span class="sd">            coefficients of the window.  A Hann window is applied if not specified.</span>
<span class="sd">            If a string is specified, then the window will be obtained from scipy.</span>
<span class="sd">        reference_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as reference.  If not specified, the response</span>
<span class="sd">            data will be used as references, resulting in a square CPSD matrix.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if reference and response functions do not have consistent</span>
<span class="sd">            abscissa</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            A PSD array computed from the specified reference and</span>
<span class="sd">            response signals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reference_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_data</span> <span class="o">=</span> <span class="n">response_data</span>
            <span class="n">ref_ord</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">ref_data</span> <span class="o">=</span> <span class="n">reference_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">elif</span> <span class="n">only_asds</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`only_asds` cannot be true when reference data is &#39;</span>
                             <span class="s1">&#39;specified&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ref_data</span> <span class="o">=</span> <span class="n">reference_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
            <span class="n">ref_ord</span> <span class="o">=</span> <span class="n">ref_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">res_data</span> <span class="o">=</span> <span class="n">response_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">res_ord</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                           <span class="n">res_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">))</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span><span class="n">res_data</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reference and Response Data should have identical abscissa!&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">abscissa_spacing</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">cpsd</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">res_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                           <span class="n">window</span><span class="p">,</span> <span class="n">reference_signals</span> <span class="o">=</span> <span class="n">ref_ord</span><span class="p">,</span><span class="n">only_asds</span> <span class="o">=</span> <span class="n">only_asds</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cpsd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">df</span>
        <span class="c1"># Now construct the transfer function array</span>
        <span class="k">if</span> <span class="n">only_asds</span><span class="p">:</span>
            <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">res_data</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                                         <span class="n">ref_data</span><span class="o">.</span><span class="n">coordinate</span><span class="p">),</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">coordinate</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">res_data</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                       <span class="n">ref_data</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span>
                          <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">cpsd</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.generate_time_history"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.generate_time_history">[docs]</a>    <span class="k">def</span> <span class="nf">generate_time_history</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_length</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">output_oversample</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates a time history from a CPSD matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        time_length : float, optional</span>
<span class="sd">            The length (in time, not samples) of the signal.  If not specified,</span>
<span class="sd">            the signal length will be based on the frequency spacing and</span>
<span class="sd">            nyquist frequency of the CPSD matrix.  If specified, a signal will</span>
<span class="sd">            be constructed using constant overlap and add techniques.  A whole</span>
<span class="sd">            number of realizations will be constructed, so the output signal</span>
<span class="sd">            can be longer than the `time_length` specified.</span>
<span class="sd">        output_oversample : int, optional</span>
<span class="sd">            Oversample factor applied to the output signal. The default is 1.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If the entries in the CPSD matrix do not have consistent abscissa</span>
<span class="sd">            or equally spaced frequency bins.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        time_history : TimeHistoryArray</span>
<span class="sd">            A time history satisfying the properties of the CPSD matrix.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_format</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">coordinates</span> <span class="o">=</span> <span class="n">matrix_format</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">matrix_format</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">validate_common_abscissa</span><span class="p">(</span><span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All functions in CPSD matrix must have the same abscissa&#39;</span><span class="p">)</span>
        <span class="n">abs_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">matrix_format</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">abs_diff</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">abs_diff</span><span class="p">,</span> <span class="n">df</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa must have constant frequency spacing.  Max </span><span class="si">{:}</span><span class="s1">, Min </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="n">abs_diff</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">abs_diff</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span>
        <span class="n">sample_rate</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">matrix_format</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="n">realization_length</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">df</span>
        <span class="k">if</span> <span class="n">time_length</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">realizations</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">realizations</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">time_length</span> <span class="o">/</span> <span class="n">realization_length</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Do constant overlap and add</span>
        <span class="n">final_signals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">coordinates</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="p">(</span><span class="n">realizations</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span>
                                 <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">output_oversample</span><span class="p">))</span>
        <span class="n">window_function</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">hann</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">output_oversample</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">**</span><span class="mf">0.5</span>
        <span class="n">window_first_half</span> <span class="o">=</span> <span class="n">window_function</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">window_first_half</span><span class="p">[</span><span class="n">window_first_half</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">window_second_half</span> <span class="o">=</span> <span class="n">window_function</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">window_second_half</span><span class="p">[:</span><span class="n">window_second_half</span><span class="o">.</span><span class="n">size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">realizations</span><span class="p">):</span>
            <span class="n">indices</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">output_oversample</span><span class="p">,</span> <span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_elements</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">output_oversample</span><span class="p">)</span>
            <span class="n">realization</span> <span class="o">=</span> <span class="n">cpsd_to_time_history</span><span class="p">(</span><span class="n">cpsd_matrix</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">df</span><span class="p">,</span> <span class="n">output_oversample</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">realization</span> <span class="o">*=</span> <span class="n">window_first_half</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">realizations</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">realization</span> <span class="o">*=</span> <span class="n">window_second_half</span>
            <span class="n">final_signals</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span> <span class="o">+=</span> <span class="n">realization</span>
        <span class="c1"># Create time history array</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">final_signals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">/</span> <span class="n">sample_rate</span> <span class="o">/</span> <span class="n">output_oversample</span>
        <span class="n">time_history</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">final_signals</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">time_history</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.mimo_forward"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.mimo_forward">[docs]</a>    <span class="k">def</span> <span class="nf">mimo_forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transfer_function</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the forward MIMO problem Gxx = Hxv@Gvv@Hxv*</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transfer_function : TransferFunctionArray</span>
<span class="sd">            Transfer function used to transform the input matrix to the</span>
<span class="sd">            response matrix</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If abscissa do not match between self and transfer function</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            Response CPSD matrix</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check consistent abscissa</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Transfer Function Abscissa do not match CPSD&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All CPSD abscissa must be identical&#39;</span><span class="p">)</span>
        <span class="c1"># First do bookkeeping, we want to get the coordinates of the response</span>
        <span class="c1"># of the FRF corresponding to the specification matrix</span>
        <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">response_dofs</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="n">reference_dofs</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reference_coordinate</span>
        <span class="n">cpsd_dofs</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">reference_dofs</span><span class="p">,</span> <span class="n">reference_dofs</span><span class="p">)</span>
        <span class="n">output_dofs</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">response_dofs</span><span class="p">,</span> <span class="n">response_dofs</span><span class="p">)</span>
        <span class="n">frf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">transfer_function</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">cpsd_dofs</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">frf_matrix</span> <span class="o">@</span> <span class="n">cpsd_matrix</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frf_matrix</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span>
                          <span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">output_dofs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.mimo_inverse"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.mimo_inverse">[docs]</a>    <span class="k">def</span> <span class="nf">mimo_inverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transfer_function</span><span class="p">,</span>
                     <span class="n">method</span><span class="o">=</span><span class="s1">&#39;standard&#39;</span><span class="p">,</span>
                     <span class="n">response_weighting_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">reference_weighting_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">regularization_weighting_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">regularization_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">cond_num_threshold</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                     <span class="n">num_retained_values</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes input estimation for MIMO random vibration problems</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        transfer_function : TransferFunctionArray</span>
<span class="sd">            System transfer functions used to estimate the input from the given</span>
<span class="sd">            response matrix</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The method to be used for the FRF matrix inversions. The available</span>
<span class="sd">            methods are:</span>
<span class="sd">                - standard - basic pseudo-inverse via numpy.linalg.pinv with the</span>
<span class="sd">                  default rcond parameter, this is the default method</span>
<span class="sd">                - threshold - pseudo-inverse via numpy.linalg.pinv with a specified</span>
<span class="sd">                  condition number threshold</span>
<span class="sd">                - tikhonov - pseudo-inverse using the Tikhonov regularization method</span>
<span class="sd">                - truncation - pseudo-inverse where a fixed number of singular values</span>
<span class="sd">                  are retained for the inverse</span>
<span class="sd">        response_weighting_matrix : sdpy.Matrix, optional</span>
<span class="sd">            Diagonal matrix used to weight response degrees of freedom (to solve the</span>
<span class="sd">            problem as a weight least squares) by multiplying the rows of the FRF</span>
<span class="sd">            matrix by a scalar weights. This matrix can also be a 3D matrix such that</span>
<span class="sd">            the the weights are different for each frequency line. The matrix should</span>
<span class="sd">            be sized [number of lines, number of references, number of references],</span>
<span class="sd">            where the number of lines either be one (the same weights at all frequencies)</span>
<span class="sd">            or the length of the abscissa (for the case where a 3D matrix is supplied).</span>
<span class="sd">        reference_weighting_matrix : sdpy.Matrix, optional</span>
<span class="sd">            Diagonal matrix used to weight reference degrees of freedom (generally for</span>
<span class="sd">            normalization) by multiplying the columns of the FRF matrix by a scalar weights.</span>
<span class="sd">            This matrix can also be a 3D matrix such that the the weights are different</span>
<span class="sd">            for each frequency line. The matrix should be sized</span>
<span class="sd">            [number of lines, number of references, number of references], where the number</span>
<span class="sd">            of lines either be one (the same weights at all frequencies) or the length</span>
<span class="sd">            of the abscissa (for the case where a 3D matrix is supplied).</span>
<span class="sd">        regularization_weighting_matrix : sdpy.Matrix, optional</span>
<span class="sd">            Matrix used to weight input degrees of freedom via Tikhonov regularization.</span>
<span class="sd">            This matrix can also be a 3D matrix such that the the weights are different</span>
<span class="sd">            for each frequency line. The matrix should be sized</span>
<span class="sd">            [number of lines, number of references, number of references], where the number</span>
<span class="sd">            of lines either be one (the same weights at all frequencies) or the length</span>
<span class="sd">            of the abscissa (for the case where a 3D matrix is supplied).</span>
<span class="sd">        regularization_parameter : float or np.ndarray, optional</span>
<span class="sd">            Scaling parameter used on the regularization weighting matrix when the tikhonov</span>
<span class="sd">            method is chosen. A vector of regularization parameters can be provided so the</span>
<span class="sd">            regularization is different at each frequency line. The vector must match the</span>
<span class="sd">            length of the abscissa in this case (either be size [num_lines,] or [num_lines, 1]).</span>
<span class="sd">        cond_num_threshold : float or np.ndarray, optional</span>
<span class="sd">            Condition number used for SVD truncation when the threshold method is chosen.</span>
<span class="sd">            A vector of condition numbers can be provided so it varies as a function of</span>
<span class="sd">            frequency. The vector must match the length of the abscissa in this case.</span>
<span class="sd">        num_retained_values : float or np.ndarray, optional</span>
<span class="sd">            Number of singular values to retain in the pseudo-inverse when the truncation</span>
<span class="sd">            method is chosen. A vector of can be provided so the number of retained values</span>
<span class="sd">            can change as a function of frequency. The vector must match the length of the</span>
<span class="sd">            abscissa in this case.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If Abscissa are not consistent</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            Input CPSD matrix</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function solves the MIMO problem Gxx = Hxv@Gvv@Hxv^* using the pseudoinverse.</span>
<span class="sd">        Gvv = Hxv^+@Gxx@Hxv^+^*, where Gvv is the source.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Wikipedia, &quot;Moore-Penrose inverse&quot;.</span>
<span class="sd">               https://en.wikipedia.org/wiki/Moore%E2%80%93Penrose_inverse</span>
<span class="sd">        .. [2] A.N. Tithe, D.J. Thompson, The quantification of structure-borne transmission pathsby inverse methods. Part 2: Use of regularization techniques,</span>
<span class="sd">               Journal of Sound and Vibration, Volume 264, Issue 2, 2003, Pages 433-451, ISSN 0022-460X,</span>
<span class="sd">               https://doi.org/10.1016/S0022-460X(02)01203-8.</span>
<span class="sd">        .. [3] Wikipedia, &quot;Ridge regression&quot;.</span>
<span class="sd">               https://en.wikipedia.org/wiki/Ridge_regression</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check consistent abscissa</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Transfer Function Abscissa do not match CPSD&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All CPSD abscissa must be identical&#39;</span><span class="p">)</span>
        <span class="c1"># First do bookkeeping, we want to get the coordinates of the response</span>
        <span class="c1"># of the FRF corresponding to the specification matrix</span>
        <span class="n">transfer_function</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">response_dofs</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="n">reference_dofs</span> <span class="o">=</span> <span class="n">transfer_function</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reference_coordinate</span>
        <span class="n">cpsd_dofs</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">response_dofs</span><span class="p">,</span> <span class="n">response_dofs</span><span class="p">)</span>
        <span class="n">output_dofs</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">reference_dofs</span><span class="p">,</span> <span class="n">reference_dofs</span><span class="p">)</span>
        <span class="n">frf_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">transfer_function</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">cpsd_dofs</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Perform the generalized inversion</span>
        <span class="k">if</span> <span class="n">response_weighting_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">response_weighting_matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                <span class="n">response_weighting_matrix</span> <span class="o">=</span> <span class="n">response_weighting_matrix</span><span class="p">[</span><span class="n">response_dofs</span><span class="p">,</span> <span class="n">response_dofs</span><span class="p">]</span>
            <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">response_weighting_matrix</span> <span class="o">@</span> <span class="n">cpsd_matrix</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">response_weighting_matrix</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reference_weighting_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">reference_weighting_matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
                <span class="n">reference_weighting_matrix</span> <span class="o">=</span> <span class="n">reference_weighting_matrix</span><span class="p">[</span><span class="n">reference_dofs</span><span class="p">,</span> <span class="n">reference_dofs</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">regularization_weighting_matrix</span><span class="p">,</span> <span class="n">Matrix</span><span class="p">):</span>
            <span class="n">regularization_weighting_matrix</span> <span class="o">=</span> <span class="n">regularization_weighting_matrix</span><span class="p">[</span><span class="n">reference_dofs</span><span class="p">,</span> <span class="n">reference_dofs</span><span class="p">]</span>
        <span class="n">frf_pinv</span> <span class="o">=</span> <span class="n">frf_inverse</span><span class="p">(</span><span class="n">frf_matrix</span><span class="p">,</span>
                               <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                               <span class="n">response_weighting_matrix</span><span class="o">=</span><span class="n">response_weighting_matrix</span><span class="p">,</span>
                               <span class="n">reference_weighting_matrix</span><span class="o">=</span><span class="n">reference_weighting_matrix</span><span class="p">,</span>
                               <span class="n">regularization_weighting_matrix</span><span class="o">=</span><span class="n">regularization_weighting_matrix</span><span class="p">,</span>
                               <span class="n">regularization_parameter</span><span class="o">=</span><span class="n">regularization_parameter</span><span class="p">,</span>
                               <span class="n">cond_num_threshold</span><span class="o">=</span><span class="n">cond_num_threshold</span><span class="p">,</span>
                               <span class="n">num_retained_values</span><span class="o">=</span><span class="n">num_retained_values</span><span class="p">)</span>
        <span class="n">method_statement_start</span> <span class="o">=</span> <span class="s1">&#39;The inputs are being computed using the &#39;</span>
        <span class="n">method_statement_end</span> <span class="o">=</span> <span class="s1">&#39; method&#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">method_statement_start</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="n">method_statement_end</span><span class="p">)</span>
        <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">frf_pinv</span> <span class="o">@</span> <span class="n">cpsd_matrix</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frf_pinv</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reference_weighting_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">output_matrix</span> <span class="o">=</span> <span class="n">reference_weighting_matrix</span><span class="nd">@output_matrix@reference_weighting_matrix</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span>
                          <span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">output_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">output_dofs</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.error_summary"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.error_summary">[docs]</a>    <span class="k">def</span> <span class="nf">error_summary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figure_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="o">**</span><span class="n">cpsd_matrices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots an error summary compared to the current array</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figure_kwargs : dict, optional</span>
<span class="sd">            Arguments to use when creating the figure. The default is {}.</span>
<span class="sd">        linewidth : float, optional</span>
<span class="sd">            Widths of the lines on the plot. The default is 1.</span>
<span class="sd">        plot_kwargs : dict, optional</span>
<span class="sd">            Arguments to use when plotting the lines. The default is {}.</span>
<span class="sd">        **cpsd_matrices : PowerSpectralDensityArray</span>
<span class="sd">            Data to compare against the current CPSD matrix.  The keys will be</span>
<span class="sd">            used as labels with _ replaced with a space.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If CPSD abscissa do not match</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Error Metrics</span>
<span class="sd">            A tuple of dictionaries of error metrics</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">dB_pow</span><span class="p">(</span><span class="n">x</span><span class="p">):</span> <span class="k">return</span> <span class="mi">10</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="n">frequencies</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">cpsd</span> <span class="ow">in</span> <span class="n">cpsd_matrices</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">cpsd</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Compared CPSD abscissa do not match&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All CPSD abscissa must be identical&#39;</span><span class="p">)</span>
        <span class="c1"># Get ASDs</span>
        <span class="n">responses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">))</span>
        <span class="n">response_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">responses</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">2</span><span class="p">)</span>
        <span class="n">channel_names</span> <span class="o">=</span> <span class="n">responses</span><span class="o">.</span><span class="n">string_array</span><span class="p">()</span>
        <span class="n">spec_asd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="bp">self</span><span class="p">[</span><span class="n">response_dofs</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span>
        <span class="n">data_asd</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">response_dofs</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span> <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">cpsd_matrices</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">spec_asd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)))</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_channels</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpsd_matrices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">total_rows</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">+</span> <span class="mi">2</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpsd_matrices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">total_rows</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">total_rows</span> <span class="o">=</span> <span class="n">nrows</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="o">**</span><span class="n">figure_kwargs</span><span class="p">)</span>
        <span class="n">grid_spec</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="n">total_rows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">figure</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
            <span class="n">this_row</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="n">ncols</span>
            <span class="n">this_col</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ncols</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">this_row</span><span class="p">,</span> <span class="n">this_col</span><span class="p">])</span>
                <span class="n">original_ax</span> <span class="o">=</span> <span class="n">ax</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">this_row</span><span class="p">,</span> <span class="n">this_col</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="n">original_ax</span><span class="p">,</span>
                                     <span class="n">sharey</span><span class="o">=</span><span class="n">original_ax</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">spec_asd</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_asd</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">channel_names</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_row</span> <span class="o">==</span> <span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_col</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">return_data</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpsd_matrices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">spec_sum_asd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">spec_asd</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">data_sum_asd</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_asd</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">db_error</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">rms</span><span class="p">(</span><span class="n">dB_pow</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="o">-</span> <span class="n">dB_pow</span><span class="p">(</span><span class="n">spec_asd</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_asd</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">plot_width</span> <span class="o">=</span> <span class="n">ncols</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">nrows</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">plot_width</span><span class="p">])</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">spec_sum_asd</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">2</span> <span class="o">*</span> <span class="n">linewidth</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">data_sum_asd</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Sum ASDs&#39;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">nrows</span><span class="p">,</span> <span class="o">-</span><span class="n">plot_width</span><span class="p">:])</span>
            <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">db_error</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;dB Error&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cpsd_matrices</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">prop_cycle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.prop_cycle&#39;</span><span class="p">]</span>
            <span class="n">colors</span> <span class="o">=</span> <span class="n">prop_cycle</span><span class="o">.</span><span class="n">by_key</span><span class="p">()[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">100</span>
            <span class="n">db_error_sum_asd</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">rms</span><span class="p">(</span><span class="n">dB_pow</span><span class="p">(</span><span class="n">sum_asd</span><span class="p">)</span> <span class="o">-</span> <span class="n">dB_pow</span><span class="p">(</span><span class="n">spec_sum_asd</span><span class="p">))</span>
                                <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">sum_asd</span> <span class="ow">in</span> <span class="n">data_sum_asd</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">db_error_rms</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">rms</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">db_error</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
            <span class="n">return_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">db_error_sum_asd</span><span class="p">,</span> <span class="n">db_error_rms</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">plot_width</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">db_error_sum_asd</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                        <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="n">legend</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">legend</span> <span class="ow">in</span> <span class="n">db_error_sum_asd</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Sum RMS dB Error&#39;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">plot_width</span><span class="p">:])</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">data</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">db_error_rms</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">),</span>
                        <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([</span><span class="n">legend</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)</span>
                               <span class="k">for</span> <span class="n">legend</span> <span class="ow">in</span> <span class="n">db_error_rms</span><span class="p">],</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;RMS dB Error&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">return_data</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.svd"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.svd">[docs]</a>    <span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the SVD of the provided CPSD matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        full_matrices : bool, optional</span>
<span class="sd">            This is an optional input for np.linalg.svd</span>
<span class="sd">        compute_uv : bool, optional</span>
<span class="sd">            This is an optional input for np.linalg.svd</span>
<span class="sd">        as_matrix : bool, optional</span>
<span class="sd">            If True, matrices are returned as a SDynPy Matrix class with named</span>
<span class="sd">            rows and columns.  Otherwise, a simple numpy array is returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        u : ndarray</span>
<span class="sd">            Left hand singular vectors, sized [..., num_responses, num_responses].</span>
<span class="sd">            Only returned when compute_uv is True.</span>
<span class="sd">        s : ndarray</span>
<span class="sd">            Singular values, sized [..., num_references]</span>
<span class="sd">        vh : ndarray</span>
<span class="sd">            Right hand singular vectors, sized [..., num_references, num_references].</span>
<span class="sd">            Only returned when compute_uv is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cpsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">cpsdOrd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">cpsd</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">cpsdOrd</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">cpsd</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">,</span>
                           <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">vh</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">vh</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">cpsd</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">,</span>
                            <span class="p">)</span>
            <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">cpsdOrd</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.get_asd"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.get_asd">[docs]</a>    <span class="k">def</span> <span class="nf">get_asd</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get functions where the response coordinate is equal to the reference coordinate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            PowerSpectralDensityArrays where the response is equal to the reference</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">indices</span><span class="p">]</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.rms"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.rms">[docs]</a>    <span class="k">def</span> <span class="nf">rms</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute RMSs of the PSDs using the diagonals</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ndarray</span>
<span class="sd">            RMS values for the ASDS</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">asd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_asd</span><span class="p">()</span>
        <span class="n">abscissa_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_spacing</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">asd</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">abscissa_spacing</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.plot_asds"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.plot_asds">[docs]</a>    <span class="k">def</span> <span class="nf">plot_asds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">figure_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">asds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_asd</span><span class="p">()</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">rms</span> <span class="o">=</span> <span class="n">asds</span><span class="o">.</span><span class="n">rms</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
            <span class="n">rms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">asds</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">one_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">subplots_kwargs</span><span class="o">=</span><span class="n">figure_kwargs</span><span class="p">,</span> <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span> <span class="n">linewidth</span><span class="p">})</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="n">asd</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">asds</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">rms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">a</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">get_ylabel</span><span class="p">()</span><span class="o">+</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">RMS: </span><span class="si">{:0.4f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rms</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="n">a</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.compare_asds"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.compare_asds">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">compare_asds</span><span class="p">(</span><span class="n">figure_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">cpsd_matrices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the diagonals of the CPSD matrix, as well as the level</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        figure_kwargs : dict, optional</span>
<span class="sd">            Optional arguments to use when creating the figure. The default is {}.</span>
<span class="sd">        linewidth : float, optional</span>
<span class="sd">            Width of plotted lines. The default is 1.</span>
<span class="sd">        **cpsd_matrices : PowerSpectralDensityArray</span>
<span class="sd">            PSDs to plot.  Only gets plotted if response and reference are</span>
<span class="sd">            identical.  The key will be used as the label with _ replaced by a</span>
<span class="sd">            space.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If degrees of freedom are not consistent between PSDs</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">asds</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">cpsd</span><span class="o">.</span><span class="n">get_asd</span><span class="p">()</span> <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">cpsd</span> <span class="ow">in</span> <span class="n">cpsd_matrices</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">asd</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">asds</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">this_dofs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">asd</span><span class="o">.</span><span class="n">coordinate</span><span class="p">))</span>
            <span class="n">this_abscissa</span> <span class="o">=</span> <span class="n">asd</span><span class="o">.</span><span class="n">abscissa</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">dofs</span> <span class="o">=</span> <span class="n">this_dofs</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">this_dofs</span> <span class="o">==</span> <span class="n">dofs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;CPSDs must have identical dofs&#39;</span><span class="p">)</span>
        <span class="c1"># Sort the dofs correctly</span>
        <span class="n">asds</span> <span class="o">=</span> <span class="p">{</span><span class="n">legend</span><span class="p">:</span> <span class="n">asd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">dofs</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="mi">2</span><span class="p">)]</span> <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">asd</span> <span class="ow">in</span> <span class="n">asds</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">num_channels</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dofs</span><span class="p">)</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">num_channels</span><span class="p">)))</span>
        <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">num_channels</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>
        <span class="n">total_rows</span> <span class="o">=</span> <span class="n">nrows</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="o">**</span><span class="n">figure_kwargs</span><span class="p">)</span>
        <span class="n">grid_spec</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">GridSpec</span><span class="p">(</span><span class="n">total_rows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="n">figure</span><span class="o">=</span><span class="n">fig</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">num_channels</span><span class="p">):</span>
            <span class="n">this_row</span> <span class="o">=</span> <span class="n">i</span> <span class="o">//</span> <span class="n">ncols</span>
            <span class="n">this_col</span> <span class="o">=</span> <span class="n">i</span> <span class="o">%</span> <span class="n">ncols</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">this_row</span><span class="p">,</span> <span class="n">this_col</span><span class="p">])</span>
                <span class="n">original_ax</span> <span class="o">=</span> <span class="n">ax</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">this_row</span><span class="p">,</span> <span class="n">this_col</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="n">original_ax</span><span class="p">,</span>
                                     <span class="n">sharey</span><span class="o">=</span><span class="n">original_ax</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">legend</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">asds</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span> <span class="n">linewidth</span><span class="o">=</span><span class="n">linewidth</span><span class="p">)</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">dofs</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_row</span> <span class="o">==</span> <span class="n">nrows</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_xticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">this_col</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">setp</span><span class="p">(</span><span class="n">ax</span><span class="o">.</span><span class="n">get_yticklabels</span><span class="p">(),</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">prop_cycle</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.prop_cycle&#39;</span><span class="p">]</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">prop_cycle</span><span class="o">.</span><span class="n">by_key</span><span class="p">()[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="mi">10</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">grid_spec</span><span class="p">[</span><span class="n">total_rows</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">ncols</span><span class="p">])</span>
        <span class="n">legend_handles</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">legend_strings</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">legend</span><span class="p">,</span> <span class="n">asd</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">asds</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">asd</span><span class="p">):</span>
                <span class="n">rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">real</span><span class="p">)</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)))</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">asds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">j</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">bar</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">rms</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">colors</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">legend_handles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                    <span class="n">legend_strings</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">legend</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39; </span><span class="si">{:.2f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">rms</span><span class="p">),</span>
                        <span class="n">horizontalalignment</span><span class="o">=</span><span class="s1">&#39;center&#39;</span><span class="p">,</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">,</span> <span class="n">rotation</span><span class="o">=</span><span class="mi">90</span><span class="p">)</span>
        <span class="c1"># Set XTicks</span>
        <span class="n">xticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">asds</span><span class="p">)))</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dofs</span><span class="p">))</span><span class="o">*</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">asds</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">xticklabels</span> <span class="o">=</span> <span class="p">[</span><span class="nb">str</span><span class="p">(</span><span class="n">dof</span><span class="p">)</span> <span class="k">for</span> <span class="n">dof</span> <span class="ow">in</span> <span class="n">dofs</span><span class="p">]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">(</span><span class="n">xticks</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">(</span><span class="n">xticklabels</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;RMS Levels&#39;</span><span class="p">)</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
        <span class="n">legend</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legend_handles</span><span class="p">,</span> <span class="n">legend_strings</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">canvas</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="n">legend_width</span> <span class="o">=</span> <span class="n">legend</span><span class="o">.</span><span class="n">get_window_extent</span><span class="p">()</span><span class="o">.</span><span class="n">width</span>
        <span class="n">figure_width</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">bbox</span><span class="o">.</span><span class="n">width</span>
        <span class="n">figure_fraction</span> <span class="o">=</span> <span class="n">legend_width</span><span class="o">/</span><span class="n">figure_width</span>
        <span class="n">ax_position</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_position</span><span class="p">()</span>
        <span class="n">ax_position</span><span class="o">.</span><span class="n">x1</span> <span class="o">-=</span> <span class="n">figure_fraction</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_position</span><span class="p">(</span><span class="n">ax_position</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.plot_singular_values"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.plot_singular_values">[docs]</a>    <span class="k">def</span> <span class="nf">plot_singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_freqency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the singular values of an FRF matrix with a visualization of the rcond tolerance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rcond : value of float, optional</span>
<span class="sd">            Cutoff for small singular values. Implemented such that the cutoff is rcond*</span>
<span class="sd">            largest_singular_value (the same as np.linalg.pinv). This is to visualize the</span>
<span class="sd">            effect of rcond and is used for display purposes only.</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Minimum frequency to plot</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency to plot</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">s_cpsd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">s_cpsd</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">s_cpsd</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rcond</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;Singular Values&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="s1">&#39;Singular Values of CPSD Matrix&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_freqency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">min_freqency</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlim</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.coherence"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.coherence">[docs]</a>    <span class="k">def</span> <span class="nf">coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the coherence of a PSD matrix</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If abscissa are not consistent.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        CoherenceArray</span>
<span class="sd">            CoherenceArray containing the values of coherence for each function.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">reshaped_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">reshaped_array</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">reshaped_array</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;All functions must have identical abscissa&#39;</span><span class="p">)</span>
        <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_array</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">coherence_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">sp_coherence</span><span class="p">(</span><span class="n">cpsd_matrix</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">coherence_array</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span>
            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span><span class="p">,</span> <span class="n">abscissa</span><span class="o">=</span><span class="n">reshaped_array</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
            <span class="n">ordinate</span><span class="o">=</span><span class="n">coherence_matrix</span><span class="p">,</span> <span class="n">coordinate</span><span class="o">=</span><span class="n">reshaped_array</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coherence_array</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">]</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.angle"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the angle of a PSD matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        NDDataArray</span>
<span class="sd">            Data array consisting of the angle of each function at each</span>
<span class="sd">            frequency line</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.set_coherence_phase"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.set_coherence_phase">[docs]</a>    <span class="k">def</span> <span class="nf">set_coherence_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coherence_array</span><span class="p">,</span> <span class="n">angle_array</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coherence and phase of a PSD matrix while maintaining the ASDs</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coherence_array : CoherenceArray</span>
<span class="sd">            Coherence to which the PSD will be set</span>
<span class="sd">        angle_array : NDDataArray</span>
<span class="sd">            Phase to which the PSD will be set</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output : PowerSpectralDensityArray</span>
<span class="sd">            PSD with coherence and phase matching that of the input argument</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">asds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_asd</span><span class="p">()</span>
        <span class="n">dofs</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">asds</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">,</span> <span class="n">asds</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">)</span>
        <span class="n">reshaped_coherence</span> <span class="o">=</span> <span class="n">coherence_array</span><span class="p">[</span><span class="n">dofs</span><span class="p">]</span>
        <span class="n">reshaped_angle</span> <span class="o">=</span> <span class="n">angle_array</span><span class="p">[</span><span class="n">dofs</span><span class="p">]</span>
        <span class="n">asd_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">asds</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">coherence_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_coherence</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">phase_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_angle</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">cpsd_matrix</span> <span class="o">=</span> <span class="n">cpsd_from_coh_phs</span><span class="p">(</span><span class="n">asd_matrix</span><span class="p">,</span> <span class="n">coherence_matrix</span><span class="p">,</span> <span class="n">phase_matrix</span><span class="p">)</span>
        <span class="n">output</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span>
                            <span class="n">asds</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">cpsd_matrix</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                            <span class="n">dofs</span><span class="p">)[</span><span class="n">dofs</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">output</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.eye"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.eye">[docs]</a>    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">eye</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">,</span> <span class="n">rms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">full_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
            <span class="n">breakpoint_frequencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">breakpoint_levels</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">breakpoint_interpolation</span><span class="o">=</span><span class="s1">&#39;lin&#39;</span><span class="p">,</span>
            <span class="n">min_frequency</span><span class="o">=</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a diagonal CPSD matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        frequencies : ndarray</span>
<span class="sd">            Frequencies at which the CPSD should be constructed</span>
<span class="sd">        coordinates : CoordinateArray</span>
<span class="sd">            CoordinateArray to use to set the CPSD values</span>
<span class="sd">        rms : ndarray, optional</span>
<span class="sd">            Value to scale the RMS of each CPSD to</span>
<span class="sd">        full_matrix : bool, optional</span>
<span class="sd">            If True, a full, square CPSD matrix will be computed.  If False, only</span>
<span class="sd">            the ASDs will be computed. The default is False.</span>
<span class="sd">        breakpoint_frequencies : iterable, optional</span>
<span class="sd">            A list of frequencies that breakpoints are defined at.</span>
<span class="sd">        breakpoint_levels : iterable, optional</span>
<span class="sd">            A list of levels that breakpoints are defined at</span>
<span class="sd">        breakpoint_interpolation : str, optional</span>
<span class="sd">            &#39;lin&#39; or &#39;log&#39; to specify the type of interpolation. The default is</span>
<span class="sd">            &#39;lin&#39;.</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Low frequency cutoff for the CPSD.  Frequency lines below this value</span>
<span class="sd">            will be set to zero.</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            High frequency cutoff for the CPSD.  Frequency lines above this value</span>
<span class="sd">            will be set to zero.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If invalid interpolation is specified, or if RMS is specified with</span>
<span class="sd">            inconsistent frequency spacing.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            A set of PSDs.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">breakpoint_frequencies</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">breakpoint_levels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">frequencies</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">breakpoint_interpolation</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">,</span> <span class="s1">&#39;logarithmic&#39;</span><span class="p">]:</span>
                <span class="n">cpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">frequencies</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">breakpoint_frequencies</span><span class="p">),</span>
                                 <span class="n">breakpoint_levels</span><span class="p">,</span> <span class="n">left</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">right</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">breakpoint_interpolation</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;lin&#39;</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">]:</span>
                <span class="n">cpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">frequencies</span><span class="p">,</span> <span class="n">breakpoint_frequencies</span><span class="p">,</span> <span class="n">breakpoint_levels</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid Interpolation, should be &quot;lin&quot; or &quot;log&quot;&#39;</span><span class="p">)</span>

        <span class="c1"># Truncate to the minimum frequency</span>
        <span class="n">cpsd</span><span class="p">[</span><span class="n">frequencies</span> <span class="o">&lt;</span> <span class="n">min_frequency</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cpsd</span><span class="p">[</span><span class="n">frequencies</span> <span class="o">&gt;</span> <span class="n">max_frequency</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">rms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">frequency_spacing</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frequencies</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">frequency_spacing</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">frequencies</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;In order to specify RMS, the spacing of frequencies must be constant&#39;</span><span class="p">)</span>
            <span class="n">cpsd_rms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">cpsd</span><span class="p">)</span> <span class="o">*</span> <span class="n">frequency_spacing</span><span class="p">)</span>
            <span class="n">cpsd</span> <span class="o">*=</span> <span class="p">(</span><span class="n">rms</span> <span class="o">/</span> <span class="n">cpsd_rms</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>

        <span class="n">num_channels</span> <span class="o">=</span> <span class="n">coordinates</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">full_matrix</span><span class="p">:</span>
            <span class="n">full_cpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">num_channels</span><span class="p">,</span> <span class="n">num_channels</span><span class="p">,</span> <span class="n">frequencies</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
            <span class="n">full_cpsd</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_channels</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num_channels</span><span class="p">),</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cpsd</span>
            <span class="n">cpsd_coordinates</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">coordinates</span><span class="p">,</span> <span class="n">coordinates</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">full_cpsd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">cpsd</span><span class="p">,</span> <span class="p">(</span><span class="n">num_channels</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
            <span class="n">cpsd_coordinates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">coordinates</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span> <span class="n">frequencies</span><span class="p">,</span>
                          <span class="n">full_cpsd</span><span class="p">,</span> <span class="n">cpsd_coordinates</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.plot_magnitude_coherence_phase"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.plot_magnitude_coherence_phase">[docs]</a>    <span class="k">def</span> <span class="nf">plot_magnitude_coherence_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">compare_data</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">plot_axes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logx</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                       <span class="n">logy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                       <span class="n">magnitude_plot_kwargs</span><span class="o">=</span><span class="p">{},</span>
                                       <span class="n">coherence_plot_kwargs</span><span class="o">=</span><span class="p">{},</span>
                                       <span class="n">angle_plot_kwargs</span><span class="o">=</span><span class="p">{},</span>
                                       <span class="n">figure_kwargs</span><span class="o">=</span><span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the magnitude, coherence, and phase of a CPSD matrix.</span>

<span class="sd">        Coherence is plotted on the upper triangle, phase on the lower triangle,</span>
<span class="sd">        and magnitude on the diagonal.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        compare_data : PowerSpectralDensityArray, optional</span>
<span class="sd">            An optional dataset to compare against. The default is None.</span>
<span class="sd">        plot_axes : bool, optional</span>
<span class="sd">            If True, axes tick labels will be plotted.  If false, the plots will</span>
<span class="sd">            be pushed right against one another without room for labels.</span>
<span class="sd">            The default is False.</span>
<span class="sd">        sharex : bool, optional</span>
<span class="sd">            If True, all plots will share the same range on the X axis. The</span>
<span class="sd">            default is True.</span>
<span class="sd">        sharey : bool, optional</span>
<span class="sd">            If true, all plots of the same type will share the same range on the</span>
<span class="sd">            Y axis. The default is True.</span>
<span class="sd">        logx : bool, optional</span>
<span class="sd">            If true, the x-axis will be logarithmic. The default is False.</span>
<span class="sd">        logy : bool, optional</span>
<span class="sd">            If true, the y-axis on magnitude plots will be logrithmic. The</span>
<span class="sd">            default is True.</span>
<span class="sd">        magnitude_plot_kwargs : dict, optional</span>
<span class="sd">            Optional keywards to use when plotting magnitude. The default is {}.</span>
<span class="sd">        coherence_plot_kwargs : dict, optional</span>
<span class="sd">            Optional keywards to use when plotting coherence. The default is {}.</span>
<span class="sd">        angle_plot_kwargs : dict, optional</span>
<span class="sd">            Optional keywards to use when plotting phase. The default is {}.</span>
<span class="sd">        figure_kwargs : dict, optional</span>
<span class="sd">            Optional keywards to use when creating the figure. The default is {}.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="o">**</span><span class="n">figure_kwargs</span><span class="p">)</span>
        <span class="n">reshaped_array</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">coherence</span> <span class="o">=</span> <span class="n">reshaped_array</span><span class="o">.</span><span class="n">coherence</span><span class="p">()</span>
        <span class="n">phase</span> <span class="o">=</span> <span class="n">reshaped_array</span><span class="o">.</span><span class="n">angle</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reshaped_compare_data</span> <span class="o">=</span> <span class="n">compare_data</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
            <span class="n">compare_coherence</span> <span class="o">=</span> <span class="n">reshaped_compare_data</span><span class="o">.</span><span class="n">coherence</span><span class="p">()</span>
            <span class="n">phase_compare</span> <span class="o">=</span> <span class="n">reshaped_compare_data</span><span class="o">.</span><span class="n">angle</span><span class="p">()</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">gs</span> <span class="o">=</span> <span class="n">GridSpec</span><span class="p">(</span><span class="o">*</span><span class="n">reshaped_array</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">fig</span><span class="p">,</span>
                      <span class="n">wspace</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">plot_axes</span> <span class="k">else</span> <span class="mi">0</span><span class="p">,</span>
                      <span class="n">hspace</span><span class="o">=</span><span class="kc">None</span> <span class="k">if</span> <span class="n">plot_axes</span> <span class="k">else</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">function</span> <span class="ow">in</span> <span class="n">reshaped_array</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">sharex</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sharey</span><span class="p">))</span> <span class="ow">or</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">])</span>
                <span class="k">elif</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sharex</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sharey</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">elif</span> <span class="n">sharex</span> <span class="ow">and</span> <span class="p">(</span><span class="ow">not</span> <span class="n">sharey</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">):</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                               <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span>
                              <span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">magnitude_plot_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">reshaped_compare_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">reshaped_compare_data</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">),</span>
                                  <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span> <span class="mf">.5</span><span class="p">,</span> <span class="mf">.5</span><span class="p">],</span> <span class="o">**</span><span class="n">magnitude_plot_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">logy</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span>
                    <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                    <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sharex</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sharey</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">phase</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span>
                              <span class="s1">&#39;g&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">angle_plot_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">phase_compare</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">phase_compare</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">angle_plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span>
                    <span class="n">gs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span>
                    <span class="n">sharex</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sharex</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
                    <span class="n">sharey</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="n">sharey</span> <span class="k">else</span> <span class="kc">None</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">coherence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span>
                              <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">coherence_plot_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">compare_coherence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                                  <span class="n">compare_coherence</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span>
                                  <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">],</span> <span class="o">**</span><span class="n">coherence_plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">logx</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">reshaped_array</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plot_axes</span><span class="p">:</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_yticklabels</span><span class="p">([])</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">set_xticklabels</span><span class="p">([])</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">direction</span><span class="o">=</span><span class="s1">&#39;in&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="PowerSpectralDensityArray.to_rattlesnake_specification"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.to_rattlesnake_specification">[docs]</a>    <span class="k">def</span> <span class="nf">to_rattlesnake_specification</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">coordinate_order</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">upper_warning_db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">lower_warning_db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">upper_abort_db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">lower_abort_db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">upper_warning_psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">lower_warning_psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">upper_abort_psd</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                     <span class="n">lower_abort_psd</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">coordinate_order</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">coordinate_array</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">coordinate_order</span><span class="p">)</span>
            <span class="n">reshaped_data</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">coordinate_array</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;CPSD Matrix must be 2D to transform to rattlesnake specification&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;CPSD Matrix must be square&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Row and column coordinates of the CPSD matrix are not ordered identically&#39;</span><span class="p">)</span>
            <span class="n">reshaped_data</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="n">coordinate_array</span> <span class="o">=</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">coordinate</span>
        <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">min_frequency</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="k">if</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">max_frequency</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">inf</span>
            <span class="n">reshaped_data</span> <span class="o">=</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">)</span>
        <span class="n">out_dict</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">f</span><span class="o">=</span><span class="n">reshaped_data</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
            <span class="n">cpsd</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_data</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">upper_warning_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;warning_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijj-&gt;ij&#39;</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;cpsd&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">db2scale</span><span class="p">(</span><span class="n">upper_warning_db</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">lower_warning_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;warning_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijj-&gt;ij&#39;</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;cpsd&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">db2scale</span><span class="p">(</span><span class="n">lower_warning_db</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">upper_abort_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;abort_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijj-&gt;ij&#39;</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;cpsd&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">db2scale</span><span class="p">(</span><span class="n">upper_abort_db</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">lower_abort_db</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;abort_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;ijj-&gt;ij&#39;</span><span class="p">,</span> <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;cpsd&#39;</span><span class="p">]</span><span class="o">*</span><span class="n">db2scale</span><span class="p">(</span><span class="n">lower_abort_db</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">upper_warning_psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">upper_warning_psd</span>
            <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;iij-&gt;ij&#39;</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;jji-&gt;ji&#39;</span><span class="p">,</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa specified by upper warning signal is not equal to the specification signal&#39;</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;warning_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_signal</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">lower_warning_psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">lower_warning_psd</span>
            <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;iij-&gt;ij&#39;</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;jji-&gt;ji&#39;</span><span class="p">,</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa specified by lower warning signal is not equal to the specification signal&#39;</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;warning_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_signal</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">upper_abort_psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">upper_abort_psd</span>
            <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;iij-&gt;ij&#39;</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;jji-&gt;ji&#39;</span><span class="p">,</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa specified by upper abort signal is not equal to the specification signal&#39;</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;abort_upper&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_signal</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">lower_abort_psd</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">lower_abort_psd</span>
            <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">signal</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;iij-&gt;ij&#39;</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">reshaped_signal</span> <span class="o">=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">extract_elements_by_abscissa</span><span class="p">(</span><span class="n">min_frequency</span><span class="p">,</span> <span class="n">max_frequency</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;jji-&gt;ji&#39;</span><span class="p">,</span> <span class="n">reshaped_data</span><span class="o">.</span><span class="n">abscissa</span><span class="p">)</span> <span class="o">!=</span> <span class="n">reshaped_signal</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Abscissa specified by lower abort signal is not equal to the specification signal&#39;</span><span class="p">)</span>
            <span class="n">out_dict</span><span class="p">[</span><span class="s1">&#39;abort_lower&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">reshaped_signal</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">real</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">**</span><span class="n">out_dict</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out_dict</span></div>
    
<div class="viewcode-block" id="PowerSpectralDensityArray.bandwidth_average"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectralDensityArray.html#sdynpy.core.sdynpy_data.PowerSpectralDensityArray.bandwidth_average">[docs]</a>    <span class="k">def</span> <span class="nf">bandwidth_average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">band_lb</span><span class="p">,</span><span class="n">band_ub</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Integrates the PSD over frequency to get the power spectrum for each </span>
<span class="sd">        frequency bin (line)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        band_lb : ndarray</span>
<span class="sd">            (n_bands,1) array of bandwidth lower bounds</span>
<span class="sd">        band_ub : ndarray</span>
<span class="sd">            (n_bands,1) array of bandwidth upper bounds</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray with abscissa given by the mean of band_lb</span>
<span class="sd">        and band_ub</span>
<span class="sd">        </span>
<span class="sd">        Notes</span>
<span class="sd">        -------</span>
<span class="sd">        Determines which freq bins (lines) contribute to each band. Contribute</span>
<span class="sd">        means the freq bin is at least partially within the band limits</span>
<span class="sd">        </span>
<span class="sd">        The portion of the bin which contributes to the band is computed based</span>
<span class="sd">        multiplied by the fraction of the contributing frequency to get how</span>
<span class="sd">        much bin PS adds to the band PS</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Process inputs</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span><span class="mi">2</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span>
            <span class="n">ein_str</span> <span class="o">=</span> <span class="s1">&#39;jk,lk-&gt;lj&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,:]</span>
            <span class="n">ein_str</span> <span class="o">=</span> <span class="s1">&#39;jk,lmk-&gt;lmj&#39;</span>
            
        <span class="n">band_lb</span><span class="p">,</span> <span class="n">band_ub</span> <span class="o">=</span> <span class="p">[</span><span class="n">band_lb</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">band_ub</span><span class="o">.</span><span class="n">flatten</span><span class="p">()]</span>
        <span class="n">band_lb</span><span class="p">,</span><span class="n">band_ub</span> <span class="o">=</span> <span class="p">[</span> <span class="n">band_lb</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="p">,</span> <span class="n">band_ub</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="p">]</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">freq</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">freq</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">hlf_bin</span> <span class="o">=</span> <span class="n">df</span><span class="o">/</span><span class="mi">2</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span><span class="o">-</span><span class="n">df</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mf">1e-12</span><span class="p">:</span>
            <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Frequencies are not evenly spaced&#39;</span><span class="p">)</span>
        
        <span class="c1"># Determine matrix A s.t. A_jk PSD_lmk = PSDav_lmj</span>
        <span class="n">bandwidths</span> <span class="o">=</span> <span class="n">band_ub</span><span class="o">-</span><span class="n">band_lb</span>
        <span class="n">bin_map_lb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">freq</span><span class="o">-</span><span class="n">hlf_bin</span><span class="p">,</span><span class="n">band_lb</span><span class="p">)</span> <span class="c1"># LB of overlap for each bin/band combo</span>
        <span class="n">bin_map_ub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">freq</span><span class="o">+</span><span class="n">hlf_bin</span><span class="p">,</span><span class="n">band_ub</span><span class="p">)</span> <span class="c1"># UB of overlap for each bin/band combo</span>
        
        <span class="n">bin_to_band</span> <span class="o">=</span> <span class="p">(</span><span class="n">bin_map_ub</span><span class="o">-</span><span class="n">bin_map_lb</span><span class="p">)</span><span class="o">/</span><span class="n">df</span>
        <span class="n">bin_to_band</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">bin_to_band</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">bin_to_band</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        
        <span class="c1"># Get PSD</span>
        <span class="n">psd_ave</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="n">ein_str</span><span class="p">,</span><span class="n">bin_to_band</span><span class="p">,</span><span class="n">df</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span>
            
        <span class="n">psd_ave</span> <span class="o">=</span> <span class="n">psd_ave</span><span class="o">/</span><span class="p">(</span><span class="n">band_ub</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">band_lb</span><span class="p">[:,</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span> <span class="p">(</span><span class="n">band_lb</span><span class="p">,</span><span class="n">band_ub</span><span class="p">)</span> <span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span><span class="n">freqs</span><span class="p">,</span>
                         <span class="n">psd_ave</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span><span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="PowerSpectrumArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.PowerSpectrumArray.html#sdynpy.core.sdynpy_data.PowerSpectrumArray">[docs]</a><span class="k">class</span> <span class="nc">PowerSpectrumArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store power spectra arrays&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;complex128&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOSPECTRUM</span></div>
<span class="c1"># def power_spectrum_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="TransferFunctionArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray">[docs]</a><span class="k">class</span> <span class="nc">TransferFunctionArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store transfer functions (for example FRFs)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;complex128&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

<div class="viewcode-block" id="TransferFunctionArray.from_time_data"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_time_data</span><span class="p">(</span><span class="n">reference_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span><span class="p">,</span>
                       <span class="n">response_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span><span class="p">,</span>
                       <span class="n">samples_per_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;H1&#39;</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.0</span><span class="p">,)),</span> <span class="n">return_model_data</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="o">**</span><span class="n">timedata2frf_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a transfer function from reference and response time histories</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reference_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as a reference</span>
<span class="sd">        response_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as responses</span>
<span class="sd">        samples_per_average : int, optional</span>
<span class="sd">            Number of samples used to split up the signals into averages.  The</span>
<span class="sd">            default is None, meaning the data is treated as a single measurement</span>
<span class="sd">            frame.</span>
<span class="sd">        overlap : float, optional</span>
<span class="sd">            The overlap as a fraction of the frame (e.g. 0.5 specifies 50% overlap).</span>
<span class="sd">            The default is 0.0, meaning no overlap is used.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">            The method for creating the frequency response function. &#39;H1&#39; is</span>
<span class="sd">            default if not specified. samples_per_average, overlap, and window</span>
<span class="sd">            are not used if method==&#39;LRM&#39;.</span>
<span class="sd">        window : np.ndarray or str, optional</span>
<span class="sd">            A 1D ndarray with length samples_per_average that specifies the</span>
<span class="sd">            coefficients of the window.  No window is applied if not specified.</span>
<span class="sd">            If a string is specified, then the window will be obtained from scipy.</span>
<span class="sd">        **timedata2frf_kwargs : various</span>
<span class="sd">            Additional keyword arguments that may be passed into the</span>
<span class="sd">            timedata2frf function in sdynpy.frf.  If method==&#39;LRM&#39;, see also</span>
<span class="sd">            frf_local_model in sdynpy.lrm for more options.</span>


<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if reference and response functions do not have consistent</span>
<span class="sd">            abscissa</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransferFunctionArray</span>
<span class="sd">            A transfer function array computed from the specified references and</span>
<span class="sd">            responses.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ref_data</span> <span class="o">=</span> <span class="n">reference_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">res_data</span> <span class="o">=</span> <span class="n">response_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ref_ord</span> <span class="o">=</span> <span class="n">ref_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">res_ord</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                           <span class="n">res_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reference and Response Data should have identical abscissa spacing!&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ref_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">return_model_data</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span><span class="n">frf</span><span class="p">,</span><span class="n">model_data</span> <span class="o">=</span> <span class="n">timedata2frf</span><span class="p">(</span><span class="n">ref_ord</span><span class="p">,</span> <span class="n">res_ord</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span>
                                            <span class="n">overlap</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">return_model_data</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                            <span class="o">**</span><span class="n">timedata2frf_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">freq</span><span class="p">,</span><span class="n">frf</span> <span class="o">=</span> <span class="n">timedata2frf</span><span class="p">(</span><span class="n">ref_ord</span><span class="p">,</span> <span class="n">res_ord</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span>
                                    <span class="n">overlap</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">window</span><span class="p">,</span> <span class="n">return_model_data</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                    <span class="o">**</span><span class="n">timedata2frf_kwargs</span><span class="p">)</span>
        <span class="c1"># Now construct the transfer function array</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">res_data</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                   <span class="n">ref_data</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">if</span> <span class="n">return_model_data</span><span class="p">:</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="p">(</span><span class="n">model_data</span><span class="p">[</span><span class="s1">&#39;model_selected&#39;</span><span class="p">]</span><span class="o">==</span><span class="nb">len</span><span class="p">(</span><span class="n">model_data</span><span class="p">[</span><span class="s1">&#39;modelset&#39;</span><span class="p">])</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>
            <span class="n">model_data</span> <span class="o">=</span> <span class="s1">&#39;Highest order model selected in &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">model_data</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="s1">&#39;</span><span class="si">% o</span><span class="s1">f bins.&#39;</span>
            <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">,</span>
                              <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">coordinate</span><span class="p">,</span>
                              <span class="n">comment1</span><span class="o">=</span><span class="n">model_data</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">,</span>
                              <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">coordinate</span><span class="p">)</span></div>


<div class="viewcode-block" id="TransferFunctionArray.ifft"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.ifft">[docs]</a>    <span class="k">def</span> <span class="nf">ifft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s2">&quot;backward&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">scipy_irfft_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts frequency response functions to impulse response functions via an</span>
<span class="sd">        inverse fourier transform.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        norm : str, optional</span>
<span class="sd">            The type of normalization applied to the fft computation.</span>
<span class="sd">        scipy_irfft_kwargs :</span>
<span class="sd">            Additional keywords that will be passed to SciPy&#39;s irfft function.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        Warning</span>
<span class="sd">            Raised if the transfer function array does not have evenly spaced</span>
<span class="sd">            frequency data in the 0-maximum frequency range, but appears to have been</span>
<span class="sd">            high pass filtered.</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if the transfer function array does not have evenly spaced</span>
<span class="sd">            frequency data in the 0-maximum frequency range and it does not appear</span>
<span class="sd">            to have been high pass filtered.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImpulseResponseFunctionArray</span>
<span class="sd">            The impulse response function array computed from the transfer function</span>
<span class="sd">            array.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">frfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>

        <span class="c1"># Getting some initial sampling parameters for the transform</span>
        <span class="n">number_spectral_lines</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">df</span> <span class="o">=</span> <span class="n">frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">number_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">df</span><span class="p">))</span>
        <span class="n">number_lines</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">number_samples</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">start_freq</span> <span class="o">=</span> <span class="n">frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Determining if the data needs to be zero padded at low frequencies</span>
        <span class="k">if</span> <span class="n">number_spectral_lines</span><span class="o">*</span><span class="mi">2</span> <span class="o">!=</span> <span class="n">number_samples</span> <span class="ow">and</span> <span class="n">start_freq</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span>
                <span class="s1">&#39;The FRFs are missing some frequency data&#39;</span>
                <span class="o">+</span> <span class="s1">&#39; and it is assumed that this is due to some high pass cut-off.&#39;</span>
                <span class="o">+</span> <span class="s1">&#39; The data is being zero padded at low frequencies.&#39;</span><span class="p">)</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">start_freq</span><span class="o">/</span><span class="n">df</span><span class="p">)</span>  <span class="c1"># need to check that this indexing makes sense</span>
        <span class="k">elif</span> <span class="n">number_spectral_lines</span><span class="o">*</span><span class="mi">2</span> <span class="o">!=</span> <span class="n">number_samples</span> <span class="ow">and</span> <span class="n">start_freq</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s1">&#39;The FRFs are missing some frequency data and it cannot be determined what is missing.&#39;</span>
                <span class="o">+</span> <span class="s1">&#39; The frequency data should be in the 0-Fs/2 range.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start_index</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Organizing the FRFs for the ifft, this handles the zero padding if low frequency</span>
        <span class="c1"># data is missing</span>
        <span class="n">frfs_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frfs</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">frf_ordinate_for_transform</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">number_lines</span><span class="p">,</span> <span class="n">frfs_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">frfs_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">)</span>
        <span class="n">frf_ordinate_for_transform</span><span class="p">[</span><span class="n">start_index</span><span class="p">:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">frfs_ordinate</span>

        <span class="n">irfs</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">irfft</span><span class="p">(</span><span class="n">frf_ordinate_for_transform</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">number_samples</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="o">**</span><span class="n">scipy_irfft_kwargs</span><span class="p">)</span>

        <span class="c1"># Building the time vectors</span>
        <span class="n">time_vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">dt</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">number_samples</span><span class="p">))</span> <span class="o">+</span> <span class="n">dt</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">time_vector</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">irfs</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">IMPULSE_RESPONSE_FUNCTION</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">irfs</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">frfs</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransferFunctionArray.enforce_causality"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.enforce_causality">[docs]</a>    <span class="k">def</span> <span class="nf">enforce_causality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exponential_taper&#39;</span><span class="p">,</span>
                          <span class="n">window_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">end_of_ringdown</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforces causality on the frequency response function via a conversion</span>
<span class="sd">        to a impulse response function, applying a cutoff window, then converting</span>
<span class="sd">        back to a frequency response function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            The window type that is applied to the data to enforce causality.</span>
<span class="sd">            Note that these options are not necessarily traditional windows</span>
<span class="sd">            (used for data processing). The current options are:</span>
<span class="sd">                - exponential_taper (default) - this applies a exponential taper</span>
<span class="sd">                  to the end of a boxcar window on the IRF.</span>
<span class="sd">                - boxcar - this applies a boxcar (uniform) window to the IRF</span>
<span class="sd">                  with the cuttoff at a specified sample.</span>
<span class="sd">                - exponential - this applies an exponential window to the IRF</span>
<span class="sd">                  with the 40 dB down point (of the window) at a specified sample.</span>
<span class="sd">                  Care should be taken when using this window type, since it can</span>
<span class="sd">                  lead to erratic behavior.</span>
<span class="sd">        window_parameter : int, optional</span>
<span class="sd">            This is a parameter that defines the window for the causality</span>
<span class="sd">            enforcement. Methods exist to define this parameter automatically</span>
<span class="sd">            if it isn&#39;t provided. The behaviors for the options are:</span>
<span class="sd">                - boxcar - the window_paramter is the sample after which the</span>
<span class="sd">                  IRF is set to zero. It is the same as the end_of_ringdown</span>
<span class="sd">                  parameter for this window type.</span>
<span class="sd">                - exponential - the window_parameter is where the 40 dB down</span>
<span class="sd">                  point is for the window. It is the same as the end_of_ringdown</span>
<span class="sd">                  parameter for this window type.</span>
<span class="sd">                - exponential_taper - the window_parameter is where the end point</span>
<span class="sd">                  of the window (where the amplitude is 0.001), as defined by the</span>
<span class="sd">                  number of samples after the uniform section of the window.</span>
<span class="sd">        end_of_ringdown : int, optional</span>
<span class="sd">            This is a parameter that defines the end of the uniform section of</span>
<span class="sd">            the exponetional_taper window. It is not used for either the boxcar</span>
<span class="sd">            or exponential window. Methods exist to define this parameter</span>
<span class="sd">            automatically if it isn&#39;t provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransferFunctionArray</span>
<span class="sd">            The FRF with causality enforced.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is a wrapper around the method in the impulse response function class</span>
<span class="sd">        and it may be wiser to use that function instead.</span>

<span class="sd">        Although optional, it is best practice for the user to supply a parameter</span>
<span class="sd">        for the end_of_ringdown variable if the &quot;exponential_taper&quot; method is</span>
<span class="sd">        being used or a window_parameter if the &quot;exponential&quot; or &quot;boxcar&quot; methods</span>
<span class="sd">        are being used. The code will attempt to find the end of the ring-down in</span>
<span class="sd">        the IRF and use use that as the end_of_ringdown parameter for the</span>
<span class="sd">        &quot;exponential_taper&quot; window or the window_parameter for the exponential and</span>
<span class="sd">        boxcar windows.</span>

<span class="sd">        It is not suggested that the user provide a window_paramter if the</span>
<span class="sd">        &quot;exponential_taper&quot; method is being used, since the default is likely the</span>
<span class="sd">        most logical choice.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Zvonkin, M. (2015). Methods for checking and enforcing physical quality of linear electrical network models</span>
<span class="sd">               [Masters Theses, Missouri University of Science and Technology], Missouri S&amp;T Scholars&#39; Mine, https://scholarsmine.mst.edu/masters_theses/7490/</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
        <span class="n">causal_irfs</span> <span class="o">=</span> <span class="n">irfs</span><span class="o">.</span><span class="n">enforce_causality</span><span class="p">(</span><span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span>
                                             <span class="n">window_parameter</span><span class="o">=</span><span class="n">window_parameter</span><span class="p">,</span>
                                             <span class="n">end_of_ringdown</span><span class="o">=</span><span class="n">end_of_ringdown</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">causal_irfs</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span></div>

<div class="viewcode-block" id="TransferFunctionArray.svd"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.svd">[docs]</a>    <span class="k">def</span> <span class="nf">svd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute the SVD of the provided FRF matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        full_matrices : bool, optional</span>
<span class="sd">            This is an optional input for np.linalg.svd, the default for this</span>
<span class="sd">            function is true (which differs from  the np.linalg.svd function).</span>
<span class="sd">        compute_uv : bool, optional</span>
<span class="sd">            This is an optional input for np.linalg.svd, the default for this</span>
<span class="sd">            function is true (which differs from the np.linalg.svd function).</span>
<span class="sd">        as_matrix : bool, optional</span>
<span class="sd">            If True, matrices are returned as a SDynPy Matrix class with named</span>
<span class="sd">            rows and columns.  Otherwise, a simple numpy array is returned</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        u : ndarray or Matrix</span>
<span class="sd">            Left hand singular vectors, sized [..., num_responses, num_responses].</span>
<span class="sd">            Only returned when compute_uv is True.</span>
<span class="sd">        s : ndarray or Matrix</span>
<span class="sd">            Singular values, sized [..., num_references]</span>
<span class="sd">        vh : ndarray or Matrix</span>
<span class="sd">            Right hand singular vectors, sized [..., num_references, num_references].</span>
<span class="sd">            Only returned when compute_uv is True.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">frf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">frfOrd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frf</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compute_uv</span><span class="p">:</span>
            <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">frfOrd</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
                <span class="n">u</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">frf</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">,</span>
                           <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
                <span class="n">vh</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">vh</span><span class="p">,</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">vh</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                            <span class="n">frf</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">,</span>
                            <span class="p">)</span>
            <span class="k">return</span> <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">frfOrd</span><span class="p">,</span> <span class="n">full_matrices</span><span class="p">,</span> <span class="n">compute_uv</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">as_matrix</span><span class="p">:</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">(</span><span class="n">s</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]),</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
                           <span class="n">coordinate_array</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">s</span></div>

<div class="viewcode-block" id="TransferFunctionArray.compute_mif"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_mif">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mif_type</span><span class="p">,</span> <span class="o">*</span><span class="n">mif_args</span><span class="p">,</span> <span class="o">**</span><span class="n">mif_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute a mode indicator functions from the transfer functions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        mif_type : str</span>
<span class="sd">            Mode indicator function type, one of &#39;cmif&#39;,&#39;nmif&#39;, or &#39;mmif&#39;</span>
<span class="sd">        *mif_args : list</span>
<span class="sd">            Arguments passed to the compute_*mif function</span>
<span class="sd">        **mif_kwargs : dict</span>
<span class="sd">            Keyword arguments passed to the compute_*mif function</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If an invalid mif name is provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ModeIndicatorFunctionArray</span>
<span class="sd">            Mode indicator function</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">mif_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;cmif&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_cmif</span><span class="p">(</span><span class="o">*</span><span class="n">mif_args</span><span class="p">,</span> <span class="o">**</span><span class="n">mif_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mif_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;mmif&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_mmif</span><span class="p">(</span><span class="o">*</span><span class="n">mif_args</span><span class="p">,</span> <span class="o">**</span><span class="n">mif_kwargs</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">mif_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;nmif&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">compute_nmif</span><span class="p">(</span><span class="o">*</span><span class="n">mif_args</span><span class="p">,</span> <span class="o">**</span><span class="n">mif_kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid MIF type, must be one of cmif, mmif, or nmif&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransferFunctionArray.compute_cmif"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_cmif">[docs]</a>    <span class="k">def</span> <span class="nf">compute_cmif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="s1">&#39;both&#39;</span><span class="p">,</span> <span class="n">tracking</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a complex mode indicator function from the</span>
<span class="sd">        TransferFunctionArray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        part : str, optional</span>
<span class="sd">            Specifies which part(s) of the transfer functions are used to</span>
<span class="sd">            compute the CMIF.  Can be &#39;real&#39;, &#39;imag&#39;, or &#39;both&#39;.  The default</span>
<span class="sd">            is &#39;both&#39;.</span>
<span class="sd">        tracking : str or None, optional</span>
<span class="sd">            Specifies if any singular value tracking should be used.  Can be</span>
<span class="sd">            &#39;left&#39; or &#39;right&#39;. The default is None.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if an invalid tracking is specified</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_array : ModeIndicatorFunctionArray</span>
<span class="sd">            Complex Mode Indicator Function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">matrix_form</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">matrix_form</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;imag&#39;</span> <span class="ow">or</span> <span class="n">part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;imaginary&#39;</span><span class="p">:</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">imag</span>
        <span class="k">if</span> <span class="n">part</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span>
            <span class="n">ordinate</span> <span class="o">=</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">real</span>
        <span class="n">u</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">vh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">ordinate</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">vh</span><span class="o">.</span><span class="n">conjugate</span><span class="p">()</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">tracking</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">u_unshuffled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">s_unshuffled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">s</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">v_unshuffled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">v</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">v</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">tracking</span> <span class="o">==</span> <span class="s1">&#39;left&#39;</span><span class="p">:</span>
                <span class="n">u_unshuffled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">s_unshuffled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">v_unshuffled</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="k">if</span> <span class="n">line</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">previous_u</span> <span class="o">=</span> <span class="n">u_unshuffled</span><span class="p">[</span><span class="n">line</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">this_u</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">line</span><span class="p">]</span>
                    <span class="c1"># np.linalg.norm(previous_u-this_u,axis=0)</span>
                    <span class="n">comparison_matrix</span> <span class="o">=</span> <span class="n">mac</span><span class="p">(</span><span class="n">previous_u</span><span class="p">,</span> <span class="n">this_u</span><span class="p">)</span>
                    <span class="n">current_sorting</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">comparison_matrix</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                    <span class="n">u_unshuffled</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="n">line</span><span class="p">][:,</span> <span class="n">current_sorting</span><span class="p">]</span>
                    <span class="n">s_unshuffled</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">line</span><span class="p">][</span><span class="n">current_sorting</span><span class="p">]</span>
                    <span class="n">v_unshuffled</span><span class="p">[</span><span class="n">line</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">line</span><span class="p">][:,</span> <span class="n">current_sorting</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">tracking</span> <span class="o">==</span> <span class="s1">&#39;right&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="s1">&#39;Tracking by right singular vector is not yet implemented&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;tracking must be None or &quot;left&quot; or &quot;right&quot;&#39;</span><span class="p">)</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">u_unshuffled</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v_unshuffled</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s_unshuffled</span>
        <span class="n">output_array</span> <span class="o">=</span> <span class="n">ModeIndicatorFunctionArray</span><span class="p">((</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],),</span> <span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">response_coordinate</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">T</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[(</span>
            <span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)]</span>
        <span class="k">return</span> <span class="n">output_array</span></div>

<div class="viewcode-block" id="TransferFunctionArray.compute_nmif"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_nmif">[docs]</a>    <span class="k">def</span> <span class="nf">compute_nmif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a normal mode indicator function from the</span>
<span class="sd">        TransferFunctionArray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        part : str, optional</span>
<span class="sd">            Specifies which part(s) of the transfer functions are used to</span>
<span class="sd">            compute the NMIF.  Can be &#39;real&#39; or &#39;imag&#39;.  The default</span>
<span class="sd">            is &#39;real&#39;.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if an invalid part is specified</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_array : ModeIndicatorFunctionArray</span>
<span class="sd">            Normal Mode Indicator Function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="n">part</span> <span class="o">==</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span>
            <span class="n">nmif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">part</span> <span class="o">==</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span>
            <span class="n">nmif</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)),</span>
                          <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;part must be &quot;real&quot; or &quot;imag&quot;&#39;</span><span class="p">)</span>
        <span class="n">output_array</span> <span class="o">=</span> <span class="n">ModeIndicatorFunctionArray</span><span class="p">((),</span> <span class="n">nmif</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[(</span>
            <span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)]</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">nmif</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">response_coordinate</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_array</span></div>

<div class="viewcode-block" id="TransferFunctionArray.compute_mmif"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_mmif">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mmif</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">part</span><span class="o">=</span><span class="s1">&#39;real&#39;</span><span class="p">,</span> <span class="n">mass_matrix</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a Multi Mode indicator function from the</span>
<span class="sd">        TransferFunctionArray</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        part : str, optional</span>
<span class="sd">            Specifies which part(s) of the transfer functions are used to</span>
<span class="sd">            compute the NMIF.  Can be &#39;real&#39; or &#39;imag&#39;.  The default</span>
<span class="sd">            is &#39;real&#39;.</span>
<span class="sd">        mass_matrix : np.ndarray, optional</span>
<span class="sd">            Matrix used to compute the MMIF, Identity is used if not specified</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if an invalid part is specified</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        output_array : ModeIndicatorFunctionArray</span>
<span class="sd">            Multi Mode Indicator Function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rect_frf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">ordinate</span> <span class="o">=</span> <span class="n">rect_frf</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">real</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)</span>
        <span class="n">imag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">ordinate</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">mass_matrix</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mass_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">real</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">mass_matrix</span> <span class="o">@</span> <span class="n">real</span>
        <span class="n">B</span> <span class="o">=</span> <span class="n">imag</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">@</span> <span class="n">mass_matrix</span> <span class="o">@</span> <span class="n">imag</span>
        <span class="n">mif_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">part</span> <span class="o">==</span> <span class="s1">&#39;real&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">this_a</span><span class="p">,</span> <span class="n">this_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)):</span>
                <span class="n">evalue</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">this_a</span><span class="p">,</span> <span class="p">(</span><span class="n">this_a</span> <span class="o">+</span> <span class="n">this_b</span><span class="p">),</span> <span class="n">eigvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mif_ordinate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">evalue</span>
        <span class="k">elif</span> <span class="n">part</span> <span class="o">==</span> <span class="s1">&#39;imag&#39;</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="p">(</span><span class="n">this_a</span><span class="p">,</span> <span class="n">this_b</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)):</span>
                <span class="n">evalue</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">this_b</span><span class="p">,</span> <span class="p">(</span><span class="n">this_a</span> <span class="o">+</span> <span class="n">this_b</span><span class="p">),</span> <span class="n">eigenvals_only</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">mif_ordinate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">evalue</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;part must be &quot;real&quot; or &quot;imag&quot;&#39;</span><span class="p">)</span>
        <span class="n">output_array</span> <span class="o">=</span> <span class="n">ModeIndicatorFunctionArray</span><span class="p">(</span><span class="n">mif_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">mif_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[(</span>
            <span class="mi">0</span><span class="p">,)</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">),)]</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">mif_ordinate</span><span class="o">.</span><span class="n">T</span>
        <span class="n">output_array</span><span class="o">.</span><span class="n">response_coordinate</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">mif_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">output_array</span></div>

<div class="viewcode-block" id="TransferFunctionArray.plot_cond_num"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.plot_cond_num">[docs]</a>    <span class="k">def</span> <span class="nf">plot_cond_num</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">number_retained_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plots the condition number of the FRF matrix</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        min_freqency : float, optional</span>
<span class="sd">            Minimum frequency to plot. The default is None.</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency to plot. The default is None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">s_frf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">cond_num</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">s_frf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">cond_num</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Unmodified Condition Number&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number_retained_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">s_frf</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">number_retained_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">number_retained_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_retained_values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[:,</span> <span class="n">number_retained_values</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">number_retained_values</span><span class="p">)):</span>
                    <span class="n">cutoff</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">number_retained_values</span><span class="p">[</span><span class="n">ii</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">s_frf</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Modified Condition Number&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">legend</span><span class="p">()</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Condition Number&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Condition Number of FRF Matrix&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">)</span>
            <span class="n">cond_num</span> <span class="o">=</span> <span class="n">cond_num</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span><span class="o">-</span><span class="n">min_frequency</span><span class="p">)):]</span>
        <span class="k">if</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">)</span>
            <span class="n">cond_num</span> <span class="o">=</span> <span class="n">cond_num</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span><span class="o">-</span><span class="n">max_frequency</span><span class="p">))]</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="n">cond_num</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.01</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="TransferFunctionArray.plot_singular_values"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.plot_singular_values">[docs]</a>    <span class="k">def</span> <span class="nf">plot_singular_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">rcond</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">condition_number</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">number_retained_values</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">regularization_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">min_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                             <span class="n">max_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the singular values of an FRF matrix with a visualization of the rcond tolerance</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        rcond : float or ndarray, optional</span>
<span class="sd">            Cutoff for small singular values. Implemented such that the cutoff is rcond*</span>
<span class="sd">            largest_singular_value (the same as np.linalg.pinv). This is to visualize the</span>
<span class="sd">            effect of rcond and is used for display purposes only.</span>
<span class="sd">        condition_number : float or ndarray, optional</span>
<span class="sd">            Condition number threshold for small singular values. The condition number</span>
<span class="sd">            is the reciprocal of rcond. This is to visualize the effect of condition</span>
<span class="sd">            number threshold and is used for display purposes only.</span>
<span class="sd">        number_retained_values : float or ndarray, optional</span>
<span class="sd">            Cutoff for small singular values a an integer value of number of values</span>
<span class="sd">            to retain. This is to visualize the effect of singular value truncation</span>
<span class="sd">            and is used for display purposes only.</span>
<span class="sd">        regularization_parameter: float or ndarray, optional</span>
<span class="sd">            Regularization parameter to compute the modified singular values. This is</span>
<span class="sd">            to visualize the effect of Tikhonov regularization and is used for display</span>
<span class="sd">            purposes only.</span>
<span class="sd">        min_frequency : float, optional</span>
<span class="sd">            Minimum frequency to plot</span>
<span class="sd">        max_frequency : float, optional</span>
<span class="sd">            Maximum frequency to plot</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">s_frf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">svd</span><span class="p">(</span><span class="n">compute_uv</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">as_matrix</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">s_frf</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">rcond</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">rcond</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">condition_number</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">threshold</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">condition_number</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">s_frf</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">threshold</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">number_values_above_cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">s_frf</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="p">:]</span> <span class="o">&gt;</span> <span class="n">threshold</span><span class="p">[</span><span class="n">ii</span><span class="p">])</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="n">cutoff</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">number_values_above_cutoff</span><span class="p">:]</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">number_values_above_cutoff</span><span class="p">:]</span>
            <span class="n">cutoff</span><span class="p">[</span><span class="n">cutoff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">number_retained_values</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">s_frf</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">number_retained_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">number_retained_values</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">intc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">number_retained_values</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[:,</span> <span class="n">number_retained_values</span><span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">cutoff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">s_frf</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ii</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">number_retained_values</span><span class="p">)):</span>
                    <span class="n">cutoff</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">number_retained_values</span><span class="p">[</span><span class="n">ii</span><span class="p">]:]</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[</span><span class="n">ii</span><span class="p">,</span> <span class="n">number_retained_values</span><span class="p">[</span><span class="n">ii</span><span class="p">]:]</span>
            <span class="n">cutoff</span><span class="p">[</span><span class="n">cutoff</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dashed&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">regularization_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s_modified</span> <span class="o">=</span> <span class="n">compute_tikhonov_modified_singular_values</span><span class="p">(</span><span class="n">s_frf</span><span class="p">,</span> <span class="n">regularization_parameter</span><span class="p">)</span>
            <span class="n">figure</span><span class="o">.</span><span class="n">gca</span><span class="p">()</span><span class="o">.</span><span class="n">set_prop_cycle</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">semilogy</span><span class="p">(</span><span class="n">freq</span><span class="p">,</span> <span class="n">s_modified</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;dotted&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">grid</span><span class="p">()</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Singular Values&#39;</span><span class="p">)</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Singular Values of FRF Matrix&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">min_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">left</span><span class="o">=</span><span class="n">min_frequency</span><span class="p">)</span>
            <span class="n">s_frf</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span><span class="o">-</span><span class="n">min_frequency</span><span class="p">)):,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="n">max_frequency</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">right</span><span class="o">=</span><span class="n">max_frequency</span><span class="p">)</span>
            <span class="n">s_frf</span> <span class="o">=</span> <span class="n">s_frf</span><span class="p">[:</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">freq</span><span class="o">-</span><span class="n">max_frequency</span><span class="p">)),</span> <span class="p">:]</span>
        <span class="n">axis</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">bottom</span><span class="o">=</span><span class="n">s_frf</span><span class="o">.</span><span class="n">min</span><span class="p">()</span><span class="o">*</span><span class="mf">0.9</span><span class="p">,</span> <span class="n">top</span><span class="o">=</span><span class="n">s_frf</span><span class="o">.</span><span class="n">max</span><span class="p">()</span><span class="o">*</span><span class="mf">1.1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="TransferFunctionArray.plot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">one_axis</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">part</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subplots_kwargs</span><span class="o">=</span><span class="p">{},</span>
             <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">abscissa_markers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
             <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">abscissa_marker_type</span> <span class="o">=</span> <span class="s1">&#39;vline&#39;</span><span class="p">,</span>
             <span class="n">abscissa_marker_plot_kwargs</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the transfer functions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        one_axis : bool, optional</span>
<span class="sd">            Set to True to plot all data on one axis.  Set to False to plot</span>
<span class="sd">            data on multiple subplots.  one_axis can also be set to a</span>
<span class="sd">            matplotlib axis to plot data on an existing axis.  The default is</span>
<span class="sd">            True.</span>
<span class="sd">        part : str, optional</span>
<span class="sd">            The part of the FRF to plot.  This can be, &#39;real&#39;, &#39;imag&#39; or</span>
<span class="sd">            &#39;imaginary&#39;, &#39;mag&#39; or &#39;magnitude&#39;, or &#39;phase&#39;.  If not specified,</span>
<span class="sd">            magnitude and phase will be plotted if `one_axis` is True, and </span>
<span class="sd">            magnitude will be plotted if `one_axis` is False.</span>
<span class="sd">        subplots_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib subplots function to create the</span>
<span class="sd">            figure and axes. The default is {}.</span>
<span class="sd">        plot_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib plot function. The default is {}.</span>
<span class="sd">        abscissa_markers : ndarray, optional</span>
<span class="sd">            Array containing abscissa values to mark on the plot to denote</span>
<span class="sd">            significant events.</span>
<span class="sd">        abscissa_marker_labels : str or ndarray</span>
<span class="sd">            Array of strings to label the abscissa_markers with, or</span>
<span class="sd">            alternatively a format string that accepts index and abscissa</span>
<span class="sd">            inputs (e.g. &#39;{index:}: {abscissa:0.2f}&#39;).  By default no label</span>
<span class="sd">            will be applied.</span>
<span class="sd">        abscissa_marker_type : str</span>
<span class="sd">            The type of marker to use.  This can either be the string &#39;vline&#39;</span>
<span class="sd">            or a valid matplotlib symbol specifier (e.g. &#39;o&#39;, &#39;x&#39;, &#39;.&#39;).</span>
<span class="sd">        abscissa_marker_plot_kwargs : dict</span>
<span class="sd">            Additional keyword arguments used when plotting the abscissa label</span>
<span class="sd">            markers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib axis or array of axes</span>
<span class="sd">             On which the data were plotted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">abscissa_marker_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abscissa_markers</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">abscissa_marker_labels</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">abscissa</span> <span class="o">=</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">)]</span>
                
        <span class="n">part_fns</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;imag&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">,</span>
                    <span class="s1">&#39;real&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">,</span>
                    <span class="s1">&#39;mag&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
                    <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,</span>
                    <span class="s1">&#39;phase&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">,</span>
                    <span class="s1">&#39;imaginary&#39;</span><span class="p">:</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">}</span>
        <span class="n">part_labels</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;imag&#39;</span><span class="p">:</span><span class="s1">&#39;Imaginary&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;real&#39;</span><span class="p">:</span><span class="s1">&#39;Real&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;mag&#39;</span><span class="p">:</span><span class="s1">&#39;Magnitude&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span><span class="s1">&#39;Magnitude&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;phase&#39;</span><span class="p">:</span><span class="s1">&#39;Phase&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;imaginary&#39;</span><span class="p">:</span><span class="s1">&#39;Imaginary&#39;</span><span class="p">}</span>
        <span class="n">part_yscale</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;imag&#39;</span><span class="p">:</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;real&#39;</span><span class="p">:</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;mag&#39;</span><span class="p">:</span><span class="s1">&#39;log&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;magnitude&#39;</span><span class="p">:</span><span class="s1">&#39;log&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;phase&#39;</span><span class="p">:</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                       <span class="s1">&#39;imaginary&#39;</span><span class="p">:</span><span class="s1">&#39;linear&#39;</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Phase&#39;</span><span class="p">)</span>
                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Amplitude&#39;</span><span class="p">)</span>
                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
                
            <span class="k">else</span><span class="p">:</span>
                <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">part_fns</span><span class="p">[</span><span class="n">part</span><span class="p">](</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">part_yscale</span><span class="p">[</span><span class="n">part</span><span class="p">])</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">part_labels</span><span class="p">[</span><span class="n">part</span><span class="p">])</span>
                <span class="n">axis</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">())):</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">()]))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                                <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                                <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">())):</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">part_fns</span><span class="p">[</span><span class="n">part</span><span class="p">](</span><span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">()]))</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">part_yscale</span><span class="p">[</span><span class="n">part</span><span class="p">])</span>
                    <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                                <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                                <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                    <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">one_axis</span>
            <span class="k">if</span> <span class="n">part</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                                <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                                <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                    <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                            <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                                <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                                <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                                <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                    <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                    <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                                <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                                <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                                <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                                <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                                <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                                <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                    <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">part_fns</span><span class="p">[</span><span class="n">part</span><span class="p">](</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">),</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axis</span></div>

<div class="viewcode-block" id="TransferFunctionArray.plot_with_coherence"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.plot_with_coherence">[docs]</a>    <span class="k">def</span> <span class="nf">plot_with_coherence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coherence</span><span class="p">,</span> <span class="n">part</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">subplots_kwargs</span><span class="o">=</span><span class="p">{},</span> <span class="n">plot_kwargs</span><span class="o">=</span><span class="p">{}):</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">one_axis</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span><span class="n">part</span><span class="o">=</span><span class="n">part</span><span class="p">,</span><span class="n">subplots_kwargs</span> <span class="o">=</span> <span class="n">subplots_kwargs</span><span class="p">,</span>
                         <span class="n">plot_kwargs</span> <span class="o">=</span> <span class="n">plot_kwargs</span><span class="p">)</span>
        <span class="c1"># Get the corresponding coherences</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coherence</span><span class="p">,</span><span class="n">CoherenceArray</span><span class="p">):</span>
            <span class="n">coherence</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coherence</span><span class="p">,</span><span class="n">MultipleCoherenceArray</span><span class="p">):</span>
            <span class="n">coherence</span> <span class="o">=</span> <span class="n">coherence</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,:</span><span class="mi">1</span><span class="p">]]</span>
        <span class="n">coh_axes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ax</span><span class="p">,</span> <span class="n">coh</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span><span class="n">coherence</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
            <span class="n">coh_ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
            <span class="n">coh_ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">coh</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span><span class="n">coh</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="n">plt</span><span class="o">.</span><span class="n">rcParams</span><span class="p">[</span><span class="s1">&#39;axes.prop_cycle&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">by_key</span><span class="p">()[</span><span class="s1">&#39;color&#39;</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span><span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="n">coh_ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">coh_ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">([</span><span class="o">-</span><span class="mf">0.05</span><span class="p">,</span><span class="mf">1.05</span><span class="p">])</span>
            <span class="n">coh_axes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">coh_ax</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axes</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">coh_axes</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">axes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span></div>

<div class="viewcode-block" id="TransferFunctionArray.delay_response"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.delay_response">[docs]</a>    <span class="k">def</span> <span class="nf">delay_response</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dt</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adjusts the FRF phases as if the response had been shifted `dt` in time</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dt : float</span>
<span class="sd">            Time shift to apply to the responses</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        shifted_transfer_function : TransferFunctionArray</span>
<span class="sd">            A copy of the transfer function with the phase shifted</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">shifted_transfer_function</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">omegas</span> <span class="o">=</span> <span class="n">shifted_transfer_function</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">shifted_transfer_function</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">omegas</span> <span class="o">*</span> <span class="n">dt</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">shifted_transfer_function</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span>

<div class="viewcode-block" id="TransferFunctionArray.interpolate_by_zero_pad"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.interpolate_by_zero_pad">[docs]</a>    <span class="k">def</span> <span class="nf">interpolate_by_zero_pad</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">irf_padded_length</span><span class="p">,</span> <span class="n">return_irf</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Interpolates a transfer function by zero padding or truncating its</span>
<span class="sd">        impulse response</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        irf_padded_length : int</span>
<span class="sd">            Length of the final zero-padded impulse response function</span>
<span class="sd">        return_irf : bool, optional</span>
<span class="sd">            If True, the zero-padded impulse response function will be returned.</span>
<span class="sd">            If False, it will be transformed back to a transfer function prior</span>
<span class="sd">            to being returned.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransferFunctionArray or ImpulseResponseFunctionArray:</span>
<span class="sd">            Transfer function array with appropriately spaced abscissa</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function will automatically set the last frequency line of the</span>
<span class="sd">        TransferFunctionArray to zero because it won&#39;t be accurate anyway.</span>
<span class="sd">        If `irf_padded_length` is less than the current function&#39;s `num_elements`,</span>
<span class="sd">        then it will be truncated instead of zero-padded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">irf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ifft</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">irf_padded_length</span> <span class="o">&lt;</span> <span class="n">irf</span><span class="o">.</span><span class="n">num_elements</span><span class="p">:</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">irf</span><span class="o">.</span><span class="n">idx_by_el</span><span class="p">[:</span><span class="n">irf_padded_length</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">irf</span> <span class="o">=</span> <span class="n">irf</span><span class="o">.</span><span class="n">zero_pad</span><span class="p">(</span><span class="n">irf_padded_length</span> <span class="o">-</span> <span class="n">irf</span><span class="o">.</span><span class="n">num_elements</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">return_irf</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">irf</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">frf</span> <span class="o">=</span> <span class="n">irf</span><span class="o">.</span><span class="n">fft</span><span class="p">()</span>
            <span class="n">frf</span><span class="o">.</span><span class="n">ordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">frf</span></div>

<div class="viewcode-block" id="TransferFunctionArray.substructure_by_constraint_matrix"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.substructure_by_constraint_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">substructure_by_constraint_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dofs</span><span class="p">,</span> <span class="n">constraint_matrix</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs frequency based substructuring using the</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dofs : CoordinateArray</span>
<span class="sd">            Coordinates to use in the constraints</span>
<span class="sd">        constraint_matrix : np.ndarray</span>
<span class="sd">            Constraints to apply to the frequency response functions</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            If listed degrees of freedom are not found in the function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        constrained_frfs : TransferFunctionArray</span>
<span class="sd">            Constrained Frequency Response Functions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a rectangular FRF array</span>
        <span class="n">rect_frfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Extract the reference and response dofs</span>
        <span class="n">response_dofs</span> <span class="o">=</span> <span class="n">rect_frfs</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">response_coordinate</span>
        <span class="n">reference_dofs</span> <span class="o">=</span> <span class="n">rect_frfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reference_coordinate</span>
        <span class="c1"># Now find the indices of each of the dofs</span>
        <span class="n">reference_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">reference_dofs</span><span class="p">),</span>
                                            <span class="nb">abs</span><span class="p">(</span><span class="n">dofs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">reference_dofs</span><span class="p">[</span><span class="n">reference_indices</span><span class="p">])</span> <span class="o">!=</span>
                  <span class="nb">abs</span><span class="p">(</span><span class="n">dofs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not all constraint degrees of freedom are found in the references&#39;</span><span class="p">)</span>
        <span class="n">response_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">searchsorted</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">response_dofs</span><span class="p">),</span>
                                           <span class="nb">abs</span><span class="p">(</span><span class="n">dofs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">response_dofs</span><span class="p">[</span><span class="n">response_indices</span><span class="p">])</span> <span class="o">!=</span>
                  <span class="nb">abs</span><span class="p">(</span><span class="n">dofs</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Not all constraint degrees of freedom are found in the responses&#39;</span><span class="p">)</span>
        <span class="c1"># Handle sign flipping</span>
        <span class="n">flip_sign_references</span> <span class="o">=</span> <span class="n">reference_dofs</span><span class="p">[</span><span class="n">reference_indices</span><span class="p">]</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="n">dofs</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
        <span class="n">flip_sign_responses</span> <span class="o">=</span> <span class="n">response_dofs</span><span class="p">[</span><span class="n">response_indices</span><span class="p">]</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span> <span class="o">*</span> <span class="n">dofs</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
        <span class="c1"># Put together the constraint matrix</span>
        <span class="n">constraint_matrix_responses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">constraint_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">response_dofs</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">constraint_matrix_references</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">constraint_matrix</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">reference_dofs</span><span class="o">.</span><span class="n">size</span><span class="p">))</span>
        <span class="n">constraint_matrix_responses</span><span class="p">[:,</span> <span class="n">response_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">flip_sign_responses</span> <span class="o">*</span> <span class="n">constraint_matrix</span>
        <span class="n">constraint_matrix_references</span><span class="p">[:,</span>
                                     <span class="n">reference_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">flip_sign_references</span> <span class="o">*</span> <span class="n">constraint_matrix</span>
        <span class="c1"># Perform the constraint</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">rect_frfs</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">H_constrained</span> <span class="o">=</span> <span class="n">H</span> <span class="o">-</span> <span class="n">H</span> <span class="o">@</span> <span class="n">constraint_matrix_references</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span>
            <span class="n">constraint_matrix_responses</span> <span class="o">@</span> <span class="n">H</span> <span class="o">@</span> <span class="n">constraint_matrix_references</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">constraint_matrix_responses</span> <span class="o">@</span> <span class="n">H</span><span class="p">)</span>
        <span class="n">rect_frfs</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">H_constrained</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">rect_frfs</span></div>

<div class="viewcode-block" id="TransferFunctionArray.substructure_by_coordinate"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.substructure_by_coordinate">[docs]</a>    <span class="k">def</span> <span class="nf">substructure_by_coordinate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dof_pairs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Performs frequency based substructuring by constraining pairs of degrees</span>
<span class="sd">        of freedom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dof_pairs : CoordinateArray or None</span>
<span class="sd">            Pairs of coordinates to constrain together.  To constain a coordinate</span>
<span class="sd">            to ground (i.e. fix it so it cannot move), the coordinate should be</span>
<span class="sd">            paired with None.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransferFunctionArray</span>
<span class="sd">            Constrained frequency response functions</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dof_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">constraint_matrix_values</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">constraint_index</span><span class="p">,</span> <span class="n">dof_pair</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">dof_pairs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">sign</span><span class="p">,</span> <span class="n">dof</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dof_pair</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">dof</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">dof_list</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dof</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">dof_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">dof</span><span class="p">))</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">dof_list</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
                <span class="n">flip_sign</span> <span class="o">=</span> <span class="n">dof</span><span class="o">.</span><span class="n">sign</span><span class="p">()</span>
                <span class="n">constraint_matrix_values</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">constraint_index</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span>
                                                 <span class="n">flip_sign</span> <span class="o">*</span> <span class="n">sign</span><span class="p">))</span>
        <span class="c1"># Now create the final matrix and fill it</span>
        <span class="n">constraint_matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">dof_pairs</span><span class="p">),</span>
                                      <span class="nb">len</span><span class="p">(</span><span class="n">dof_list</span><span class="p">)))</span>
        <span class="k">for</span> <span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">constraint_matrix_values</span><span class="p">:</span>
            <span class="n">constraint_matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
        <span class="c1"># Apply Constraints</span>
        <span class="n">dof_list</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dof_list</span><span class="p">)</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CoordinateArray</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">substructure_by_constraint_matrix</span><span class="p">(</span><span class="n">dof_list</span><span class="p">,</span> <span class="n">constraint_matrix</span><span class="p">)</span></div></div>

<span class="c1"># def transfer_function_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="ImpulseResponseFunctionArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.html#sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray">[docs]</a><span class="k">class</span> <span class="nc">ImpulseResponseFunctionArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store impulse response functions&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">IMPULSE_RESPONSE_FUNCTION</span>

<div class="viewcode-block" id="ImpulseResponseFunctionArray.fft"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.html#sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.fft">[docs]</a>    <span class="k">def</span> <span class="nf">fft</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;backward&#39;</span><span class="p">,</span> <span class="o">**</span><span class="n">scipy_rfft_kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the impulse response function to a frequency response function</span>
<span class="sd">        using the fft function.</span>

<span class="sd">        Paramters</span>
<span class="sd">        ---------</span>
<span class="sd">        norm : str, optional</span>
<span class="sd">            The type of normalization applied to the fft computation.</span>
<span class="sd">        scipy_rfft_kwargs :</span>
<span class="sd">            Additional keywords that will be passed to SciPy&#39;s rfft function.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        TransferFunctionArray</span>
<span class="sd">            The transfer function array computed from the impusle response function</span>
<span class="sd">            array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Some initial organization</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">irf_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">irfs</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Getting sampling parameters for the fft</span>
        <span class="n">number_samples</span> <span class="o">=</span> <span class="n">irf_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">irfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">irfs</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Doing the fft</span>
        <span class="n">frf_ordinate</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">rfft</span><span class="p">(</span><span class="n">irf_ordinate</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">norm</span><span class="p">,</span> <span class="o">**</span><span class="n">scipy_rfft_kwargs</span><span class="p">)</span>
        <span class="n">freq_vector</span> <span class="o">=</span> <span class="n">scipyfft</span><span class="o">.</span><span class="n">rfftfreq</span><span class="p">(</span><span class="n">number_samples</span><span class="p">,</span> <span class="n">dt</span><span class="p">)</span>

        <span class="c1"># Broadcasting the frequency vector to the correct size</span>
        <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">freq_vector</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">frf_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">abscissa</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span>
                          <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">frf_ordinate</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">irfs</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span></div>

<div class="viewcode-block" id="ImpulseResponseFunctionArray.find_end_of_ringdown"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.html#sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.find_end_of_ringdown">[docs]</a>    <span class="k">def</span> <span class="nf">find_end_of_ringdown</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds the end of the ringdown in a impulse response function (IRF).</span>

<span class="sd">        It does this by smoothing the IRF via a moving average filter, then finding</span>
<span class="sd">        the index of the minimum of the smoothed IRF (for each response/reference</span>
<span class="sd">        pair). The &quot;end of ringdown&quot; is defined as the median of the possible</span>
<span class="sd">        indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        end_of_ringdow : int</span>
<span class="sd">            Index that represents the end of the ringdown for the supplied IRFs.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">irf_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Start off by performing a moving average on the IRF to make</span>
        <span class="c1"># it easier to find the end of the ring down</span>
        <span class="n">moving_average_kernel_length</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">irf_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">/</span><span class="mi">5</span><span class="p">)</span>
        <span class="n">moving_average_kernel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">broadcast_to</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">moving_average_kernel_length</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span>
                                                <span class="p">(</span><span class="n">moving_average_kernel_length</span><span class="p">,</span> <span class="n">irf_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">irf_ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
        <span class="n">irf_moving_average</span> <span class="o">=</span> <span class="n">convolve</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">irf_ordinate</span><span class="p">),</span> <span class="n">moving_average_kernel</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;same&#39;</span><span class="p">)</span>

        <span class="c1"># Find where the smoothed version of the IRF is at a minimum and</span>
        <span class="c1"># then using the median index (by channel) as the window_parameter</span>
        <span class="n">min_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">irf_moving_average</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">end_of_ringdown</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">min_index</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">end_of_ringdown</span></div>

<div class="viewcode-block" id="ImpulseResponseFunctionArray.enforce_causality"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.html#sdynpy.core.sdynpy_data.ImpulseResponseFunctionArray.enforce_causality">[docs]</a>    <span class="k">def</span> <span class="nf">enforce_causality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;exponential_taper&#39;</span><span class="p">,</span>
                          <span class="n">window_parameter</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">end_of_ringdown</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Enforces causality on the impulse response function via a cutoff</span>
<span class="sd">        of some sort.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : str</span>
<span class="sd">            The window type that is applied to the data to enforce causality.</span>
<span class="sd">            Note that these options are not necessarily traditional windows</span>
<span class="sd">            (used for data processing). The current options are:</span>
<span class="sd">                - exponential_taper (default) - this applies a exponential taper</span>
<span class="sd">                to the end of a boxcar window on the IRF.</span>
<span class="sd">                - boxcar - this applies a boxcar (uniform) window to the IRF</span>
<span class="sd">                with the cuttoff at a specified sample.</span>
<span class="sd">                - exponential - this applies an exponential window to the IRF</span>
<span class="sd">                with the 40 dB down point (of the window) at a specified sample.</span>
<span class="sd">                Care should be taken when using this window type, since it can</span>
<span class="sd">                lead to erratic behavior.</span>
<span class="sd">        window_parameter : int, optional</span>
<span class="sd">            This is a parameter that defines the window for the causality</span>
<span class="sd">            enforcement. Methods exist to define this parameter automatically</span>
<span class="sd">            if it isn&#39;t provided. The behaviors for the options are:</span>
<span class="sd">                - boxcar - the window_paramter is the sample after which the</span>
<span class="sd">                IRF is set to zero. It is the same as the end_of_ringdown</span>
<span class="sd">                parameter for this window type.</span>
<span class="sd">                - exponential - the window_parameter is where the 40 dB down</span>
<span class="sd">                point is for the window. It is the same as the end_of_ringdown</span>
<span class="sd">                parameter for this window type.</span>
<span class="sd">                - exponential_taper - the window_parameter is where the end point</span>
<span class="sd">                of the window (where the amplitude is 0.001), as defined by the</span>
<span class="sd">                number of samples after the uniform section of the window.</span>
<span class="sd">        end_of_ringdown : int, optional</span>
<span class="sd">            This is a parameter that defines the end of the uniform section of</span>
<span class="sd">            the exponetional_taper window. It is not used for either the boxcar</span>
<span class="sd">            or exponential window. Methods exist to define this parameter</span>
<span class="sd">            automatically if it isn&#39;t provided.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ImpulseResponseFunctionArray</span>
<span class="sd">            The IRF with causality enforced.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Although optional, it is best practice for the user to supply a parameter</span>
<span class="sd">        for the end_of_ringdown variable if the &quot;exponential_taper&quot; method is</span>
<span class="sd">        being used or a window_parameter if the &quot;exponential&quot; or &quot;boxcar&quot; methods</span>
<span class="sd">        are being used. The code will attempt to find the end of the ring-down in</span>
<span class="sd">        the IRF and use use that as the end_of_ringdown parameter for the</span>
<span class="sd">        &quot;exponential_taper&quot; window or the window_parameter for the exponential and</span>
<span class="sd">        boxcar windows.</span>

<span class="sd">        It is not suggested that the user provide a window_paramter if the</span>
<span class="sd">        &quot;exponential_taper&quot; method is being used, since the default is likely the</span>
<span class="sd">        most logical choice.</span>

<span class="sd">        References</span>
<span class="sd">        ----------</span>
<span class="sd">        .. [1] Zvonkin, M. (2015). Methods for checking and enforcing physical quality of linear electrical network models</span>
<span class="sd">               [Masters Theses, Missouri University of Science and Technology], Missouri S&amp;T Scholars&#39; Mine, https://scholarsmine.mst.edu/masters_theses/7490/</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Organizing the IRFs and pulling the ordinate out</span>
        <span class="n">irfs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span>
        <span class="n">irf_ord</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">irfs</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;exponential_taper&#39;</span> <span class="ow">and</span> <span class="n">end_of_ringdown</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">end_of_ringdown</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_end_of_ringdown</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxcar&#39;</span> <span class="ow">and</span> <span class="n">window_parameter</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">window_parameter</span> <span class="o">&gt;=</span> <span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;window parameter is greater than the IRF block size and creates an illogical window for the data&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;exponential&#39;</span><span class="p">,</span> <span class="s1">&#39;boxcar&#39;</span><span class="p">]</span> <span class="ow">and</span> <span class="n">window_parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">window_parameter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_end_of_ringdown</span><span class="p">()</span>

        <span class="c1"># Generating the desired window, based on the seleted method</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;exponential_taper&#39;</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">window</span><span class="p">[</span><span class="n">end_of_ringdown</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">end_of_ringdown</span><span class="p">)</span>
            <span class="n">window_length</span> <span class="o">=</span> <span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">end_of_ringdown</span>
            <span class="k">if</span> <span class="n">window_parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">window_parameter</span> <span class="o">=</span> <span class="n">window_length</span>
            <span class="n">window_tau</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">window_parameter</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="mf">0.001</span><span class="p">)</span>
            <span class="n">window</span><span class="p">[</span><span class="n">end_of_ringdown</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">window_length</span><span class="p">)]</span> <span class="o">=</span> <span class="n">exponential</span><span class="p">(</span><span class="n">window_length</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">window_tau</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;exponential&#39;</span><span class="p">:</span>
            <span class="n">end_of_ringdown</span> <span class="o">=</span> <span class="n">window_parameter</span>
            <span class="n">window_tau</span> <span class="o">=</span> <span class="n">window_parameter</span><span class="o">*</span><span class="mf">8.69</span><span class="o">/</span><span class="mi">20</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">exponential</span><span class="p">(</span><span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">center</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">tau</span><span class="o">=</span><span class="n">window_tau</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;boxcar&#39;</span><span class="p">:</span>
            <span class="n">end_of_ringdown</span> <span class="o">=</span> <span class="n">window_parameter</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">window</span><span class="p">[</span><span class="n">window_parameter</span><span class="p">:]</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Setting up the time reversal window so the non-causal portion of the IRF can be added back to the IRFs</span>
        <span class="n">time_reversal_window</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">irf_ord</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">-</span> <span class="n">window</span>
        <span class="c1"># time_reversal_window[:window_parameter] = 0, might need this if using an exponential window</span>

        <span class="n">method_statement_start</span> <span class="o">=</span> <span class="s1">&#39;Causality is being enforced using &#39;</span>
        <span class="n">method_statement_middle</span> <span class="o">=</span> <span class="s1">&#39; method with a end_of_ringdown of &#39;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">method_statement_start</span><span class="o">+</span><span class="n">method</span><span class="o">+</span><span class="n">method_statement_middle</span><span class="o">+</span><span class="nb">str</span><span class="p">(</span><span class="n">end_of_ringdown</span><span class="p">))</span>

        <span class="c1"># Applying the window to the data for the causality enforcement</span>
        <span class="n">irf_causal_ord</span> <span class="o">=</span> <span class="n">irf_ord</span> <span class="o">*</span> <span class="n">window</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>
        <span class="n">irf_noncausal_ord</span> <span class="o">=</span> <span class="n">irf_ord</span> <span class="o">*</span> <span class="n">time_reversal_window</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

        <span class="c1"># Generating the new impulse response function array</span>
        <span class="n">irfs_causal</span> <span class="o">=</span> <span class="n">irfs</span>
        <span class="n">irfs_causal</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">irf_causal_ord</span><span class="o">+</span><span class="n">np</span><span class="o">.</span><span class="n">flip</span><span class="p">(</span><span class="n">irf_noncausal_ord</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">irfs_causal</span></div></div>


<div class="viewcode-block" id="TransmissibilityArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.TransmissibilityArray.html#sdynpy.core.sdynpy_data.TransmissibilityArray">[docs]</a><span class="k">class</span> <span class="nc">TransmissibilityArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store transmissibility data&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;complex128&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TRANSMISIBILITY</span></div>
<span class="c1"># def transmisibility_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="CoherenceArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CoherenceArray.html#sdynpy.core.sdynpy_data.CoherenceArray">[docs]</a><span class="k">class</span> <span class="nc">CoherenceArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store coherence data&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span>

<div class="viewcode-block" id="CoherenceArray.from_time_data"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CoherenceArray.html#sdynpy.core.sdynpy_data.CoherenceArray.from_time_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_time_data</span><span class="p">(</span><span class="n">response_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span><span class="p">,</span>
                       <span class="n">samples_per_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.0</span><span class="p">,)),</span>
                       <span class="n">reference_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes coherence from reference and response time histories</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        response_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as responses</span>
<span class="sd">        samples_per_average : int, optional</span>
<span class="sd">            Number of samples used to split up the signals into averages.  The</span>
<span class="sd">            default is None, meaning the data is treated as a single measurement</span>
<span class="sd">            frame.</span>
<span class="sd">        overlap : float, optional</span>
<span class="sd">            The overlap as a fraction of the frame (e.g. 0.5 specifies 50% overlap).</span>
<span class="sd">            The default is 0.0, meaning no overlap is used.</span>
<span class="sd">        window : np.ndarray or str, optional</span>
<span class="sd">            A 1D ndarray with length samples_per_average that specifies the</span>
<span class="sd">            coefficients of the window.  A Hann window is applied if not specified.</span>
<span class="sd">            If a string is specified, then the window will be obtained from scipy.</span>
<span class="sd">        reference_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as reference.  If not specified, the response</span>
<span class="sd">            data will be used as references, resulting in a square coherence matrix.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if reference and response functions do not have consistent</span>
<span class="sd">            abscissa</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            A PSD array computed from the specified reference and</span>
<span class="sd">            response signals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reference_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_data</span> <span class="o">=</span> <span class="n">response_data</span>
        <span class="n">ref_data</span> <span class="o">=</span> <span class="n">reference_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">res_data</span> <span class="o">=</span> <span class="n">response_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ref_ord</span> <span class="o">=</span> <span class="n">ref_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">res_ord</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                           <span class="n">res_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">))</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span><span class="n">res_data</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reference and Response Data should have identical abscissa!&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">abscissa_spacing</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">cpsd</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">res_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                           <span class="n">window</span><span class="p">,</span> <span class="n">reference_signals</span> <span class="o">=</span> <span class="n">ref_ord</span><span class="p">)</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">res_asds</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">res_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                           <span class="n">window</span><span class="p">,</span> <span class="n">only_asds</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">ref_asds</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">ref_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                               <span class="n">window</span><span class="p">,</span> <span class="n">only_asds</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">cpsd</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">res_asds</span><span class="p">[</span><span class="o">...</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">ref_asds</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,:]</span>
        <span class="n">den</span><span class="p">[</span><span class="n">den</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Set to 1 if denominator is zero</span>
        <span class="n">coh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">cpsd</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">df</span>
        <span class="c1"># Now construct the transfer function array</span>
        <span class="n">coordinate</span> <span class="o">=</span> <span class="n">outer_product</span><span class="p">(</span><span class="n">res_data</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span>
                                   <span class="n">ref_data</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span><span class="p">,</span>
                          <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">coh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">coordinate</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="MultipleCoherenceArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.MultipleCoherenceArray.html#sdynpy.core.sdynpy_data.MultipleCoherenceArray">[docs]</a><span class="k">class</span> <span class="nc">MultipleCoherenceArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store coherence data&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MULTIPLE_COHERENCE</span>
    
<div class="viewcode-block" id="MultipleCoherenceArray.from_time_data"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.MultipleCoherenceArray.html#sdynpy.core.sdynpy_data.MultipleCoherenceArray.from_time_data">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">from_time_data</span><span class="p">(</span><span class="n">response_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span><span class="p">,</span>
                       <span class="n">samples_per_average</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">overlap</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
                       <span class="n">window</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="mf">1.0</span><span class="p">,)),</span>
                       <span class="n">reference_data</span><span class="p">:</span> <span class="n">TimeHistoryArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes coherence from reference and response time histories</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        response_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as responses</span>
<span class="sd">        samples_per_average : int, optional</span>
<span class="sd">            Number of samples used to split up the signals into averages.  The</span>
<span class="sd">            default is None, meaning the data is treated as a single measurement</span>
<span class="sd">            frame.</span>
<span class="sd">        overlap : float, optional</span>
<span class="sd">            The overlap as a fraction of the frame (e.g. 0.5 specifies 50% overlap).</span>
<span class="sd">            The default is 0.0, meaning no overlap is used.</span>
<span class="sd">        window : np.ndarray or str, optional</span>
<span class="sd">            A 1D ndarray with length samples_per_average that specifies the</span>
<span class="sd">            coefficients of the window.  A Hann window is applied if not specified.</span>
<span class="sd">            If a string is specified, then the window will be obtained from scipy.</span>
<span class="sd">        reference_data : TimeHistoryArray</span>
<span class="sd">            Time data to be used as reference.  If not specified, the response</span>
<span class="sd">            data will be used as references, resulting in a square coherence matrix.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            Raised if reference and response functions do not have consistent</span>
<span class="sd">            abscissa</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        PowerSpectralDensityArray</span>
<span class="sd">            A PSD array computed from the specified reference and</span>
<span class="sd">            response signals.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reference_data</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">reference_data</span> <span class="o">=</span> <span class="n">response_data</span>
        <span class="n">ref_data</span> <span class="o">=</span> <span class="n">reference_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">res_data</span> <span class="o">=</span> <span class="n">response_data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">ref_ord</span> <span class="o">=</span> <span class="n">ref_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="n">res_ord</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">ordinate</span>
        <span class="k">if</span> <span class="p">((</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span>
                           <span class="n">res_data</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span><span class="p">))</span>
            <span class="ow">or</span> <span class="p">(</span><span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ref_data</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">,</span><span class="n">res_data</span><span class="o">.</span><span class="n">abscissa_spacing</span><span class="p">))):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Reference and Response Data should have identical abscissa!&#39;</span><span class="p">)</span>
        <span class="n">dt</span> <span class="o">=</span> <span class="n">res_data</span><span class="o">.</span><span class="n">abscissa_spacing</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">cross_cpsd</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">res_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                           <span class="n">window</span><span class="p">,</span> <span class="n">reference_signals</span> <span class="o">=</span> <span class="n">ref_ord</span><span class="p">)</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">res_apsd</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">res_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                              <span class="n">window</span><span class="p">,</span><span class="n">only_asds</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">df</span><span class="p">,</span> <span class="n">ref_cpsd</span> <span class="o">=</span> <span class="n">sp_cpsd</span><span class="p">(</span><span class="n">ref_ord</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">dt</span><span class="p">,</span> <span class="n">samples_per_average</span><span class="p">,</span> <span class="n">overlap</span><span class="p">,</span>
                               <span class="n">window</span><span class="p">)</span>
        
        <span class="n">num</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">einsum</span><span class="p">(</span><span class="s1">&#39;fij,fji-&gt;fi&#39;</span><span class="p">,</span> <span class="n">cross_cpsd</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">solve</span><span class="p">(</span><span class="n">ref_cpsd</span><span class="p">,</span><span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">cross_cpsd</span><span class="o">.</span><span class="n">conj</span><span class="p">(),</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span><span class="o">-</span><span class="mi">1</span><span class="p">)))</span>
        <span class="n">den</span> <span class="o">=</span> <span class="n">res_apsd</span>
        <span class="n">den</span><span class="p">[</span><span class="n">den</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>  <span class="c1"># Set to 1 if denominator is zero</span>
        <span class="n">mcoh</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">num</span><span class="o">/</span><span class="n">den</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">num</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">*</span><span class="n">df</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MULTIPLE_COHERENCE</span><span class="p">,</span>
                          <span class="n">freq</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">mcoh</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="n">res_data</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span></div></div>

<span class="c1"># def coherence_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="CorrelationArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CorrelationArray.html#sdynpy.core.sdynpy_data.CorrelationArray">[docs]</a><span class="k">class</span> <span class="nc">CorrelationArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Data array used to store correlation data&quot;&quot;&quot;</span>
    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSCORRELATION</span></div>

<span class="c1"># def correlation_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<div class="viewcode-block" id="ModeIndicatorFunctionArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ModeIndicatorFunctionArray.html#sdynpy.core.sdynpy_data.ModeIndicatorFunctionArray">[docs]</a><span class="k">class</span> <span class="nc">ModeIndicatorFunctionArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Mode indicator function (CMIF, NMIF, or NMIF)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MODE_INDICATOR_FUNCTION</span></div>


<div class="viewcode-block" id="ShockResponseSpectrumArray"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ShockResponseSpectrumArray.html#sdynpy.core.sdynpy_data.ShockResponseSpectrumArray">[docs]</a><span class="k">class</span> <span class="nc">ShockResponseSpectrumArray</span><span class="p">(</span><span class="n">NDDataArray</span><span class="p">):</span>

    <span class="n">_srs_type_map</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;ppaa&#39;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;pnaa&#39;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                     <span class="s1">&#39;pmaa&#39;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                     <span class="s1">&#39;rpaa&#39;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                     <span class="s1">&#39;rnaa&#39;</span><span class="p">:</span> <span class="mi">5</span><span class="p">,</span>
                     <span class="s1">&#39;rmaa&#39;</span><span class="p">:</span> <span class="mi">6</span><span class="p">,</span>
                     <span class="s1">&#39;mpaa&#39;</span><span class="p">:</span> <span class="mi">7</span><span class="p">,</span>
                     <span class="s1">&#39;mnaa&#39;</span><span class="p">:</span> <span class="mi">8</span><span class="p">,</span>
                     <span class="s1">&#39;mmaa&#39;</span><span class="p">:</span> <span class="mi">9</span><span class="p">,</span>
                     <span class="s1">&#39;alaa&#39;</span><span class="p">:</span> <span class="mi">10</span><span class="p">,</span>
                     <span class="s1">&#39;pprd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                     <span class="s1">&#39;pnrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                     <span class="s1">&#39;pmrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
                     <span class="s1">&#39;rprd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>
                     <span class="s1">&#39;rnrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">5</span><span class="p">,</span>
                     <span class="s1">&#39;rmrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">6</span><span class="p">,</span>
                     <span class="s1">&#39;mprd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">7</span><span class="p">,</span>
                     <span class="s1">&#39;mnrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">8</span><span class="p">,</span>
                     <span class="s1">&#39;mmrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">9</span><span class="p">,</span>
                     <span class="s1">&#39;alrd&#39;</span><span class="p">:</span> <span class="o">-</span><span class="mi">10</span><span class="p">}</span>

<span class="w">    </span><span class="sd">&quot;&quot;&quot;Shock Response Spectrum (SRS)&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">nelements</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">function_type</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the function type of the data array</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SHOCK_RESPONSE_SPECTRUM</span>

<div class="viewcode-block" id="ShockResponseSpectrumArray.sum_decayed_sines"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ShockResponseSpectrumArray.html#sdynpy.core.sdynpy_data.ShockResponseSpectrumArray.sum_decayed_sines">[docs]</a>    <span class="k">def</span> <span class="nf">sum_decayed_sines</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span>
                          <span class="n">sine_frequencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sine_tone_range</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sine_tone_per_octave</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">sine_amplitudes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sine_decays</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sine_delays</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">srs_damping</span><span class="o">=</span><span class="mf">0.03</span><span class="p">,</span> <span class="n">srs_type</span><span class="o">=</span><span class="s2">&quot;MMAA&quot;</span><span class="p">,</span>
                          <span class="n">compensation_frequency</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">compensation_decay</span><span class="o">=</span><span class="mf">0.95</span><span class="p">,</span>
                          <span class="c1"># Paramters for the iteration</span>
                          <span class="n">number_of_iterations</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">convergence</span><span class="o">=</span><span class="mf">0.8</span><span class="p">,</span>
                          <span class="n">error_tolerance</span><span class="o">=</span><span class="mf">0.05</span><span class="p">,</span>
                          <span class="n">tau</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">num_time_constants</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decay_resolution</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">scale_factor</span><span class="o">=</span><span class="mf">1.02</span><span class="p">,</span>
                          <span class="n">acceleration_factor</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
                          <span class="n">plot_results</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">srs_frequencies</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                          <span class="n">return_velocity</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_displacement</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">return_srs</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">return_sine_table</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                          <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a Sum of Decayed Sines signal given an SRS.</span>

<span class="sd">        Note that there are many approaches to do this, with many optional arguments</span>
<span class="sd">        so please read the documentation carefully to understand which arguments</span>
<span class="sd">        must be passed to the function.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sample_rate : float</span>
<span class="sd">            The sample rate of the generated signal.</span>
<span class="sd">        block_size : int</span>
<span class="sd">            The number of samples in the generated signal.</span>
<span class="sd">        sine_frequencies : np.ndarray, optional</span>
<span class="sd">            The frequencies of the sine tones.  If this argument is not specified</span>
<span class="sd">            and the `sine_tone_range` argument is not specified, then the</span>
<span class="sd">            `sine_tone_range` will be set to the maximum and minimum abscissa</span>
<span class="sd">            value for this `ShockResponseSpectrumArray`.</span>
<span class="sd">        sine_tone_range : np.ndarray, optional</span>
<span class="sd">            A length-2 array containing the minimum and maximum sine tone to</span>
<span class="sd">            generate.  If this argument is not specified</span>
<span class="sd">            and the `sine_frequencies` argument is not specified, then the</span>
<span class="sd">            `sine_tone_range` will be set to the maximum and minimum abscissa</span>
<span class="sd">            value for this `ShockResponseSpectrumArray`.</span>
<span class="sd">        sine_tone_per_octave : int, optional</span>
<span class="sd">            The number of sine tones per octave. If not specified along with</span>
<span class="sd">            `sine_tone_range`, then a default value of 4 will be used if the</span>
<span class="sd">            `srs_damping` is &gt;= 0.05.  Otherwise, the formula of</span>
<span class="sd">            `sine_tone_per_octave = 9 - srs_damping*100` will be used.</span>
<span class="sd">        sine_amplitudes : np.ndarray, optional</span>
<span class="sd">            The initial amplitude of the sine tones used in the optimization.  If</span>
<span class="sd">            not specified, they will be set to the value of the SRS at each frequency</span>
<span class="sd">            divided by the quality factor of the SRS.</span>
<span class="sd">        sine_decays : np.ndarray, optional</span>
<span class="sd">            An array of decay value time constants (often represented by variable</span>
<span class="sd">            tau).  Tau is the time for the amplitude of motion to decay 63% defined</span>
<span class="sd">            by the equation `1/(2*np.pi*freq*zeta)` where `freq` is the frequency</span>
<span class="sd">            of the sine tone and `zeta` is the fraction of critical damping.</span>
<span class="sd">            If not specified, then either the `tau` or `num_time_constants`</span>
<span class="sd">            arguments must be specified instead.</span>
<span class="sd">        sine_delays : np.ndarray, optional</span>
<span class="sd">            An array of delay values for the sine components. If not specified,</span>
<span class="sd">            all tones will have zero delay.</span>
<span class="sd">        srs_damping : float, optional</span>
<span class="sd">            Fraction of critical damping to use in the SRS calculation (e.g. you</span>
<span class="sd">            should specify 0.03 to represent 3%, not 3). If not defined, a</span>
<span class="sd">            default of 0.03 will be used.</span>
<span class="sd">        srs_type : int or str</span>
<span class="sd">            The type of spectrum desired: This can be an integer or a string.</span>
<span class="sd">            If `srs_type` is an integer:</span>
<span class="sd">            if `srs_type` &gt; 0 (pos) then the SRS will be a base</span>
<span class="sd">            acceleration-absolute acceleration model</span>
<span class="sd">            If `srs_type` &lt; 0 (neg) then the SRS will be a base acceleration-relative</span>
<span class="sd">            displacement model (expressed in equivalent static acceleration units).</span>
<span class="sd">            If abs(`srs_type`) is:</span>
<span class="sd">                1--positive primary,  2--negative primary,  3--absolute maximum primary</span>
<span class="sd">                4--positive residual, 5--negative residual, 6--absolute maximum residual</span>
<span class="sd">                7--largest of 1&amp;4, maximum positive, 8--largest of 2&amp;5, maximum negative</span>
<span class="sd">                9 -- maximax, the largest absolute value of 1-8</span>
<span class="sd">               10 -- returns a matrix s(9,length(fn)) with all the types 1-9.</span>
<span class="sd">        compensation_frequency : float</span>
<span class="sd">            The frequency of the compensation pulse.  If not specified, it will be</span>
<span class="sd">            set to 1/3 of the lowest sine tone</span>
<span class="sd">        compensation_decay : float</span>
<span class="sd">            The decay value for the compensation pulse.  If not specified, it will</span>
<span class="sd">            be set to 0.95.</span>
<span class="sd">        number_of_iterations : int, optional</span>
<span class="sd">            The number of iterations to perform. At least two iterations should be</span>
<span class="sd">            performed.  3 iterations is preferred, and will be used if this argument</span>
<span class="sd">            is not specified.</span>
<span class="sd">        convergence : float, optional</span>
<span class="sd">            The fraction of the error corrected each iteration. The default is 0.8.</span>
<span class="sd">        error_tolerance : float, optional</span>
<span class="sd">            Allowable relative error in the SRS. The default is 0.05.</span>
<span class="sd">        tau : float, optional</span>
<span class="sd">            If a floating point number is passed, then this will be used for the</span>
<span class="sd">            `sine_decay` values.  Alternatively, a dictionary can be passed with</span>
<span class="sd">            the keys containing a length-2 tuple specifying the minimum and maximum</span>
<span class="sd">            frequency range, and the value specifying the value of `tau` within that</span>
<span class="sd">            frequency range.  If this latter approach is used, all `sine_frequencies`</span>
<span class="sd">            must be contained within a frequency range. If this argument is not</span>
<span class="sd">            specified, then either `sine_decays` or `num_time_constants` must be</span>
<span class="sd">            specified instead.</span>
<span class="sd">        num_time_constants : int, optional</span>
<span class="sd">            If an integer is passed, then this will be used to set the `sine_decay`</span>
<span class="sd">            values by ensuring the specified number of time constants occur in the</span>
<span class="sd">            `block_size`.  Alternatively, a dictionary can be passed with the keys</span>
<span class="sd">            containing a length-2 tuple specifying the minimum and maximum</span>
<span class="sd">            frequency range, and the value specifying the value of</span>
<span class="sd">            `num_time_constants` over that frequency range. If this latter approach</span>
<span class="sd">            is used, all `sine_frequencies` must be contained within a frequency</span>
<span class="sd">            range. If this argument is not specified, then either `sine_decays` or</span>
<span class="sd">            `tau` must be specified instead.</span>
<span class="sd">        decay_resolution : float, optional</span>
<span class="sd">            A scalar identifying the resolution of the fractional decay rate</span>
<span class="sd">            (often known by the variable `zeta`).  The decay parameters will be</span>
<span class="sd">            rounded to this value.  The default is to not round.</span>
<span class="sd">        scale_factor : float, optional</span>
<span class="sd">            A scaling applied to the sine tone amplitudes so the achieved SRS better</span>
<span class="sd">            fits the specified SRS, rather than just touching it. The default is 1.02.</span>
<span class="sd">        acceleration_factor : float, optional</span>
<span class="sd">            Optional scale factor to convert acceleration into velocity and</span>
<span class="sd">            displacement.  For example, if sine amplitudes are in G and displacement</span>
<span class="sd">            is desired in inches, the acceleration factor should be set to 386.089.</span>
<span class="sd">            If sine amplitudes are in G and displacement is desired in meters, the</span>
<span class="sd">            acceleration factor should be set to 9.80665.  The default is 1, which</span>
<span class="sd">            assumes consistent units (e.g. acceleration in m/s^2, velocity in m/s,</span>
<span class="sd">            displacement in m).</span>
<span class="sd">        plot_results : bool, optional</span>
<span class="sd">            If True, a figure will be plotted showing the acceleration, velocity,</span>
<span class="sd">            and displacement signals, as well as the desired and achieved SRS.</span>
<span class="sd">        srs_frequencies : np.ndarray, optional</span>
<span class="sd">            If specified, these frequencies will be used to compute the SRS that</span>
<span class="sd">            will be plotted when the `plot_results` value is `True`.</span>
<span class="sd">        return_velocity : bool, optional</span>
<span class="sd">            If specified, a velocity signal will also be returned.  Default is</span>
<span class="sd">            False</span>
<span class="sd">        return_displacement : bool, optional</span>
<span class="sd">            If True, a displacement signal will also be returned.  Default is</span>
<span class="sd">            False</span>
<span class="sd">        return_srs : bool, optional</span>
<span class="sd">            If True, the SRS of the generated signal will also be returned</span>
<span class="sd">        return_sine_table : bool, optional</span>
<span class="sd">            If True, a sine table will also be returned</span>
<span class="sd">        verbose : True, optional</span>
<span class="sd">            If True, additional diagnostics will be printed to the console.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        acceleration : TimeHistoryArray</span>
<span class="sd">            A TimeHistoryArray object containing an acceleration response that</span>
<span class="sd">            satisfies the SRS</span>
<span class="sd">        velocity : TimeHistoryArray</span>
<span class="sd">            A TimeHistoryArray object containing the velocity corresponding to</span>
<span class="sd">            `acceleration`.  Only returned if `return_velocity` is True.</span>
<span class="sd">        displacement : TimeHistoryArray</span>
<span class="sd">            A TimeHistoryArray object containing the displacement corresponding</span>
<span class="sd">            to `acceleration`.  Only returned if `return_displacement` is True.</span>
<span class="sd">        srs : TimeHistoryArray</span>
<span class="sd">            A `ShockResponseSpectrumArray` containing the SRS of `acceleration`.</span>
<span class="sd">            This can be used to check against the original signal to identify</span>
<span class="sd">            how good the match is.  Only returned if `return_srs` is True.</span>
<span class="sd">        sine_table : DecayedSineTable</span>
<span class="sd">            A `DecayedSineTable` object containing the frequency, amplitude,</span>
<span class="sd">            delay, and decay parameters that are used to generate `acceleration`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">srs_type</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">srs_type</span> <span class="o">=</span> <span class="n">ShockResponseSpectrumArray</span><span class="o">.</span><span class="n">_srs_type_map</span><span class="p">[</span><span class="n">srs_type</span><span class="o">.</span><span class="n">lower</span><span class="p">()]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid `srs_type` specified, should be one of </span><span class="si">{:}</span><span class="s1"> (case insensitive)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="p">[</span><span class="n">k</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ShockResponseSpectrumArray</span><span class="o">.</span><span class="n">_srs_type_map</span><span class="p">]))</span>

        <span class="n">acceleration</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">block_size</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">return_displacement</span><span class="p">:</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">block_size</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">return_velocity</span><span class="p">:</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">block_size</span><span class="p">,))</span>
        <span class="k">if</span> <span class="n">return_srs</span><span class="p">:</span>
            <span class="n">srs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="n">return_sine_table</span><span class="p">:</span>
            <span class="n">sine_table</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">srs_fn</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>

            <span class="k">if</span> <span class="n">sine_frequencies</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sine_tone_range</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">this_sine_tone_range</span> <span class="o">=</span> <span class="p">[</span><span class="n">srs_fn</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">srs_fn</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">max</span><span class="p">()]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">this_sine_tone_range</span> <span class="o">=</span> <span class="n">sine_tone_range</span>

            <span class="n">srs_breakpoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">((</span><span class="n">srs_fn</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">srs_fn</span><span class="o">.</span><span class="n">ordinate</span><span class="p">))</span><span class="o">.</span><span class="n">T</span>

            <span class="p">(</span><span class="n">acceleration_signal</span><span class="p">,</span> <span class="n">velocity_signal</span><span class="p">,</span> <span class="n">displacement_signal</span><span class="p">,</span>
             <span class="n">all_frequencies</span><span class="p">,</span> <span class="n">all_amplitudes</span><span class="p">,</span> <span class="n">all_decays</span><span class="p">,</span> <span class="n">all_delays</span><span class="p">,</span>
             <span class="o">*</span><span class="n">plot_stuff</span><span class="p">)</span> <span class="o">=</span> <span class="n">sp_sds</span><span class="p">(</span>
                 <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">sine_frequencies</span><span class="p">,</span>
                 <span class="n">this_sine_tone_range</span><span class="p">,</span> <span class="n">sine_tone_per_octave</span><span class="p">,</span> <span class="n">sine_amplitudes</span><span class="p">,</span>
                 <span class="n">sine_decays</span><span class="p">,</span> <span class="n">sine_delays</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">srs_breakpoints</span><span class="p">,</span>
                 <span class="n">srs_damping</span><span class="p">,</span> <span class="n">srs_type</span><span class="p">,</span> <span class="n">compensation_frequency</span><span class="p">,</span>
                 <span class="n">compensation_decay</span><span class="p">,</span> <span class="n">number_of_iterations</span><span class="p">,</span> <span class="n">convergence</span><span class="p">,</span>
                 <span class="n">error_tolerance</span><span class="p">,</span> <span class="n">tau</span><span class="p">,</span> <span class="n">num_time_constants</span><span class="p">,</span> <span class="n">decay_resolution</span><span class="p">,</span>
                 <span class="n">scale_factor</span><span class="p">,</span> <span class="n">acceleration_factor</span><span class="p">,</span> <span class="n">plot_results</span><span class="p">,</span>
                 <span class="n">srs_frequencies</span><span class="p">,</span> <span class="n">verbose</span><span class="p">)</span>

            <span class="n">acceleration</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">acceleration_signal</span>
            <span class="k">if</span> <span class="n">return_displacement</span><span class="p">:</span>
                <span class="n">displacement</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">displacement_signal</span>
            <span class="k">if</span> <span class="n">return_velocity</span><span class="p">:</span>
                <span class="n">velocity</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">velocity_signal</span>
            <span class="k">if</span> <span class="n">return_srs</span><span class="p">:</span>
                <span class="c1"># Compute the SRS</span>
                <span class="k">if</span> <span class="n">srs_frequencies</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">this_srs_frequencies</span> <span class="o">=</span> <span class="n">all_frequencies</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">this_srs_frequencies</span> <span class="o">=</span> <span class="n">srs_frequencies</span>
                <span class="n">this_srs</span><span class="p">,</span> <span class="n">freq</span> <span class="o">=</span> <span class="n">sp_srs</span><span class="p">(</span><span class="n">acceleration_signal</span><span class="p">,</span> <span class="mi">1</span><span class="o">/</span><span class="n">sample_rate</span><span class="p">,</span>
                                        <span class="n">this_srs_frequencies</span><span class="p">,</span> <span class="n">srs_damping</span><span class="p">,</span> <span class="n">srs_type</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">srs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">srs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">this_srs</span><span class="o">.</span><span class="n">size</span><span class="p">,))</span>
                <span class="n">srs</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">this_srs</span>
            <span class="k">if</span> <span class="n">return_sine_table</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sine_table</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">sine_table</span> <span class="o">=</span> <span class="n">DecayedSineTable</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">all_frequencies</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
                <span class="n">sine_table</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">decayed_sine_table</span><span class="p">(</span><span class="n">all_frequencies</span><span class="p">,</span> <span class="n">all_amplitudes</span><span class="p">,</span> <span class="n">all_decays</span><span class="p">,</span> <span class="n">all_delays</span><span class="p">,</span> <span class="n">srs_fn</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span>

        <span class="c1"># Now convert to objects</span>
        <span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
        <span class="n">acceleration</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">times</span><span class="p">,</span> <span class="n">acceleration</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span>
        <span class="n">return_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">acceleration</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">return_velocity</span><span class="p">:</span>
            <span class="n">velocity</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                  <span class="n">times</span><span class="p">,</span> <span class="n">displacement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span>
            <span class="n">return_values</span> <span class="o">+=</span> <span class="p">(</span><span class="n">velocity</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">return_displacement</span><span class="p">:</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                                      <span class="n">times</span><span class="p">,</span> <span class="n">displacement</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
                                      <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span>
            <span class="n">return_values</span> <span class="o">+=</span> <span class="p">(</span><span class="n">displacement</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">return_srs</span><span class="p">:</span>
            <span class="n">srs</span> <span class="o">=</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SHOCK_RESPONSE_SPECTRUM</span><span class="p">,</span>
                             <span class="n">this_srs_frequencies</span><span class="p">,</span> <span class="n">srs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span>
            <span class="n">return_values</span> <span class="o">+=</span> <span class="p">(</span><span class="n">srs</span><span class="p">,)</span>
        <span class="k">if</span> <span class="n">return_sine_table</span><span class="p">:</span>
            <span class="n">return_values</span> <span class="o">+=</span> <span class="p">(</span><span class="n">sine_table</span><span class="p">,)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_values</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">return_values</span> <span class="o">=</span> <span class="n">return_values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">return_values</span></div>

<div class="viewcode-block" id="ShockResponseSpectrumArray.plot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ShockResponseSpectrumArray.html#sdynpy.core.sdynpy_data.ShockResponseSpectrumArray.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">one_axis</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">subplots_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
             <span class="n">plot_kwargs</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span> <span class="n">abscissa_markers</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
             <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">abscissa_marker_type</span> <span class="o">=</span> <span class="s1">&#39;vline&#39;</span><span class="p">,</span>
             <span class="n">abscissa_marker_plot_kwargs</span> <span class="o">=</span> <span class="p">{}):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Plot the shock response spectrum</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        one_axis : bool, optional</span>
<span class="sd">            Set to True to plot all data on one axis.  Set to False to plot</span>
<span class="sd">            data on multiple subplots.  one_axis can also be set to a</span>
<span class="sd">            matplotlib axis to plot data on an existing axis.  The default is</span>
<span class="sd">            True.</span>
<span class="sd">        subplots_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib subplots function to create the</span>
<span class="sd">            figure and axes. The default is {}.</span>
<span class="sd">        plot_kwargs : dict, optional</span>
<span class="sd">            Keywords passed to the matplotlib plot function. The default is {}.</span>
<span class="sd">        abscissa_markers : ndarray, optional</span>
<span class="sd">            Array containing abscissa values to mark on the plot to denote</span>
<span class="sd">            significant events.</span>
<span class="sd">        abscissa_marker_labels : str or ndarray</span>
<span class="sd">            Array of strings to label the abscissa_markers with, or</span>
<span class="sd">            alternatively a format string that accepts index and abscissa</span>
<span class="sd">            inputs (e.g. &#39;{index:}: {abscissa:0.2f}&#39;).  By default no label</span>
<span class="sd">            will be applied.</span>
<span class="sd">        abscissa_marker_type : str</span>
<span class="sd">            The type of marker to use.  This can either be the string &#39;vline&#39;</span>
<span class="sd">            or a valid matplotlib symbol specifier (e.g. &#39;o&#39;, &#39;x&#39;, &#39;.&#39;).</span>
<span class="sd">        abscissa_marker_plot_kwargs : dict</span>
<span class="sd">            Additional keyword arguments used when plotting the abscissa label</span>
<span class="sd">            markers.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        axis : matplotlib axis or array of axes</span>
<span class="sd">             On which the data were plotted</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">abscissa_marker_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;&#39;</span> <span class="k">for</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">abscissa_markers</span><span class="p">]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                <span class="n">abscissa_marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">abscissa_marker_labels</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">,</span> <span class="n">abscissa</span> <span class="o">=</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">v</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">)]</span>
                
        <span class="k">if</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="n">axis</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">one_axis</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span><span class="p">)))</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">size</span> <span class="o">/</span> <span class="n">ncols</span><span class="p">))</span>
            <span class="n">figure</span><span class="p">,</span> <span class="n">axis</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">,</span> <span class="o">**</span><span class="n">subplots_kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">function</span><span class="p">))</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">())):</span>
                <span class="n">lines</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">function</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">function</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;/&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">function</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">()]))</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_xscale</span><span class="p">(</span><span class="s1">&#39;log&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                        <span class="n">ax</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                            <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                            <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                            <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                            <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                            <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                            <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                                <span class="n">ax</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:]:</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">remove</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">one_axis</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="o">**</span><span class="n">plot_kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">abscissa_markers</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">abscissa_marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                    <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="s1">&#39;k&#39;</span><span class="p">}</span>
                    <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">abscissa_marker_labels</span><span class="p">):</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">axvline</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span> <span class="o">=</span> <span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">axis</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">rotation</span> <span class="o">=</span> <span class="mi">90</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span><span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span><span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span><span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
                    <span class="n">axis</span><span class="o">.</span><span class="n">callbacks</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="s1">&#39;ylim_changed&#39;</span><span class="p">,</span><span class="n">_update_annotations_to_axes_bottom</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">:</span>
                        <span class="n">x</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_xdata</span><span class="p">()</span>
                        <span class="n">y</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">get_ydata</span><span class="p">()</span>
                        <span class="n">marker_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;color&#39;</span><span class="p">:</span><span class="n">line</span><span class="o">.</span><span class="n">get_color</span><span class="p">(),</span><span class="s1">&#39;marker&#39;</span><span class="p">:</span><span class="n">abscissa_marker_type</span><span class="p">,</span><span class="s1">&#39;linewidth&#39;</span><span class="p">:</span><span class="mi">0</span><span class="p">}</span>
                        <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">abscissa_marker_plot_kwargs</span><span class="p">)</span>
                        <span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">,</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">label</span><span class="p">,</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">abscissa_marker_labels</span><span class="p">,</span><span class="n">abscissa_markers</span><span class="p">,</span><span class="n">marker_y</span><span class="p">):</span>
                            <span class="n">axis</span><span class="o">.</span><span class="n">annotate</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">xy</span><span class="o">=</span><span class="p">(</span><span class="n">mx</span><span class="p">,</span><span class="n">my</span><span class="p">),</span> <span class="n">textcoords</span><span class="o">=</span><span class="s1">&#39;offset pixels&#39;</span><span class="p">,</span> <span class="n">xytext</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mi">4</span><span class="p">),</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;left&#39;</span><span class="p">,</span> <span class="n">va</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">axis</span></div></div>

<span class="c1"># def mode_indicator_function_array(abscissa,ordinate,coordinate,comment1=&#39;&#39;,comment2=&#39;&#39;,comment3=&#39;&#39;,comment4=&#39;&#39;,comment5=&#39;&#39;):</span>
<span class="c1">#     pass</span>


<span class="n">_function_type_class_map</span> <span class="o">=</span> <span class="p">{</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">:</span> <span class="n">NDDataArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">:</span> <span class="n">TimeHistoryArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOSPECTRUM</span><span class="p">:</span> <span class="n">PowerSpectrumArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSSPECTRUM</span><span class="p">:</span> <span class="n">PowerSpectrumArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">:</span> <span class="n">TransferFunctionArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TRANSMISIBILITY</span><span class="p">:</span> <span class="n">TransmissibilityArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span><span class="p">:</span> <span class="n">CoherenceArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOCORRELATION</span><span class="p">:</span> <span class="n">CorrelationArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSCORRELATION</span><span class="p">:</span> <span class="n">CorrelationArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">:</span> <span class="n">PowerSpectralDensityArray</span><span class="p">,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">ENERGY_SPECTRAL_DENSITY</span><span class="p">:</span> <span class="n">PowerSpectralDensityArray</span><span class="p">,</span>
                            <span class="c1"># FunctionTypes.PROBABILITY_DENSITY_FUNCTION, : ,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SPECTRUM</span><span class="p">:</span> <span class="n">SpectrumArray</span><span class="p">,</span>
                            <span class="c1"># FunctionTypes.CUMULATIVE_FREQUENCY_DISTRIBUTION, : ,</span>
                            <span class="c1"># FunctionTypes.PEAKS_VALLEY, : ,</span>
                            <span class="c1"># FunctionTypes.STRESS_PER_CYCLE, : ,</span>
                            <span class="c1"># FunctionTypes.STRAIN_PER_CYCLE, : ,</span>
                            <span class="c1"># FunctionTypes.ORBIT, : ,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MODE_INDICATOR_FUNCTION</span><span class="p">:</span> <span class="n">ModeIndicatorFunctionArray</span><span class="p">,</span>
                            <span class="c1"># FunctionTypes.FORCE_PATTERN, : ,</span>
                            <span class="c1"># FunctionTypes.PARTIAL_POWER, : ,</span>
                            <span class="c1"># FunctionTypes.PARTIAL_COHERENCE, : ,</span>
                            <span class="c1"># FunctionTypes.EIGENVALUE, : ,</span>
                            <span class="c1"># FunctionTypes.EIGENVECTOR, : ,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SHOCK_RESPONSE_SPECTRUM</span><span class="p">:</span> <span class="n">ShockResponseSpectrumArray</span><span class="p">,</span>
                            <span class="c1"># FunctionTypes.FINITE_IMPULSE_RESPONSE_FILTER, : ,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MULTIPLE_COHERENCE</span><span class="p">:</span> <span class="n">MultipleCoherenceArray</span><span class="p">,</span>
                            <span class="c1"># FunctionTypes.ORDER_FUNCTION, : ,</span>
                            <span class="c1"># FunctionTypes.PHASE_COMPENSATION,  : ,</span>
                            <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">IMPULSE_RESPONSE_FUNCTION</span><span class="p">:</span> <span class="n">ImpulseResponseFunctionArray</span><span class="p">,</span>
                            <span class="p">}</span>


<div class="viewcode-block" id="data_array"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.data_array.html#sdynpy.core.sdynpy_data.data_array">[docs]</a><span class="k">def</span> <span class="nf">data_array</span><span class="p">(</span><span class="n">data_type</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to create a data array object.</span>

<span class="sd">    All input arguments to this function are allowed to broadcast to create the</span>
<span class="sd">    final data in the NDDataArray object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    data_type : FunctionTypes</span>
<span class="sd">        Type of data array that will be created</span>
<span class="sd">    abscissa : np.ndarray</span>
<span class="sd">        Numpy array specifying the abscissa of the function</span>
<span class="sd">    ordinate : np.ndarray</span>
<span class="sd">        Numpy array specifying the ordinate of the function</span>
<span class="sd">    coordinate : CoordinateArray</span>
<span class="sd">        Coordinate for each data in the data array</span>
<span class="sd">    comment1 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment2 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment3 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment4 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment5 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    obj : NDDataArray or subclass</span>
<span class="sd">        The constructed NDDataArray (or subclass) object</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">_function_type_class_map</span><span class="p">[</span><span class="n">data_type</span><span class="p">]</span>
    <span class="n">nelem</span> <span class="o">=</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">shape</span> <span class="o">=</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">data_type</span> <span class="ow">is</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">nelem</span><span class="p">,</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">nelem</span><span class="p">)</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">ordinate</span> <span class="o">=</span> <span class="n">ordinate</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">=</span> <span class="n">abscissa</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">comment1</span> <span class="o">=</span> <span class="n">comment1</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">comment2</span> <span class="o">=</span> <span class="n">comment2</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">comment3</span> <span class="o">=</span> <span class="n">comment3</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">comment4</span> <span class="o">=</span> <span class="n">comment4</span>
    <span class="n">obj</span><span class="o">.</span><span class="n">comment5</span> <span class="o">=</span> <span class="n">comment5</span>
    <span class="n">num_coords</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coordinate</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">obj</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">coordinate</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="p">:</span><span class="n">num_coords</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">obj</span></div>


<span class="n">from_unv</span> <span class="o">=</span> <span class="n">NDDataArray</span><span class="o">.</span><span class="n">from_unv</span>
<span class="n">from_uff</span> <span class="o">=</span> <span class="n">from_unv</span>
<span class="n">load</span> <span class="o">=</span> <span class="n">NDDataArray</span><span class="o">.</span><span class="n">load</span>


<div class="viewcode-block" id="from_imat_struct"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.from_imat_struct.html#sdynpy.core.sdynpy_data.from_imat_struct">[docs]</a><span class="k">def</span> <span class="nf">from_imat_struct</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">,</span> <span class="n">squeeze</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Constructs a NDDataArray from an imat_fn class saved to a Matlab structure</span>

<span class="sd">    In IMAT, a structure can be created from an `imat_fn` by using the get()</span>
<span class="sd">    function.  This can then be saved to a .mat file and loaded using</span>
<span class="sd">    `scipy.io.loadmat`.  The output from loadmat can be passed into this function</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    imat_fn_struct : np.ndarray</span>
<span class="sd">        structure from loadmat containing data from an imat_fn</span>
<span class="sd">    squeeze : bool, optional</span>
<span class="sd">        If True, return a single NDDataArray object or subclass if only one</span>
<span class="sd">        function type exists in the data.  Otherwise, it will return a list of</span>
<span class="sd">        length one.  If more than one function type exists, a list of</span>
<span class="sd">        NDDataArray objects will be returned regardless of the value of</span>
<span class="sd">        `squeeze`.  Default is True.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    return_functions : NDDataArray or list of NDDataArray</span>
<span class="sd">        Returns a list of NDDataArray objects if `squeeze` is false, or a single</span>
<span class="sd">        NDDataArray object if `squeeze` is True, unless there are multiple</span>
<span class="sd">        function types stored in the structure.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Get function types</span>
    <span class="n">fn_types</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;FunctionType&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="n">fn_types</span> <span class="o">=</span> <span class="n">fn_types</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">fn_types</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="c1"># Separate into the different types of functions</span>
    <span class="n">function_type_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">fn_type</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">fn_types</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
        <span class="n">fn_type_enum</span> <span class="o">=</span> <span class="n">_imat_function_type_map</span><span class="p">[</span><span class="n">fn_type</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">fn_type_enum</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">function_type_dict</span><span class="p">:</span>
            <span class="n">function_type_dict</span><span class="p">[</span><span class="n">fn_type_enum</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">function_type_dict</span><span class="p">[</span><span class="n">fn_type_enum</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
    <span class="n">return_functions</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">abscissa</span> <span class="o">=</span> <span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;Abscissa&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">abscissa</span> <span class="o">=</span> <span class="n">abscissa</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">abscissa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">ordinate</span> <span class="o">=</span> <span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;Ordinate&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ordinate</span> <span class="o">=</span> <span class="n">ordinate</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">reference_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;ReferenceCoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">reference_coords</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">reference_coords</span> <span class="o">=</span> <span class="n">reference_coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">reference_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">reference_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">reference_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">response_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;ResponseCoord&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">response_coords</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">response_coords</span> <span class="o">=</span> <span class="n">response_coords</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">response_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">response_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">response_coords</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">comment_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;IDLine1&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">comment_1</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">comment_1</span> <span class="o">=</span> <span class="n">comment_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">comment_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comment_1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">comment_1</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">comment_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;IDLine2&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">comment_2</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">comment_2</span> <span class="o">=</span> <span class="n">comment_1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">comment_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comment_2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">comment_2</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">comment_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;IDLine3&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">comment_3</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">comment_3</span> <span class="o">=</span> <span class="n">comment_3</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">comment_3</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comment_3</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">comment_3</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">comment_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">imat_fn_struct</span><span class="p">[</span><span class="s1">&#39;IDLine4&#39;</span><span class="p">][</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
    <span class="k">if</span> <span class="n">comment_4</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">comment_4</span> <span class="o">=</span> <span class="n">comment_4</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">*</span><span class="n">comment_4</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">comment_4</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">comment_4</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">comment_5</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">comment_4</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;&lt;U1&#39;</span><span class="p">)</span>
    <span class="n">all_coords</span> <span class="o">=</span> <span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
        <span class="p">(</span><span class="n">response_coords</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">],</span> <span class="n">reference_coords</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">fn_type</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="n">function_type_dict</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
        <span class="n">return_functions</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
            <span class="n">data_array</span><span class="p">(</span><span class="n">fn_type</span><span class="p">,</span> <span class="n">abscissa</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ordinate</span><span class="p">[:,</span> <span class="n">indices</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span>
                       <span class="n">all_coords</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">comment_1</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">comment_2</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span>
                       <span class="n">comment_3</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">comment_4</span><span class="p">[</span><span class="n">indices</span><span class="p">],</span> <span class="n">comment_5</span><span class="p">[</span><span class="n">indices</span><span class="p">])</span>
        <span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">return_functions</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">squeeze</span><span class="p">:</span>
        <span class="n">return_functions</span> <span class="o">=</span> <span class="n">return_functions</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">return_functions</span></div>


<div class="viewcode-block" id="DecayedSineTable"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.DecayedSineTable.html#sdynpy.core.sdynpy_data.DecayedSineTable">[docs]</a><span class="k">class</span> <span class="nc">DecayedSineTable</span><span class="p">(</span><span class="n">SdynpyArray</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Structure for storing sum-of-decayed-sines information</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">,</span> <span class="n">buffer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">strides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="c1"># Create the ndarray instance of our type, given the usual</span>
        <span class="c1"># ndarray input arguments.  This will call the standard</span>
        <span class="c1"># ndarray constructor, but return an object of our type.</span>
        <span class="c1"># It also triggers a call to __array_finalize__</span>
        <span class="n">data_dtype</span> <span class="o">=</span> <span class="p">[</span>
            <span class="p">(</span><span class="s1">&#39;frequency&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;amplitude&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;decay&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;delay&#39;</span><span class="p">,</span> <span class="s1">&#39;float64&#39;</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment1&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment2&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment3&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment4&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;comment5&#39;</span><span class="p">,</span> <span class="s1">&#39;&lt;U80&#39;</span><span class="p">),</span>
            <span class="p">(</span><span class="s1">&#39;coordinate&#39;</span><span class="p">,</span> <span class="n">CoordinateArray</span><span class="o">.</span><span class="n">data_dtype</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,)),</span>
        <span class="p">]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="nb">super</span><span class="p">(</span><span class="n">SdynpyArray</span><span class="p">,</span> <span class="n">subtype</span><span class="p">)</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">subtype</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span>
                                                  <span class="n">data_dtype</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">offset</span><span class="p">,</span> <span class="n">strides</span><span class="p">,</span> <span class="n">order</span><span class="p">)</span>
        <span class="c1"># Finally, we must return the newly created object:</span>
        <span class="k">return</span> <span class="n">obj</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="n">output</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span> <span class="ow">and</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;coordinate&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">CoordinateArray</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">output</span>

<div class="viewcode-block" id="DecayedSineTable.construct_signal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.DecayedSineTable.html#sdynpy.core.sdynpy_data.DecayedSineTable.construct_signal">[docs]</a>    <span class="k">def</span> <span class="nf">construct_signal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">):</span>
        <span class="n">output_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
        <span class="n">output_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">block_size</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">sum_decayed_sines_reconstruction</span><span class="p">(</span>
                <span class="n">table</span><span class="o">.</span><span class="n">frequency</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">decay</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">)</span>
            <span class="n">output_ordinate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">output_abscissa</span><span class="p">,</span>
                          <span class="n">output_ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="DecayedSineTable.construct_velocity"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.DecayedSineTable.html#sdynpy.core.sdynpy_data.DecayedSineTable.construct_velocity">[docs]</a>    <span class="k">def</span> <span class="nf">construct_velocity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acceleration_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">output_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
        <span class="n">output_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">block_size</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">sum_decayed_sines_displacement_velocity</span><span class="p">(</span>
                <span class="n">table</span><span class="o">.</span><span class="n">frequency</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">decay</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acceleration_factor</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">output_ordinate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">output_abscissa</span><span class="p">,</span>
                          <span class="n">output_ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div>

<div class="viewcode-block" id="DecayedSineTable.construct_displacement"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.DecayedSineTable.html#sdynpy.core.sdynpy_data.DecayedSineTable.construct_displacement">[docs]</a>    <span class="k">def</span> <span class="nf">construct_displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acceleration_factor</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">output_abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">block_size</span><span class="p">)</span><span class="o">/</span><span class="n">sample_rate</span>
        <span class="n">output_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="o">+</span><span class="p">(</span><span class="n">block_size</span><span class="p">,))</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">table</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="n">signal</span> <span class="o">=</span> <span class="n">sum_decayed_sines_displacement_velocity</span><span class="p">(</span>
                <span class="n">table</span><span class="o">.</span><span class="n">frequency</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">amplitude</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">decay</span><span class="p">,</span> <span class="n">table</span><span class="o">.</span><span class="n">delay</span><span class="p">,</span>
                <span class="n">sample_rate</span><span class="p">,</span> <span class="n">block_size</span><span class="p">,</span> <span class="n">acceleration_factor</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">output_ordinate</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">signal</span>
        <span class="k">return</span> <span class="n">data_array</span><span class="p">(</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span> <span class="n">output_abscissa</span><span class="p">,</span>
                          <span class="n">output_ordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment1</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">comment4</span><span class="p">,</span>
                          <span class="bp">self</span><span class="o">.</span><span class="n">comment5</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="decayed_sine_table"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.decayed_sine_table.html#sdynpy.core.sdynpy_data.decayed_sine_table">[docs]</a><span class="k">def</span> <span class="nf">decayed_sine_table</span><span class="p">(</span><span class="n">frequency</span><span class="p">,</span> <span class="n">amplitude</span><span class="p">,</span> <span class="n">decay</span><span class="p">,</span> <span class="n">delay</span><span class="p">,</span> <span class="n">coordinate</span><span class="p">,</span> <span class="n">comment1</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment2</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment3</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment4</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="n">comment5</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Helper function to create a DecayedSineTable object.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    frequency : np.ndarray</span>
<span class="sd">        Frequencies of the decaying sine waves</span>
<span class="sd">    amplitude : np.ndarray</span>
<span class="sd">        Amplitudes of the decaying sine waves.</span>
<span class="sd">    decay : np.ndarray</span>
<span class="sd">        Damping values of the decaying sine waves.</span>
<span class="sd">    delay : np.ndarray</span>
<span class="sd">        Delay values of the decaying sine waves.</span>
<span class="sd">    coordinate : np.ndarray</span>
<span class="sd">        Coordinate information for each of the decaying sine waves.  Must match</span>
<span class="sd">        the coordinate shape of a TimeHistoryArray, which means it must have</span>
<span class="sd">        shape (...,1)</span>
<span class="sd">    comment1 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment2 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment3 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment4 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>
<span class="sd">    comment5 : np.ndarray, optional</span>
<span class="sd">        Comment used to describe the data in the data array. The default is &#39;&#39;.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    SineTable :</span>
<span class="sd">        A SineTable object containing the specified information</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">atleast_1d</span><span class="p">(</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">coordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;`coordinate` must have shape (...,1)&#39;</span><span class="p">)</span>
    <span class="o">*</span><span class="n">shape</span><span class="p">,</span> <span class="n">num_elements</span> <span class="o">=</span> <span class="n">frequency</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">st</span> <span class="o">=</span> <span class="n">DecayedSineTable</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">num_elements</span><span class="p">)</span>
    <span class="n">st</span><span class="o">.</span><span class="n">frequency</span> <span class="o">=</span> <span class="n">frequency</span>
    <span class="n">st</span><span class="o">.</span><span class="n">amplitude</span> <span class="o">=</span> <span class="n">amplitude</span>
    <span class="n">st</span><span class="o">.</span><span class="n">decay</span> <span class="o">=</span> <span class="n">decay</span>
    <span class="n">st</span><span class="o">.</span><span class="n">delay</span> <span class="o">=</span> <span class="n">delay</span>
    <span class="n">st</span><span class="o">.</span><span class="n">coordinate</span> <span class="o">=</span> <span class="n">coordinate</span>
    <span class="n">st</span><span class="o">.</span><span class="n">comment1</span> <span class="o">=</span> <span class="n">comment1</span>
    <span class="n">st</span><span class="o">.</span><span class="n">comment2</span> <span class="o">=</span> <span class="n">comment2</span>
    <span class="n">st</span><span class="o">.</span><span class="n">comment3</span> <span class="o">=</span> <span class="n">comment3</span>
    <span class="n">st</span><span class="o">.</span><span class="n">comment4</span> <span class="o">=</span> <span class="n">comment4</span>
    <span class="n">st</span><span class="o">.</span><span class="n">comment5</span> <span class="o">=</span> <span class="n">comment5</span>
    <span class="k">return</span> <span class="n">st</span></div>


<div class="viewcode-block" id="ComplexType"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.ComplexType.html#sdynpy.core.sdynpy_data.ComplexType">[docs]</a><span class="k">class</span> <span class="nc">ComplexType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Enumeration containing the various ways to plot complex data&quot;&quot;&quot;</span>
    <span class="n">REAL</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">IMAGINARY</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">MAGNITUDE</span> <span class="o">=</span> <span class="mi">2</span>
    <span class="n">PHASE</span> <span class="o">=</span> <span class="mi">3</span>
    <span class="n">REALIMAG</span> <span class="o">=</span> <span class="mi">4</span>
    <span class="n">MAGPHASE</span> <span class="o">=</span> <span class="mi">5</span></div>


<div class="viewcode-block" id="GUIPlot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot">[docs]</a><span class="k">class</span> <span class="nc">GUIPlot</span><span class="p">(</span><span class="n">QMainWindow</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An iteractive plot window allowing users to visualize data&quot;&quot;&quot;</span>

<div class="viewcode-block" id="GUIPlot.__init__"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">data_to_plot</span><span class="p">,</span> <span class="o">**</span><span class="n">labeled_data_to_plot</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Create a GUIPlot window to visualize data.</span>

<span class="sd">        Multiple datasets can be overlaid by providing additional datasets as</span>
<span class="sd">        arguments.  Position arguments will be labelled generically in the</span>
<span class="sd">        legend.  Keyword arguments will be labelled with their keywords with</span>
<span class="sd">        `_` replaced by ` `.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *data_to_plot : NDDataArray</span>
<span class="sd">            Data to visualize.  Data passed by positional argument will be</span>
<span class="sd">            labeled generically in the legend</span>
<span class="sd">        **labeled_data_to_plot : NDDataArray</span>
<span class="sd">            Data to visualize.  Data passed by keyword argument will be</span>
<span class="sd">            labeled with its keyword</span>
<span class="sd">        abscissa_markers : np.ndarray</span>
<span class="sd">            Abscissa values at which markers will be placed.  If not specified,</span>
<span class="sd">            no markers will be added.  Markers will be added to all plotted</span>
<span class="sd">            curves if this argument is passed.  To add markers to just a</span>
<span class="sd">            specific plotted data, pass the argument `abscissa_markers_*` where</span>
<span class="sd">            `*` is replaced with either the index of the data that was passed</span>
<span class="sd">            via a positional argument, or the keyword of the data that was</span>
<span class="sd">            passed via a keyword argument.  Must be passed as a keyword argument.</span>
<span class="sd">        abscissa_marker_labels : iterable</span>
<span class="sd">            Labels that will be applied to the markers.  If not specified, no</span>
<span class="sd">            label will be applied.  If a single string is passed, it will be</span>
<span class="sd">            passed to the `.format` method with keyword arguments `index` and</span>
<span class="sd">            `abscissa`.  This marker label will be used for all plotted</span>
<span class="sd">            curves if this argument is passed.  To add markers to just a</span>
<span class="sd">            specific plotted data, pass the argument `abscissa_marker_labels_*` where</span>
<span class="sd">            `*` is replaced with either the index of the data that was passed</span>
<span class="sd">            via a positional argument, or the keyword of the data that was</span>
<span class="sd">            passed via a keyword argument.  Must be passed as a keyword argument.</span>
<span class="sd">        abscissa_marker_type : str:</span>
<span class="sd">            The type of marker that will be applied.  Can be &#39;vline&#39; for a</span>
<span class="sd">            vertical line across the axis, or it can be a pyqtgraph symbol specifier</span>
<span class="sd">            (e.g. &#39;x&#39;, &#39;o&#39;, &#39;star&#39;, etc.) which will be placed on the plotted curves.</span>
<span class="sd">            If not specified, a vertical line will be used.</span>
<span class="sd">            This marker type will be used for all plotted</span>
<span class="sd">            curves if this argument is passed.  To add markers to just a</span>
<span class="sd">            specific plotted data, pass the argument `abscissa_marker_type_*` where</span>
<span class="sd">            `*` is replaced with either the index of the data that was passed</span>
<span class="sd">            via a positional argument, or the keyword of the data that was</span>
<span class="sd">            passed via a keyword argument.  Must be passed as a keyword argument.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Parse the dataset arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_arguments</span><span class="p">(</span><span class="n">data_to_plot</span><span class="p">,</span><span class="n">labeled_data_to_plot</span><span class="p">)</span>
        <span class="c1"># Now go through and reshape the data so it&#39;s all the same size</span>
        <span class="n">first_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_original_shape</span> <span class="o">=</span> <span class="n">first_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">first_data</span><span class="o">.</span><span class="n">coordinate</span>
        <span class="n">function_type</span> <span class="o">=</span> <span class="n">first_data</span><span class="o">.</span><span class="n">function_type</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Coordinates not consistent for dataset </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">GUIPlot</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="n">uic</span><span class="o">.</span><span class="n">loadUi</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span>
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="vm">__file__</span><span class="p">))),</span> <span class="s1">&#39;GUIPlot.ui&#39;</span><span class="p">),</span> <span class="bp">self</span><span class="p">)</span>
        <span class="c1"># Set up the table</span>
        <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">first_data</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
            <span class="n">this_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">rowCount</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">insertRow</span><span class="p">(</span><span class="n">this_row</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">_imat_function_type_inverse_map</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">function_type</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="n">_imat_function_type_inverse_map</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">function_type</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">resizeColumnsToContents</span><span class="p">()</span>
        <span class="c1"># Set up color map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">tab20</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Combine tab20b and tab20c</span>
            <span class="n">tab_b</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20b&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
            <span class="n">tab_c</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20c&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tab_c</span><span class="p">,</span> <span class="n">tab_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Combine tab20b and tab20c</span>
            <span class="n">tab_b</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20b&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
            <span class="n">tab_c</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20c&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tab_c</span><span class="p">,</span> <span class="n">tab_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">tab10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="c1"># Adjust the default plotting</span>
        <span class="k">if</span> <span class="n">function_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">GENERAL</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
                             <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">COHERENCE</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOCORRELATION</span><span class="p">,</span>
                             <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSCORRELATION</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MODE_INDICATOR_FUNCTION</span><span class="p">,</span>
                             <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">MULTIPLE_COHERENCE</span><span class="p">]:</span>
            <span class="n">complex_type</span> <span class="o">=</span> <span class="n">ComplexType</span><span class="o">.</span><span class="n">REAL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">elif</span> <span class="n">function_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">AUTOSPECTRUM</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">POWER_SPECTRAL_DENSITY</span><span class="p">,</span>
                               <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">ENERGY_SPECTRAL_DENSITY</span><span class="p">]:</span>
            <span class="n">complex_type</span> <span class="o">=</span> <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGNITUDE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">function_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">CROSSSPECTRUM</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">FREQUENCY_RESPONSE_FUNCTION</span><span class="p">,</span>
                               <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TRANSMISIBILITY</span><span class="p">,</span> <span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SPECTRUM</span><span class="p">]:</span>
            <span class="n">complex_type</span> <span class="o">=</span> <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGPHASE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">function_type</span> <span class="ow">in</span> <span class="p">[</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">SHOCK_RESPONSE_SPECTRUM</span><span class="p">]:</span>
            <span class="n">complex_type</span> <span class="o">=</span> <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGNITUDE</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&#39;Unknown Function Type {:}&#39;.format(self.data[0].function_type))</span>
            <span class="n">complex_type</span> <span class="o">=</span> <span class="n">ComplexType</span><span class="o">.</span><span class="n">REAL</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_types</span> <span class="o">=</span> <span class="p">{</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionImaginary</span><span class="p">,</span>
                              <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionMagnitude</span><span class="p">,</span>
                              <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGPHASE</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionMagnitude_Phase</span><span class="p">,</span>
                              <span class="n">ComplexType</span><span class="o">.</span><span class="n">PHASE</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionPhase</span><span class="p">,</span>
                              <span class="n">ComplexType</span><span class="o">.</span><span class="n">REAL</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionReal</span><span class="p">,</span>
                              <span class="n">ComplexType</span><span class="o">.</span><span class="n">REALIMAG</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionReal_Imag</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_function_maps</span> <span class="o">=</span> <span class="p">{</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">,),</span>
                                      <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">,),</span>
                                      <span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGPHASE</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">),</span>
                                      <span class="n">ComplexType</span><span class="o">.</span><span class="n">PHASE</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">,),</span>
                                      <span class="n">ComplexType</span><span class="o">.</span><span class="n">REAL</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">,),</span>
                                      <span class="n">ComplexType</span><span class="o">.</span><span class="n">REALIMAG</span><span class="p">:</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">)}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_labels</span> <span class="o">=</span> <span class="p">{</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">:</span> <span class="s1">&#39;Imag&#39;</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">:</span> <span class="s1">&#39;Mag&#39;</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">:</span> <span class="s1">&#39;Angle&#39;</span><span class="p">,</span>
                               <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">:</span> <span class="s1">&#39;Real&#39;</span><span class="p">}</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">action</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">complex_types</span><span class="p">[</span><span class="n">complex_type</span><span class="p">]</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionAbscissa_Log</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionOrdinate_Log</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">menuShare_Axes</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_button</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionOverlay</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>  <span class="c1"># TODO Remove when you implement non-overlapping plots</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connect_callbacks</span><span class="p">()</span>
        <span class="c1"># Set the first plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">selectRow</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s1">&#39;GUIPlot&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></div>

    <span class="k">def</span> <span class="nf">_parse_arguments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">data_to_plot</span><span class="p">,</span><span class="n">labeled_data_to_plot</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">data_to_plot</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="s1">&#39;Dataset </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">dataset</span> <span class="ow">in</span> <span class="n">labeled_data_to_plot</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;abscissa_markers&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;abscissa_marker_labels&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;abscissa_marker_type&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">elif</span> <span class="n">key</span><span class="p">[:</span><span class="mi">17</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;abscissa_markers_&#39;</span><span class="p">:</span>
                <span class="n">marker_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;abscissa_markers_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">marker_key</span><span class="p">)</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="s1">&#39;Dataset </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">marker_key</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="n">marker_key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">marker_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">marker_key</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">elif</span> <span class="n">key</span><span class="p">[:</span><span class="mi">23</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;abscissa_marker_labels_&#39;</span><span class="p">:</span>
                <span class="n">marker_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;abscissa_marker_labels_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">marker_key</span><span class="p">)</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="s1">&#39;Dataset </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">marker_key</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="n">marker_key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">marker_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">marker_key</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">elif</span> <span class="n">key</span><span class="p">[:</span><span class="mi">21</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;abscissa_marker_type_&#39;</span><span class="p">:</span>
                <span class="n">marker_key</span> <span class="o">=</span> <span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;abscissa_marker_type_&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">marker_key</span><span class="p">)</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="s1">&#39;Dataset </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">marker_key</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">marker_key</span> <span class="o">=</span> <span class="n">marker_key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span><span class="s1">&#39; &#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">marker_key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">marker_key</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">marker_key</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">dataset</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;_&#39;</span><span class="p">,</span> <span class="s1">&#39; &#39;</span><span class="p">)]</span> <span class="o">=</span> <span class="n">dataset</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;At least one dataset must be provided!&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="GUIPlot.connect_callbacks"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.connect_callbacks">[docs]</a>    <span class="k">def</span> <span class="nf">connect_callbacks</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Connects the callback functions to events</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">itemSelectionChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_changed</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionImaginary</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_imaginary</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionMagnitude</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_magnitude</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionMagnitude_Phase</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_magnitude_phase</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionPhase</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_phase</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionReal</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_real</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionReal_Imag</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">set_real_imag</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionOrdinate_Log</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_ordinate_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">actionAbscissa_Log</span><span class="o">.</span><span class="n">triggered</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_abscissa_log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">autoupdate_checkbox</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update_checkbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">linewidth_selector</span><span class="o">.</span><span class="n">valueChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">symbolsize_selector</span><span class="o">.</span><span class="n">valueChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.update"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.update">[docs]</a>    <span class="k">def</span> <span class="nf">update</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Updates the figure in the GUIPlot</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># print(&#39;Updating&#39;)</span>
        <span class="n">select</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">selectionModel</span><span class="p">()</span>
        <span class="c1"># print(&#39;Has Selection {:}&#39;.format(select.hasSelection()))</span>
        <span class="n">row_indices</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span><span class="o">.</span><span class="n">row</span><span class="p">()</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">select</span><span class="o">.</span><span class="n">selectedRows</span><span class="p">()]</span>
        <span class="c1"># print(&#39;Rows Selected {:}&#39;.format(row_indices))</span>
        <span class="c1"># Check if we want to plot them all on one plot</span>
        <span class="c1"># Get existing xaxis to keep it consistent</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">xrange</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphicsLayoutWidget</span><span class="o">.</span><span class="n">getItem</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">getViewBox</span><span class="p">()</span><span class="o">.</span><span class="n">viewRange</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">xrange</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># print(xrange)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">graphicsLayoutWidget</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionOverlay</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="c1"># print(&#39;Single Plot&#39;)</span>
            <span class="c1"># Figure out which is checked</span>
            <span class="n">checked_complex_type</span> <span class="o">=</span> <span class="p">[</span><span class="n">key</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span>
                                    <span class="n">val</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_types</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">isChecked</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">complex_fn</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">complex_function_maps</span><span class="p">[</span><span class="n">checked_complex_type</span><span class="p">]):</span>
                <span class="n">plot</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">graphicsLayoutWidget</span><span class="o">.</span><span class="n">addPlot</span><span class="p">(</span>
                    <span class="n">i</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;left&#39;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_labels</span><span class="p">[</span><span class="n">complex_fn</span><span class="p">]})</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">plot</span><span class="o">.</span><span class="n">setXLink</span><span class="p">(</span><span class="n">plots</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plot</span><span class="o">.</span><span class="n">addLegend</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">index</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">row_indices</span><span class="p">):</span>
                    <span class="n">original_index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_original_shape</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">dataset</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
                        <span class="n">data_entry</span> <span class="o">=</span> <span class="n">dataset</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
                        <span class="n">legend_entry</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">original_index</span><span class="p">,</span> <span class="n">data_entry</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span> <span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;&#39;&quot;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
                        <span class="n">pen</span> <span class="o">=</span> <span class="n">pyqtgraph</span><span class="o">.</span><span class="n">mkPen</span><span class="p">(</span>
                            <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span><span class="p">((</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span><span class="p">)],</span>
                            <span class="n">width</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">linewidth_selector</span><span class="o">.</span><span class="n">value</span><span class="p">())</span>
                        <span class="n">plot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">data_entry</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="n">complex_fn</span><span class="p">(</span><span class="n">data_entry</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span> <span class="o">*</span>
                                  <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">if</span> <span class="n">complex_fn</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span> <span class="k">else</span> <span class="mi">1</span><span class="p">),</span> <span class="n">name</span><span class="o">=</span><span class="n">legend_entry</span><span class="p">,</span> <span class="n">pen</span><span class="o">=</span><span class="n">pen</span><span class="p">)</span>
                        <span class="c1"># Now handle the markers</span>
                        <span class="c1"># First see if there is a matching marker set</span>
                        <span class="k">if</span> <span class="n">label</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                            <span class="n">marker_abscissa</span><span class="p">,</span> <span class="n">marker_labels</span><span class="p">,</span> <span class="n">marker_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="n">label</span><span class="p">]</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">marker_abscissa</span><span class="p">,</span> <span class="n">marker_labels</span><span class="p">,</span> <span class="n">marker_type</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">,</span><span class="kc">None</span><span class="p">]</span>
                        <span class="c1"># Now handle if things are missing</span>
                        <span class="k">if</span> <span class="n">marker_abscissa</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                            <span class="n">marker_abscissa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">marker_labels</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                            <span class="n">marker_labels</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">marker_type</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="kc">None</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">:</span>
                            <span class="n">marker_type</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">marker_data</span><span class="p">[</span><span class="kc">None</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
                        <span class="c1"># Now finally go back to the defaults if they still are</span>
                        <span class="c1"># not defined</span>
                        <span class="k">if</span> <span class="n">marker_abscissa</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span> <span class="c1"># If marker_abscissa is not defined, we don&#39;t plot markers</span>
                            <span class="c1"># The default marker is a vertical line</span>
                            <span class="k">if</span> <span class="n">marker_type</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                <span class="n">marker_type</span> <span class="o">=</span> <span class="s1">&#39;vline&#39;</span>
                            <span class="c1"># Parse out special values of the marker_labels</span>
                            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">marker_labels</span><span class="p">,</span><span class="nb">str</span><span class="p">):</span>
                                <span class="n">marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="n">marker_labels</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">index</span><span class="o">=</span><span class="n">i</span><span class="p">,</span><span class="n">abscissa</span><span class="o">=</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">marker_abscissa</span><span class="p">)]</span>
                            <span class="c1"># Now that we have all of the data we can plot it.</span>
                            <span class="k">if</span> <span class="n">marker_type</span> <span class="o">==</span> <span class="s1">&#39;vline&#39;</span><span class="p">:</span>
                                <span class="k">if</span> <span class="n">marker_labels</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="n">marker_labels</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="n">marker_abscissa</span><span class="p">)</span>
                                <span class="k">for</span> <span class="n">value</span><span class="p">,</span><span class="n">marker_label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">marker_abscissa</span><span class="p">,</span><span class="n">marker_labels</span><span class="p">):</span>
                                    <span class="n">vlinepen</span> <span class="o">=</span> <span class="n">pyqtgraph</span><span class="o">.</span><span class="n">mkPen</span><span class="p">(</span>
                                        <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span><span class="p">((</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span><span class="p">)],</span>
                                        <span class="n">width</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
                                    <span class="n">vline</span> <span class="o">=</span> <span class="n">pyqtgraph</span><span class="o">.</span><span class="n">InfiniteLine</span><span class="p">(</span>
                                        <span class="n">value</span><span class="p">,</span><span class="n">pen</span><span class="o">=</span><span class="n">vlinepen</span><span class="p">,</span><span class="n">hoverPen</span><span class="o">=</span><span class="n">pen</span><span class="p">,</span>
                                        <span class="n">label</span><span class="o">=</span><span class="n">marker_label</span><span class="p">,</span>
                                        <span class="n">labelOpts</span><span class="o">=</span><span class="p">{</span><span class="s1">&#39;position&#39;</span><span class="p">:</span><span class="mf">0.0</span><span class="p">,</span><span class="s1">&#39;rotateAxis&#39;</span><span class="p">:(</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span><span class="s1">&#39;anchors&#39;</span><span class="p">:[(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">),(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">)],</span>
                                                   <span class="s1">&#39;color&#39;</span><span class="p">:(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">)})</span>
                                    <span class="n">plot</span><span class="o">.</span><span class="n">addItem</span><span class="p">(</span><span class="n">vline</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">x</span><span class="o">=</span><span class="n">data_entry</span><span class="o">.</span><span class="n">abscissa</span>
                                <span class="n">y</span><span class="o">=</span><span class="n">complex_fn</span><span class="p">(</span><span class="n">data_entry</span><span class="o">.</span><span class="n">ordinate</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">180</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="k">if</span> <span class="n">complex_fn</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span> <span class="k">else</span> <span class="mi">1</span><span class="p">)</span>
                                <span class="n">marker_ordinate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">marker_abscissa</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
                                <span class="n">brush</span> <span class="o">=</span> <span class="n">pyqtgraph</span><span class="o">.</span><span class="n">mkBrush</span><span class="p">(</span>
                                    <span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="mi">255</span> <span class="o">*</span> <span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span><span class="p">((</span><span class="n">j</span> <span class="o">*</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span><span class="p">)</span> <span class="o">+</span> <span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span><span class="p">)])</span>
                                <span class="n">plot</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="o">=</span><span class="n">marker_abscissa</span><span class="p">,</span><span class="n">y</span><span class="o">=</span><span class="n">marker_ordinate</span><span class="p">,</span><span class="n">pen</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                                          <span class="n">symbol</span><span class="o">=</span><span class="n">marker_type</span><span class="p">,</span> <span class="n">symbolSize</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">symbolsize_selector</span><span class="o">.</span><span class="n">value</span><span class="p">(),</span> 
                                          <span class="n">symbolPen</span><span class="o">=</span><span class="n">pen</span><span class="p">,</span><span class="n">symbolBrush</span><span class="o">=</span><span class="n">brush</span><span class="p">)</span>
                                <span class="k">if</span> <span class="n">marker_labels</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                                    <span class="k">for</span> <span class="n">text_abscissa</span><span class="p">,</span><span class="n">text_ordinate</span><span class="p">,</span><span class="n">text_label</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">marker_abscissa</span><span class="p">,</span><span class="n">marker_ordinate</span><span class="p">,</span><span class="n">marker_labels</span><span class="p">):</span>
                                        <span class="n">ti</span> <span class="o">=</span> <span class="n">pyqtgraph</span><span class="o">.</span><span class="n">TextItem</span><span class="p">(</span><span class="n">text_label</span><span class="p">,</span><span class="n">anchor</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">),</span><span class="n">color</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>
                                        <span class="n">plot</span><span class="o">.</span><span class="n">addItem</span><span class="p">(</span><span class="n">ti</span><span class="p">)</span>
                                        <span class="c1"># TODO: Remove the log10s when pyqtgraph issue 2166 is fixed</span>
                                        <span class="c1"># https://github.com/pyqtgraph/pyqtgraph/issues/2166</span>
                                        <span class="n">ti</span><span class="o">.</span><span class="n">setPos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">text_abscissa</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="k">else</span> <span class="n">text_abscissa</span><span class="p">,</span>
                                                  <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">text_ordinate</span><span class="p">)</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="k">else</span> <span class="n">text_ordinate</span><span class="p">)</span>
                        
                <span class="n">plot</span><span class="o">.</span><span class="n">setLogMode</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span><span class="p">,</span>
                                <span class="kc">False</span> <span class="k">if</span> <span class="n">complex_fn</span> <span class="ow">is</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span> <span class="k">else</span> <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">xrange</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plot</span><span class="o">.</span><span class="n">setXRange</span><span class="p">(</span><span class="o">*</span><span class="n">xrange</span><span class="p">,</span> <span class="n">padding</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
                <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">plot</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.update_data"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.update_data">[docs]</a>    <span class="k">def</span> <span class="nf">update_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">data_to_plot</span><span class="p">,</span> <span class="o">**</span><span class="n">labeled_data_to_plot</span><span class="p">):</span>
        <span class="c1"># Parse the dataset arguments</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_parse_arguments</span><span class="p">(</span><span class="n">data_to_plot</span><span class="p">,</span> <span class="n">labeled_data_to_plot</span><span class="p">)</span>
        <span class="c1"># Now go through and reshape the data so it&#39;s all the same size</span>
        <span class="n">first_data</span> <span class="o">=</span> <span class="p">[</span><span class="n">v</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="o">.</span><span class="n">values</span><span class="p">()][</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data_original_shape</span> <span class="o">=</span> <span class="n">first_data</span><span class="o">.</span><span class="n">shape</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">=</span> <span class="n">first_data</span><span class="o">.</span><span class="n">coordinate</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Warning: Coordinates not consistent for dataset </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data_dictionary</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">new_coordinate</span> <span class="o">=</span> <span class="n">first_data</span><span class="o">.</span><span class="n">coordinate</span>
        <span class="k">if</span> <span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">new_coordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="ow">or</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coordinates</span> <span class="o">!=</span> <span class="n">new_coordinate</span><span class="p">))):</span>
            <span class="c1"># Redo the table</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setRowCount</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">fn</span> <span class="ow">in</span> <span class="n">first_data</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
                <span class="n">this_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">rowCount</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">insertRow</span><span class="p">(</span><span class="n">this_row</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">fn</span><span class="o">.</span><span class="n">dtype</span><span class="p">[</span><span class="s1">&#39;coordinate&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))</span>
                    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                        <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">fn</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">item</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">_imat_function_type_inverse_map</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">function_type</span><span class="p">]))</span>
                <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                    <span class="n">item</span> <span class="o">=</span> <span class="n">QtWidgets</span><span class="o">.</span><span class="n">QTableWidgetItem</span><span class="p">(</span>
                        <span class="nb">str</span><span class="p">(</span><span class="n">_imat_function_type_inverse_map</span><span class="p">[</span><span class="n">fn</span><span class="o">.</span><span class="n">function_type</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">setItem</span><span class="p">(</span><span class="n">this_row</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">resizeColumnsToContents</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">tableWidget</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Set up color map</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">tab20</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">20</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datasets</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1"># Combine tab20b and tab20c</span>
            <span class="n">tab_b</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20b&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
            <span class="n">tab_c</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20c&#39;</span><span class="p">,</span> <span class="mi">15</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">15</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tab_c</span><span class="p">,</span> <span class="n">tab_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">30</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">number_of_datsets</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="c1"># Combine tab20b and tab20c</span>
            <span class="n">tab_b</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20b&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
            <span class="n">tab_c</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;tab20c&#39;</span><span class="p">,</span> <span class="mi">20</span><span class="p">)(</span><span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">20</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">ListedColormap</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">tab_c</span><span class="p">,</span> <span class="n">tab_b</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">40</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">tab10</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cm_mod</span> <span class="o">=</span> <span class="mi">10</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

<div class="viewcode-block" id="GUIPlot.selection_changed"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.selection_changed">[docs]</a>    <span class="k">def</span> <span class="nf">selection_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Called when the selected functions is changed&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoupdate_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

<div class="viewcode-block" id="GUIPlot.deselect_all_complex_types_except"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.deselect_all_complex_types_except">[docs]</a>    <span class="k">def</span> <span class="nf">deselect_all_complex_types_except</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">complex_type</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deselects all complex types except the specified type.</span>

<span class="sd">        Makes the checkboxes in the menu act like radiobuttons</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        complex_type : ComplexType</span>
<span class="sd">            Enumeration specifying which complex plot type is selected</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">ct</span><span class="p">,</span> <span class="n">action</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">complex_types</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">action</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ct</span> <span class="ow">is</span> <span class="n">complex_type</span><span class="p">:</span>
                <span class="n">action</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">action</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">action</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoupdate_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

<div class="viewcode-block" id="GUIPlot.set_imaginary"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.set_imaginary">[docs]</a>    <span class="k">def</span> <span class="nf">set_imaginary</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the complex type to imaginary&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deselect_all_complex_types_except</span><span class="p">(</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.set_real"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.set_real">[docs]</a>    <span class="k">def</span> <span class="nf">set_real</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the complex type to real&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deselect_all_complex_types_except</span><span class="p">(</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">REAL</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.set_magnitude"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.set_magnitude">[docs]</a>    <span class="k">def</span> <span class="nf">set_magnitude</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the complex type to magnitude&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deselect_all_complex_types_except</span><span class="p">(</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.set_phase"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.set_phase">[docs]</a>    <span class="k">def</span> <span class="nf">set_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the complex type to phase&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deselect_all_complex_types_except</span><span class="p">(</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">PHASE</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.set_magnitude_phase"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.set_magnitude_phase">[docs]</a>    <span class="k">def</span> <span class="nf">set_magnitude_phase</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the complex type to magnitude and phase&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deselect_all_complex_types_except</span><span class="p">(</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">MAGPHASE</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.set_real_imag"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.set_real_imag">[docs]</a>    <span class="k">def</span> <span class="nf">set_real_imag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the complex type to real and imaginary&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">deselect_all_complex_types_except</span><span class="p">(</span><span class="n">ComplexType</span><span class="o">.</span><span class="n">REALIMAG</span><span class="p">)</span></div>

<div class="viewcode-block" id="GUIPlot.update_abscissa_log"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.update_abscissa_log">[docs]</a>    <span class="k">def</span> <span class="nf">update_abscissa_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates whether the abscissa should be plotted as log scale&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abscissa_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionAbscissa_Log</span><span class="o">.</span><span class="n">isChecked</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoupdate_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

<div class="viewcode-block" id="GUIPlot.update_ordinate_log"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.update_ordinate_log">[docs]</a>    <span class="k">def</span> <span class="nf">update_ordinate_log</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates whether the ordinate should be plotted as log scale&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ordinate_log</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">actionOrdinate_Log</span><span class="o">.</span><span class="n">isChecked</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoupdate_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update</span><span class="p">()</span></div>

<div class="viewcode-block" id="GUIPlot.update_checkbox"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot.update_checkbox">[docs]</a>    <span class="k">def</span> <span class="nf">update_checkbox</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Disables the update button if set to auto-update&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pushButton</span><span class="o">.</span><span class="n">setEnabled</span><span class="p">(</span><span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">autoupdate_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">())</span></div></div>


<div class="viewcode-block" id="MPLCanvas"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.MPLCanvas.html#sdynpy.core.sdynpy_data.MPLCanvas">[docs]</a><span class="k">class</span> <span class="nc">MPLCanvas</span><span class="p">(</span><span class="n">FigureCanvas</span><span class="p">):</span>
    <span class="c1"># This is a custom widget that can be used to put plots into a GUI window</span>
<div class="viewcode-block" id="MPLCanvas.__init__"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.MPLCanvas.html#sdynpy.core.sdynpy_data.MPLCanvas.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">):</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axis</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>

        <span class="n">FigureCanvas</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setParent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="n">FigureCanvas</span><span class="o">.</span><span class="n">setSizePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">QSizePolicy</span><span class="o">.</span><span class="n">Expanding</span><span class="p">,</span> <span class="n">QSizePolicy</span><span class="o">.</span><span class="n">Expanding</span><span class="p">)</span>
        <span class="n">FigureCanvas</span><span class="o">.</span><span class="n">updateGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="MPLMultiCanvas"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.MPLMultiCanvas.html#sdynpy.core.sdynpy_data.MPLMultiCanvas">[docs]</a><span class="k">class</span> <span class="nc">MPLMultiCanvas</span><span class="p">(</span><span class="n">FigureCanvas</span><span class="p">):</span>
    <span class="c1"># This is a custom widget that can be used to put plots into a GUI window</span>
<div class="viewcode-block" id="MPLMultiCanvas.__init__"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.MPLMultiCanvas.html#sdynpy.core.sdynpy_data.MPLMultiCanvas.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">subplots</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">ignore_subplots</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig</span> <span class="o">=</span> <span class="n">Figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">),</span> <span class="n">dpi</span><span class="o">=</span><span class="n">dpi</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">axes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">subplots</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subplots</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">subplots</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span> <span class="o">*</span> <span class="n">subplots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">index</span> <span class="ow">in</span> <span class="n">ignore_subplots</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">axes</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="n">subplots</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">subplots</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">index</span><span class="p">)</span>

        <span class="n">FigureCanvas</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">fig</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setParent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="n">FigureCanvas</span><span class="o">.</span><span class="n">setSizePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">QSizePolicy</span><span class="o">.</span><span class="n">Expanding</span><span class="p">,</span> <span class="n">QSizePolicy</span><span class="o">.</span><span class="n">Expanding</span><span class="p">)</span>
        <span class="n">FigureCanvas</span><span class="o">.</span><span class="n">updateGeometry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="CPSDPlot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot">[docs]</a><span class="k">class</span> <span class="nc">CPSDPlot</span><span class="p">(</span><span class="n">QMainWindow</span><span class="p">):</span>

<div class="viewcode-block" id="CPSDPlot.DataType"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.DataType">[docs]</a>    <span class="k">class</span> <span class="nc">DataType</span><span class="p">(</span><span class="n">Enum</span><span class="p">):</span>
        <span class="n">MAGNITUDE</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">COHERENCE</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="n">PHASE</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="n">REAL</span> <span class="o">=</span> <span class="mi">8</span>
        <span class="n">IMAGINARY</span> <span class="o">=</span> <span class="mi">16</span></div>

<div class="viewcode-block" id="CPSDPlot.__init__"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">:</span> <span class="n">PowerSpectralDensityArray</span><span class="p">,</span>
                 <span class="n">compare_data</span><span class="p">:</span> <span class="n">PowerSpectralDensityArray</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">data</span><span class="o">.</span><span class="n">validate_common_abscissa</span><span class="p">(</span><span class="n">rtol</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-8</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Data must have common abscissa&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">data</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">compare_data</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;compare_data.ordinate must have the same size as data.ordinate (</span><span class="si">{:}</span><span class="s1"> != </span><span class="si">{:}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">compare_data</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">ordinate</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">abscissa</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare_matrix</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">np</span><span class="o">.</span><span class="n">moveaxis</span><span class="p">(</span>
            <span class="n">compare_data</span><span class="o">.</span><span class="n">reshape_to_matrix</span><span class="p">()</span><span class="o">.</span><span class="n">ordinate</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cm</span> <span class="o">=</span> <span class="n">cm</span><span class="o">.</span><span class="n">Dark2</span> <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">cm</span><span class="o">.</span><span class="n">Paired</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coh_matrix</span> <span class="o">=</span> <span class="n">sp_coherence</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">compare_coh_matrix</span> <span class="o">=</span> <span class="kc">None</span> <span class="k">if</span> <span class="n">compare_data</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">sp_coherence</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compare_matrix</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_start</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_rectangles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_rectangles</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">initUI</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">connectUI</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_matrix_plot</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.initUI"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.initUI">[docs]</a>    <span class="k">def</span> <span class="nf">initUI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Main Widget</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_widget</span> <span class="o">=</span> <span class="n">QWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_widget</span><span class="p">)</span>
        <span class="c1"># Figure Control Groupbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span> <span class="o">=</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_widget</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span><span class="p">)</span>
        <span class="c1"># Figure Selection Group Box</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox</span> <span class="o">=</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox_layout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span> <span class="o">=</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="c1"># Grid Layout for Selection Buttons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span> <span class="o">=</span> <span class="n">QGridLayout</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_select_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diagonal_select_button</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_selection_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clear_selection_button</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_select_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_select_button</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_select_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_select_button</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_select_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotted_select_button</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_select_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_select_button</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_deselect_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">diagonal_deselect_button</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_deselect_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_deselect_button</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_deselect_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_deselect_button</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox_layout</span><span class="o">.</span><span class="n">addLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_button_layout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="p">)</span>
        <span class="c1"># Plotting Options Groupbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span> <span class="o">=</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="c1"># Grid layout for plot buttons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_layout</span> <span class="o">=</span> <span class="n">QGridLayout</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_selected_button</span> <span class="o">=</span> <span class="n">QPushButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_selected_button</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_mode_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">()</span>
        <span class="c1"># Radio Buttons for plotting method</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_mode_button</span> <span class="o">=</span> <span class="n">QRadioButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_mode_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix_mode_button</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_mode_button</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequential_mode_button</span> <span class="o">=</span> <span class="n">QRadioButton</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_mode_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sequential_mode_button</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_layout</span><span class="o">.</span><span class="n">addLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_mode_layout</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox_layout</span><span class="o">.</span><span class="n">addLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_layout</span><span class="p">)</span>
        <span class="c1"># Grid Layout for the function types</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span> <span class="o">=</span> <span class="n">QGridLayout</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span> <span class="o">=</span> <span class="n">QCheckBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_type_checkboxes</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="p">,</span>
                                         <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="p">]</span>
        <span class="c1"># Set them so they are tristate</span>
        <span class="k">for</span> <span class="n">box</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="p">,</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="p">]:</span>
            <span class="n">box</span><span class="o">.</span><span class="n">setTristate</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox_layout</span><span class="o">.</span><span class="n">addLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">function_type_layout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="p">)</span>
        <span class="c1"># Finish setting up the main window</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">main_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setCentralWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">main_widget</span><span class="p">)</span>
        <span class="c1"># Set up the menu bar</span>
        <span class="c1"># self.menubar = QMenuBar(self)</span>
        <span class="c1"># self.menubar.setGeometry(QRect(0, 0, 742, 21))</span>
        <span class="c1"># self.menubar.setAccessibleName(&quot;&quot;)</span>
        <span class="c1"># self.menuFile = QMenu(self.menubar)</span>
        <span class="c1"># self.menuFigure = QMenu(self.menubar)</span>
        <span class="c1"># self.setMenuBar(self.menubar)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock</span> <span class="o">=</span> <span class="n">QDockWidget</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock</span><span class="o">.</span><span class="n">setFeatures</span><span class="p">(</span><span class="n">QDockWidget</span><span class="o">.</span><span class="n">DockWidgetFloatable</span> <span class="o">|</span>
                                        <span class="n">QDockWidget</span><span class="o">.</span><span class="n">DockWidgetMovable</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock_main</span> <span class="o">=</span> <span class="n">QWidget</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock_main_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_dock_main</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox</span> <span class="o">=</span> <span class="n">QGroupBox</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_dock_main</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox_layout</span> <span class="o">=</span> <span class="n">QVBoxLayout</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox</span><span class="o">.</span><span class="n">setLayout</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox_layout</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock_main_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock</span><span class="o">.</span><span class="n">setWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">functions_dock_main</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">addDockWidget</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">DockWidgetArea</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">functions_dock</span><span class="p">)</span>

        <span class="c1"># self.actionLoad_Matrix = QAction(self)</span>
        <span class="c1"># self.actionLoad_Matrix.setObjectName(&quot;actionLoad_Matrix&quot;)</span>
        <span class="c1"># self.actionExit = QAction(self)</span>
        <span class="c1"># self.actionExit.setObjectName(&quot;actionExit&quot;)</span>
        <span class="c1"># self.actionSave_Figure = QAction(self)</span>
        <span class="c1"># self.actionSave_Figure.setObjectName(&quot;actionSave_Figure&quot;)</span>
        <span class="c1"># self.menuFile.addAction(self.actionLoad_Matrix)</span>
        <span class="c1"># self.menuFile.addSeparator()</span>
        <span class="c1"># self.menuFile.addAction(self.actionExit)</span>
        <span class="c1"># self.menuFigure.addAction(self.actionSave_Figure)</span>
        <span class="c1"># self.menubar.addAction(self.menuFile.menuAction())</span>
        <span class="c1"># self.menubar.addAction(self.menuFigure.menuAction())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">settext</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.settext"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.settext">[docs]</a>    <span class="k">def</span> <span class="nf">settext</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setWindowTitle</span><span class="p">(</span><span class="s1">&#39;Cross-power Spectral Density Matrix Viewer&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fig_control_groupbox</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s2">&quot;Figure Control&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s2">&quot;Function Select&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selection_options_groupbox</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s2">&quot;Selection Options&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_select_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Select Diagonal&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_selection_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Clear Selection&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_select_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Select Upper Triangle&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_select_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Invert Selection&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_select_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Select Plotted&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_select_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Select Lower Triangle&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_deselect_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Deselect Diagonal&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_deselect_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Deselect Upper Triangle&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_deselect_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Deselect Lower Triangle&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Matrix Select Mode&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotting_options_groupbox</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s2">&quot;Plotting Options&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_selected_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Plot Selected&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_mode_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Matrix Mode&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sequential_mode_button</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Sequential Mode&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Phase&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Magnitude&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Coherence&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Real&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="o">.</span><span class="n">setText</span><span class="p">(</span><span class="s2">&quot;Imaginary&quot;</span><span class="p">)</span>
        <span class="c1"># self.menuFile.setTitle(&quot;File&quot;)</span>
        <span class="c1"># self.menuFigure.setTitle(&quot;Figure&quot;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox</span><span class="o">.</span><span class="n">setTitle</span><span class="p">(</span><span class="s2">&quot;Functions&quot;</span><span class="p">)</span></div>
        <span class="c1"># self.actionLoad_Matrix.setText(&quot;Load Matrix...&quot;)</span>
        <span class="c1"># self.actionExit.setText(&quot;Exit&quot;)</span>
        <span class="c1"># self.actionSave_Figure.setText(&quot;Save Figure...&quot;)</span>

<div class="viewcode-block" id="CPSDPlot.connectUI"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.connectUI">[docs]</a>    <span class="k">def</span> <span class="nf">connectUI</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># self.actionLoad_Matrix.triggered.connect(self.load)</span>
        <span class="c1"># self.actionExit.triggered.connect(self.quit)</span>
        <span class="c1"># Selection Method checkbox</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">stateChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">state_changed</span><span class="p">)</span>
        <span class="c1"># Plot type checkboxes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="o">.</span><span class="n">stateChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">magnitude_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="o">.</span><span class="n">stateChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">coherence_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="o">.</span><span class="n">stateChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">phase_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="o">.</span><span class="n">stateChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">real_state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="o">.</span><span class="n">stateChanged</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">imaginary_state</span><span class="p">)</span>
        <span class="c1"># Selection Buttons</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_select_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_diagonal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">diagonal_deselect_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deselect_diagonal</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_select_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_upper_triangular</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">upper_tri_deselect_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deselect_upper_triangular</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_select_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_lower_triangular</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lower_tri_deselect_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">deselect_lower_triangular</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear_selection_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">clear_selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">invert_select_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">invert_selection</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_select_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">select_plotted</span><span class="p">)</span>
        <span class="c1"># Plot Button</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_selected_button</span><span class="o">.</span><span class="n">clicked</span><span class="o">.</span><span class="n">connect</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_selected_function</span><span class="p">)</span></div>

<div class="viewcode-block" id="CPSDPlot.init_matrix_plot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.init_matrix_plot">[docs]</a>    <span class="k">def</span> <span class="nf">init_matrix_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># Create the matrix</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
        <span class="n">max_freq_lines</span> <span class="o">=</span> <span class="mi">50</span>
        <span class="n">freq_decimate_factor</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="n">max_freq_lines</span><span class="p">))</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">indices</span><span class="p">[</span><span class="n">freq_decimate_factor</span> <span class="o">//</span> <span class="mi">2</span><span class="p">::</span><span class="n">freq_decimate_factor</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span> <span class="o">=</span> <span class="n">MPLCanvas</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">width</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">height</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">dpi</span><span class="o">=</span><span class="mi">100</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">setFocusPolicy</span><span class="p">(</span><span class="n">Qt</span><span class="o">.</span><span class="n">ClickFocus</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">setFocus</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;button_press_event&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector_click</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">mpl_connect</span><span class="p">(</span><span class="s1">&#39;button_release_event&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector_unclick</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_rectangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_rectangles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">object</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">function_select_groupbox_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">0.25</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]))</span>
                <span class="n">data</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">/=</span> <span class="o">-</span><span class="mf">2.5</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">abscissa</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="n">j</span><span class="p">,</span> <span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">logical_selector</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">data</span> <span class="o">&gt;</span> <span class="o">-</span><span class="mf">.5</span><span class="p">,</span> <span class="n">data</span> <span class="o">&lt;</span> <span class="mf">.5</span><span class="p">),</span> <span class="n">indices</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">abscissa</span><span class="p">[</span><span class="n">logical_selector</span><span class="p">],</span>
                                        <span class="n">data</span><span class="p">[</span><span class="n">logical_selector</span><span class="p">]</span> <span class="o">+</span> <span class="n">i</span> <span class="o">+</span> <span class="mf">.5</span><span class="p">,</span> <span class="s1">&#39;b&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">.25</span><span class="p">)</span>
                <span class="c1"># Create the rectangle</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select_rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                    <span class="n">Rectangle</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;k&#39;</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_rectangles</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">add_patch</span><span class="p">(</span>
                    <span class="n">Rectangle</span><span class="p">((</span><span class="n">j</span><span class="p">,</span> <span class="n">i</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;r&#39;</span><span class="p">,</span> <span class="n">visible</span><span class="o">=</span><span class="kc">False</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">set_position</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">set_xticks</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">set_yticks</span><span class="p">([])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">axis</span><span class="o">.</span><span class="n">invert_yaxis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;int8&#39;</span><span class="p">)</span></div>
<span class="c1">#        # Get the current widget size and resize if necessary</span>
<span class="c1">#        self.selector.updateGeometry()</span>
<span class="c1">#        w = self.selector.width()</span>
<span class="c1">#        h = self.selector.height()</span>
<span class="c1">#        print((w,h))</span>
<span class="c1">#        self.selector.resize(shape[2]*10 if w &lt; shape[2]*10 else w,</span>
<span class="c1">#                             shape[1]*10 if h &lt; shape[1]*10 else h)</span>
<span class="c1">#        self.selector.updateGeometry()</span>

<div class="viewcode-block" id="CPSDPlot.selector_click"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.selector_click">[docs]</a>    <span class="k">def</span> <span class="nf">selector_click</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># print(&#39;{:} Click: button={:}, x={:}, y={:}, xdata={:}, ydata={:}&#39;.format(</span>
        <span class="c1">#         &#39;double&#39; if event.dblclick else &#39;single&#39;,</span>
        <span class="c1">#         event.button, event.x,event.y,event.xdata,event.ydata))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">select_start</span> <span class="o">=</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">)</span></div>

<div class="viewcode-block" id="CPSDPlot.selector_unclick"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.selector_unclick">[docs]</a>    <span class="k">def</span> <span class="nf">selector_unclick</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="n">modifiers</span> <span class="o">=</span> <span class="n">QApplication</span><span class="o">.</span><span class="n">keyboardModifiers</span><span class="p">()</span>
        <span class="c1"># print(&#39;{:} Release: button={:}, x={:}, y={:}, xdata={:}, ydata={:}&#39;.format(</span>
        <span class="c1">#         &#39;double&#39; if event.dblclick else &#39;single&#39;,</span>
        <span class="c1">#         event.button, event.x,event.y,event.xdata,event.ydata))</span>
        <span class="n">j</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">xdata</span><span class="p">))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">event</span><span class="o">.</span><span class="n">ydata</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">ii</span><span class="p">,</span> <span class="n">ji</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">select_start</span>
        <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">select_start</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">return</span>
        <span class="c1"># See if we need to switch them</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">ii</span><span class="p">:</span>
            <span class="n">i</span><span class="p">,</span> <span class="n">ii</span> <span class="o">=</span> <span class="n">ii</span><span class="p">,</span> <span class="n">i</span>
        <span class="k">if</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">ji</span><span class="p">:</span>
            <span class="n">j</span><span class="p">,</span> <span class="n">ji</span> <span class="o">=</span> <span class="n">ji</span><span class="p">,</span> <span class="n">j</span>
        <span class="k">if</span> <span class="n">modifiers</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">.</span><span class="n">ShiftModifier</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ji</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="n">modifiers</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">.</span><span class="n">ControlModifier</span> <span class="ow">and</span> <span class="n">ii</span> <span class="o">==</span> <span class="n">i</span> <span class="ow">and</span> <span class="n">ji</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[:,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">ii</span><span class="p">:</span><span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ji</span><span class="p">:</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_selection_matrix</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.select_upper_triangular"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.select_upper_triangular">[docs]</a>    <span class="k">def</span> <span class="nf">select_upper_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.select_lower_triangular"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.select_lower_triangular">[docs]</a>    <span class="k">def</span> <span class="nf">select_lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.select_diagonal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.select_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">select_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.deselect_upper_triangular"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.deselect_upper_triangular">[docs]</a>    <span class="k">def</span> <span class="nf">deselect_upper_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.deselect_lower_triangular"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.deselect_lower_triangular">[docs]</a>    <span class="k">def</span> <span class="nf">deselect_lower_triangular</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.deselect_diagonal"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.deselect_diagonal">[docs]</a>    <span class="k">def</span> <span class="nf">deselect_diagonal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">j</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.clear_selection"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.clear_selection">[docs]</a>    <span class="k">def</span> <span class="nf">clear_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.invert_selection"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.invert_selection">[docs]</a>    <span class="k">def</span> <span class="nf">invert_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">),</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.select_plotted"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.select_plotted">[docs]</a>    <span class="k">def</span> <span class="nf">select_plotted</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">setChecked</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">[:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">[:]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.magnitude_state"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.magnitude_state">[docs]</a>    <span class="k">def</span> <span class="nf">magnitude_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># print(&#39;Magnitude Checkbox Fired&#39;)</span>
        <span class="c1"># print(self.magnitude_checkbox.checkState())</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="o">.</span><span class="n">checkState</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="o">.</span><span class="n">setCheckState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">magnitude_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CPSDPlot.coherence_state"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.coherence_state">[docs]</a>    <span class="k">def</span> <span class="nf">coherence_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># print(&#39;Coherence Checkbox Fired&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="o">.</span><span class="n">checkState</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">COHERENCE</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="o">.</span><span class="n">setCheckState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coherence_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">COHERENCE</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CPSDPlot.phase_state"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.phase_state">[docs]</a>    <span class="k">def</span> <span class="nf">phase_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># print(&#39;Phase Checkbox Fired&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="o">.</span><span class="n">checkState</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">PHASE</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="o">.</span><span class="n">setCheckState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">phase_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">PHASE</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CPSDPlot.real_state"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.real_state">[docs]</a>    <span class="k">def</span> <span class="nf">real_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># print(&#39;Real Checkbox Fired&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="o">.</span><span class="n">checkState</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">REAL</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="o">.</span><span class="n">setCheckState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">real_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">REAL</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CPSDPlot.imaginary_state"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.imaginary_state">[docs]</a>    <span class="k">def</span> <span class="nf">imaginary_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="c1"># print(&#39;Imaginary Checkbox Fired&#39;)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="o">.</span><span class="n">checkState</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">|=</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="o">.</span><span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="o">.</span><span class="n">setCheckState</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">imaginary_checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">&amp;=</span> <span class="o">~</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="o">.</span><span class="n">value</span></div>

<div class="viewcode-block" id="CPSDPlot.plot_selected_function"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.plot_selected_function">[docs]</a>    <span class="k">def</span> <span class="nf">plot_selected_function</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">):</span>
            <span class="c1">#            print((key,val))</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_rectangles</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">plot_rectangles</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.update_selection"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.update_selection">[docs]</a>    <span class="k">def</span> <span class="nf">update_selection</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print(&#39;updating selection&#39;)</span>
        <span class="c1"># Update the function type check boxes</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_function_types</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">val</span><span class="p">,</span> <span class="n">checkbox</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">function_type_checkboxes</span><span class="p">):</span>
            <span class="n">checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">checkbox</span><span class="o">.</span><span class="n">setCheckState</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
            <span class="n">checkbox</span><span class="o">.</span><span class="n">blockSignals</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">):</span>
            <span class="c1">#            print((key,val))</span>
            <span class="k">if</span> <span class="n">val</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select_rectangles</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">select_rectangles</span><span class="p">[</span><span class="n">key</span><span class="p">]</span><span class="o">.</span><span class="n">set_visible</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># print(&#39;drawing&#39;)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">draw</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.extend_selection_matrix"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.extend_selection_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">extend_selection_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span> <span class="o">=</span> <span class="n">rows</span><span class="p">[:,</span> <span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span> <span class="o">*</span> <span class="n">cols</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="CPSDPlot.state_changed"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.state_changed">[docs]</a>    <span class="k">def</span> <span class="nf">state_changed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">event</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_select_checkbox</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_selection_matrix</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">update_selection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">selector</span><span class="o">.</span><span class="n">setFocus</span><span class="p">()</span></div>

<div class="viewcode-block" id="CPSDPlot.find_function_types"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.find_function_types">[docs]</a>    <span class="k">def</span> <span class="nf">find_function_types</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print(self.plot_type_bits.shape)</span>
        <span class="c1"># print(self.selected_function.shape)</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">selected_function</span><span class="p">]</span>
        <span class="c1"># print(mat)</span>
        <span class="n">any_functions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">mat</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">COHERENCE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">PHASE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">REAL</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="o">.</span><span class="n">value</span><span class="p">]]</span>
        <span class="n">all_functions</span> <span class="o">=</span> <span class="p">[</span><span class="mi">2</span> <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">mat</span> <span class="o">&amp;</span> <span class="n">bit</span><span class="p">)</span> <span class="k">else</span> <span class="mi">0</span> <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">COHERENCE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                                                   <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">PHASE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">REAL</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="o">.</span><span class="n">value</span><span class="p">]]</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">([</span><span class="n">any_functions</span><span class="p">,</span> <span class="n">all_functions</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span></div>

<div class="viewcode-block" id="CPSDPlot.plot"><a class="viewcode-back" href="../../../_autosummary/sdynpy.core.sdynpy_data.CPSDPlot.html#sdynpy.core.sdynpy_data.CPSDPlot.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># print(&#39;plotting&#39;)</span>
        <span class="c1"># Create the figure and put it in the dock</span>
        <span class="n">functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">]</span>
        <span class="n">coherence_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coh_matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">compare_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">]</span>
            <span class="n">compare_coherence_functions</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_coh_matrix</span><span class="p">[:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">]</span>
            <span class="n">cm_increment</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cm_increment</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">plot_bits</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">plot_type_bits</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix_mode_button</span><span class="o">.</span><span class="n">isChecked</span><span class="p">():</span>
            <span class="n">rows</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">indices_to_skip</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">index</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="n">rows</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">col</span> <span class="ow">in</span> <span class="n">cols</span><span class="p">:</span>
                    <span class="c1"># print((row,col))</span>
                    <span class="c1"># print(self.plotted_function.shape)</span>
                    <span class="c1"># print(self.plotted_function[row,col])</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">plotted_function</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">]:</span>
                        <span class="n">indices_to_skip</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
                    <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">square_array_size</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">functions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
            <span class="n">nrows</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">square_array_size</span><span class="p">)</span>
            <span class="n">ncols</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">functions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">nrows</span><span class="p">))</span>
            <span class="n">indices_to_skip</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">functions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nrows</span> <span class="o">*</span> <span class="n">ncols</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># Create the canvas</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Delete the canvas if it exists</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox_layout</span><span class="o">.</span><span class="n">removeWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_canvas</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">plot_canvas</span><span class="o">.</span><span class="n">deleteLater</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># print(&#39;No Widget to Remove&#39;)</span>
            <span class="k">pass</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">plot_canvas</span> <span class="o">=</span> <span class="n">MPLMultiCanvas</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">subplots</span><span class="o">=</span><span class="p">[</span><span class="n">nrows</span><span class="p">,</span> <span class="n">ncols</span><span class="p">],</span> <span class="n">ignore_subplots</span><span class="o">=</span><span class="n">indices_to_skip</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">functions_groupbox_layout</span><span class="o">.</span><span class="n">addWidget</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_canvas</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">np</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">plot_canvas</span><span class="o">.</span><span class="n">axes</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="n">function</span> <span class="o">=</span> <span class="n">functions</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
            <span class="n">coh_function</span> <span class="o">=</span> <span class="n">coherence_functions</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">compare_function</span> <span class="o">=</span> <span class="n">compare_functions</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
                <span class="n">compare_coh_function</span> <span class="o">=</span> <span class="n">compare_coherence_functions</span><span class="p">[:,</span> <span class="n">index</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">compare_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
                <span class="n">compare_coh_function</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span>
            <span class="n">bits</span> <span class="o">=</span> <span class="p">[</span><span class="n">val</span> <span class="k">for</span> <span class="n">val</span> <span class="ow">in</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">COHERENCE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">PHASE</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                                    <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">REAL</span><span class="o">.</span><span class="n">value</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="o">.</span><span class="n">value</span><span class="p">]</span> <span class="k">if</span> <span class="nb">bool</span><span class="p">(</span><span class="n">plot_bits</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&amp;</span> <span class="n">val</span><span class="p">)]</span>
            <span class="n">plots</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">bit</span> <span class="ow">in</span> <span class="n">bits</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">bit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">MAGNITUDE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="nb">abs</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="nb">abs</span><span class="p">(</span><span class="n">compare_function</span><span class="p">),</span> <span class="mi">0</span><span class="p">,</span> <span class="s1">&#39;log&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">bit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">COHERENCE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">coh_function</span><span class="p">,</span> <span class="n">compare_coh_function</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">bit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">PHASE</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">angle</span><span class="p">(</span><span class="n">compare_function</span><span class="p">),</span> <span class="mi">2</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">bit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">REAL</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">real</span><span class="p">(</span><span class="n">compare_function</span><span class="p">),</span> <span class="mi">3</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span>
                <span class="k">elif</span> <span class="n">bit</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DataType</span><span class="o">.</span><span class="n">IMAGINARY</span><span class="o">.</span><span class="n">value</span><span class="p">:</span>
                    <span class="n">plots</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">function</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">imag</span><span class="p">(</span><span class="n">compare_function</span><span class="p">),</span> <span class="mi">4</span><span class="p">,</span> <span class="s1">&#39;linear&#39;</span><span class="p">))</span>
            <span class="c1"># Add a y axis for each plot</span>
            <span class="n">this_ax</span> <span class="o">=</span> <span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">+</span> <span class="p">[</span><span class="n">axis</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">plots</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">fn</span><span class="p">,</span> <span class="n">compare_fn</span><span class="p">,</span> <span class="n">color_index</span><span class="p">,</span> <span class="n">scale</span><span class="p">),</span> <span class="n">ax</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">plots</span><span class="p">,</span> <span class="n">this_ax</span><span class="p">):</span>
                <span class="n">color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span><span class="p">(</span><span class="n">color_index</span> <span class="o">*</span> <span class="n">cm_increment</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">fn</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">compare_matrix</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">compare_color</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cm</span><span class="p">(</span><span class="n">color_index</span> <span class="o">*</span> <span class="n">cm_increment</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">abscissa</span><span class="p">,</span> <span class="n">compare_fn</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="n">compare_color</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">set_yscale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
                <span class="n">ax</span><span class="o">.</span><span class="n">tick_params</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">colors</span><span class="o">=</span><span class="n">color</span><span class="p">)</span>
            <span class="n">index</span> <span class="o">+=</span> <span class="mi">1</span></div></div>
<span class="c1">#        self.plot_canvas.fig.tight_layout()</span>


<span class="n">frf_from_time_data</span> <span class="o">=</span> <span class="n">TransferFunctionArray</span><span class="o">.</span><span class="n">from_time_data</span>
<span class="n">join</span> <span class="o">=</span> <span class="n">NDDataArray</span><span class="o">.</span><span class="n">join</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
<jinja2.runtime.BlockReference object at 0x7f5a265a3e50>
<img src="_images/snl.jpg" alt="Sandia National Laboratories" style="height:40px">

  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>