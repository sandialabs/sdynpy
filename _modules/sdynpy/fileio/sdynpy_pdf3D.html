<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sdynpy.fileio.sdynpy_pdf3D &mdash; SDynPy 0.22.1 documentation</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
        <script src="../../../_static/sphinx_highlight.js"></script>
        <script src="../../../_static/clipboard.min.js"></script>
        <script src="../../../_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html">
            
              <img src="../../../_static/logo_horizontal_light.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../usage.html">Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../sdynpy_showcase.html">SDynPy Showcase</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../core_functionality.html">Core Functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples.html">SDynpy Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modal_tutorials.html">Modal Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../modules.html">SDynPy Programming Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">SDynPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sdynpy.fileio.sdynpy_pdf3D</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sdynpy.fileio.sdynpy_pdf3D</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Created on Wed Jan  8 11:44:09 2025</span>

<span class="sd">@author: dprohe</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..core.sdynpy_geometry</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span><span class="n">Geometry</span><span class="p">,</span><span class="n">CoordinateSystemArray</span><span class="p">,</span><span class="n">IGNORE_PLOTS</span><span class="p">,</span>
                                    <span class="n">global_coord</span><span class="p">,</span><span class="n">_beam_elem_types</span><span class="p">,</span><span class="n">_face_element_types</span><span class="p">,</span>
                                    <span class="n">_solid_element_types</span><span class="p">,</span> <span class="n">_vtk_element_map</span><span class="p">,</span>
                                    <span class="n">_element_types</span><span class="p">,</span><span class="n">split_list</span><span class="p">,</span><span class="n">GeometryPlotter</span><span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.sdynpy_shape</span><span class="w"> </span><span class="kn">import</span> <span class="n">ShapeArray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..core.sdynpy_colors</span><span class="w"> </span><span class="kn">import</span> <span class="n">colormap</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">datetime</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">pyvista</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pv</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">vtk</span><span class="w"> </span><span class="kn">import</span> <span class="n">vtkU3DExporter</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="n">vtkU3DExporter</span> <span class="o">=</span> <span class="kc">None</span>

<span class="k">def</span><span class="w"> </span><span class="nf">_create_u3d_for_animation</span><span class="p">(</span><span class="n">output_name</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span><span class="n">node_size</span> <span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">line_width</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">opacity</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
                             <span class="n">show_edges</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span><span class="kc">False</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">IGNORE_PLOTS</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot Create VTK Objects, No GPU Found&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">vtkU3DExporter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Cannot Import vtkU3DExporter.  It must first be installed with `pip install vtk-u3dexporter`&#39;</span><span class="p">)</span>
    
    <span class="c1"># Get part information</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">css</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">elems</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">element</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
    <span class="n">tls</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">traceline</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

    <span class="n">coordinate_system</span> <span class="o">=</span> <span class="n">CoordinateSystemArray</span><span class="p">(</span><span class="n">nodes</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
        <span class="n">coordinate_system</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">css</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">id</span> <span class="o">==</span> <span class="n">node</span><span class="o">.</span><span class="n">def_cs</span><span class="p">)]</span>
    <span class="n">global_node_positions</span> <span class="o">=</span> <span class="n">global_coord</span><span class="p">(</span><span class="n">coordinate_system</span><span class="p">,</span> <span class="n">nodes</span><span class="o">.</span><span class="n">coordinate</span><span class="p">)</span>
    <span class="n">node_index_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[()]:</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">()}</span>
    <span class="n">node_index_map</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vectorize</span><span class="p">(</span><span class="n">node_index_dict</span><span class="o">.</span><span class="fm">__getitem__</span><span class="p">)</span>

    <span class="c1"># Now go through and get the element and line connectivity</span>
    <span class="n">face_element_connectivity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">face_element_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">node_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">line_connectivity</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="n">line_colors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">nodes</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
        <span class="c1"># element_connectivity.append(1)</span>
        <span class="c1"># element_connectivity.append(index[0])</span>
        <span class="c1"># element_colors.append(node.color)</span>
        <span class="n">node_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">elems</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
        <span class="c1"># Check which type of element it is</span>
        <span class="k">if</span> <span class="n">element</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">_beam_elem_types</span><span class="p">:</span>  <span class="c1"># Beamlike element, use a line</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">line_connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_index_map</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">connectivity</span><span class="p">))</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s1">&#39;Element </span><span class="si">{:}</span><span class="s1"> contains a node id not found in the node array&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="n">line_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">_face_element_types</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">connectivity</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="n">face_element_connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_index_map</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">connectivity</span><span class="p">))</span>
                    <span class="n">face_element_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">face_element_connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_index_map</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
                    <span class="n">face_element_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
                    <span class="n">face_element_connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node_index_map</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">connectivity</span><span class="p">[[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">]]))</span>
                    <span class="n">face_element_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s1">&#39;Element </span><span class="si">{:}</span><span class="s1"> contains a node id not found in the node array&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">element</span><span class="o">.</span><span class="n">type</span> <span class="ow">in</span> <span class="n">_solid_element_types</span><span class="p">:</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s1">&#39;Solid Elements are currently not supported and will be skipped!&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Unknown element type </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">element</span><span class="o">.</span><span class="n">type</span><span class="p">))</span>

    <span class="k">for</span> <span class="n">index</span><span class="p">,</span> <span class="n">tl</span> <span class="ow">in</span> <span class="n">tls</span><span class="o">.</span><span class="n">ndenumerate</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">conn_group</span> <span class="ow">in</span> <span class="n">split_list</span><span class="p">(</span><span class="n">tl</span><span class="o">.</span><span class="n">connectivity</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">conn_group</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">mapped_conn_group</span> <span class="o">=</span> <span class="n">node_index_map</span><span class="p">(</span><span class="n">conn_group</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">KeyError</span><span class="p">(</span>
                    <span class="s1">&#39;Traceline </span><span class="si">{:}</span><span class="s1"> contains a node id not found in the node array&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">tl</span><span class="o">.</span><span class="n">id</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">mapped_conn_group</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span><span class="n">mapped_conn_group</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">line_connectivity</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>
                <span class="n">line_colors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">tl</span><span class="o">.</span><span class="n">color</span><span class="p">)</span>

    <span class="c1"># Now we start to plot</span>
    <span class="n">plotter</span> <span class="o">=</span> <span class="n">GeometryPlotter</span><span class="p">(</span><span class="n">editor</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
    <span class="n">face_map</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">conn</span><span class="p">,</span><span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">face_element_connectivity</span><span class="p">,</span><span class="n">face_element_colors</span><span class="p">):</span>
        <span class="n">node_indices</span><span class="p">,</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">node_positions</span> <span class="o">=</span> <span class="n">global_node_positions</span><span class="p">[</span><span class="n">node_indices</span><span class="p">][</span><span class="n">inverse</span><span class="p">]</span>
        <span class="n">node_connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">node_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">node_positions</span><span class="p">,</span><span class="n">faces</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node_connectivity</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node_connectivity</span><span class="p">])</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">SetObjectName</span><span class="p">(</span><span class="s1">&#39;Elem: </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]))</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">scalars</span><span class="o">=</span><span class="s1">&#39;color&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span> <span class="n">clim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">],</span>
                         <span class="n">show_edges</span><span class="o">=</span><span class="n">show_edges</span><span class="p">,</span> <span class="n">show_scalar_bar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span><span class="p">,</span><span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Elem: </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]))</span>
        <span class="n">face_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">inverse</span><span class="p">]])</span>

    <span class="n">line_map</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">conn</span><span class="p">,</span><span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">line_connectivity</span><span class="p">,</span><span class="n">line_colors</span><span class="p">):</span>
        <span class="n">node_indices</span><span class="p">,</span><span class="n">inverse</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">conn</span><span class="p">,</span><span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">node_positions</span> <span class="o">=</span> <span class="n">global_node_positions</span><span class="p">[</span><span class="n">node_indices</span><span class="p">][</span><span class="n">inverse</span><span class="p">]</span>
        <span class="n">node_connectivity</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">node_positions</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">node_positions</span><span class="p">,</span><span class="n">lines</span><span class="o">=</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">node_connectivity</span><span class="p">)]</span><span class="o">+</span><span class="p">[</span><span class="n">c</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">node_connectivity</span><span class="p">])</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
        <span class="n">mesh</span><span class="o">.</span><span class="n">SetObjectName</span><span class="p">(</span><span class="s1">&#39;Line: </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]))</span>
        <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span><span class="n">scalars</span><span class="o">=</span><span class="s1">&#39;color&#39;</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span> <span class="n">clim</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">],</span>
                         <span class="n">show_edges</span><span class="o">=</span><span class="n">show_edges</span><span class="p">,</span> <span class="n">show_scalar_bar</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">line_width</span><span class="o">=</span><span class="n">line_width</span><span class="p">,</span><span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">,</span><span class="n">label</span><span class="o">=</span><span class="s1">&#39;Line: </span><span class="si">{:}</span><span class="s1"> </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">inverse</span><span class="p">]]))</span>
        <span class="n">line_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">[</span><span class="n">node_indices</span><span class="p">[</span><span class="n">inverse</span><span class="p">]])</span>
    
    <span class="n">point_map</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">position</span><span class="p">,</span><span class="n">color</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="n">global_node_positions</span><span class="p">,</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">color</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">mesh</span> <span class="o">=</span> <span class="n">pv</span><span class="o">.</span><span class="n">PolyData</span><span class="p">(</span><span class="n">position</span><span class="p">)</span>
            <span class="n">mesh</span><span class="o">.</span><span class="n">cell_data</span><span class="p">[</span><span class="s1">&#39;color&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span>
            <span class="n">plotter</span><span class="o">.</span><span class="n">add_mesh</span><span class="p">(</span><span class="n">mesh</span><span class="p">,</span> <span class="n">scalars</span> <span class="o">=</span> <span class="n">color</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">colormap</span><span class="p">,</span> <span class="n">clim</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">15</span><span class="p">],</span>
                             <span class="n">show_edges</span><span class="o">=</span><span class="n">show_edges</span><span class="p">,</span> <span class="n">show_scalar_bar</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">point_size</span><span class="o">=</span><span class="n">node_size</span><span class="p">,</span>
                             <span class="n">opacity</span><span class="o">=</span><span class="n">opacity</span><span class="p">)</span>
            <span class="n">point_map</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        
    <span class="n">exporter</span> <span class="o">=</span> <span class="n">vtkU3DExporter</span><span class="o">.</span><span class="n">vtkU3DExporter</span><span class="p">()</span>
    <span class="n">exporter</span><span class="o">.</span><span class="n">SetFileName</span><span class="p">(</span><span class="n">output_name</span><span class="p">)</span>
    <span class="n">exporter</span><span class="o">.</span><span class="n">SetInput</span><span class="p">(</span><span class="n">plotter</span><span class="o">.</span><span class="n">render_window</span><span class="p">)</span>
    <span class="n">exporter</span><span class="o">.</span><span class="n">Write</span><span class="p">()</span>
    
    <span class="n">plotter</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="n">face_map</span><span class="p">,</span> <span class="n">line_map</span><span class="p">,</span> <span class="n">point_map</span>

<div class="viewcode-block" id="create_animated_modeshape_content"><a class="viewcode-back" href="../../../_autosummary/sdynpy.fileio.sdynpy_pdf3D.create_animated_modeshape_content.html#sdynpy.fileio.sdynpy_pdf3D.create_animated_modeshape_content">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">create_animated_modeshape_content</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span><span class="n">shapes</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span><span class="n">u3d_name</span><span class="o">=</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span>
                                      <span class="n">js_name</span> <span class="o">=</span> <span class="s1">&#39;mode_shapes.js&#39;</span><span class="p">,</span><span class="n">one_js</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                                      <span class="n">node_size</span> <span class="o">=</span> <span class="mi">5</span><span class="p">,</span> <span class="n">line_width</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
                                      <span class="n">opacity</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">show_edges</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                                      <span class="n">debug_js</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">displacement_scale</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Creates files that can be embedded into a PDF to create interactive content</span>
<span class="sd">    </span>
<span class="sd">    This function produces a Universal3D model containing Geometry information.</span>
<span class="sd">    This function also produces one or more JavaScript programs that are used</span>
<span class="sd">    by the PDF to animate the model data.  The model and programs can be</span>
<span class="sd">    embedded into a PDF either by using Adobe Acrobat Professional, or by using</span>
<span class="sd">    LaTeX with the media9 package to build a PDF document.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geometry : Geometry</span>
<span class="sd">        A SDynPy Geometry object that will be exported to Universal3D format.</span>
<span class="sd">    shapes : ShapeArray, optional</span>
<span class="sd">        A SDynPy ShapeArray object that contains the mode shapes that will be</span>
<span class="sd">        used to animate the model in the final PDF.  If not specified, only the</span>
<span class="sd">        geometry will be exported.</span>
<span class="sd">    u3d_name : str, optional</span>
<span class="sd">        The file path and name of the Universal3D file that will be created</span>
<span class="sd">        from the SDynPy Geometry.  Note that the .u3d extension will be</span>
<span class="sd">        automatically appended to the file path. The default is &#39;geometry&#39;.</span>
<span class="sd">    js_name : str, optional</span>
<span class="sd">        The file path and name of the JavaScript file(s) that will be created</span>
<span class="sd">        from the geometry and shape information.  The final file name will be</span>
<span class="sd">        constructed from the code `js_name.format(i+1)` where `i` is the shape</span>
<span class="sd">        index.  This allows for a different file name to be produced for each</span>
<span class="sd">        mode if `one_js` is `False`. The default is &#39;mode_shapes.js&#39;.</span>
<span class="sd">    one_js : bool, optional</span>
<span class="sd">        If True, only one JavaScript file will be produced containing all mode</span>
<span class="sd">        shape information.  If False, one JavaScript file will be produced per</span>
<span class="sd">        mode in the `shapes` argument, with each script having that shape as</span>
<span class="sd">        shape that is plotted first.  Even if `one_js` is False, all JavaScript</span>
<span class="sd">        programs will have all modes in them. The default is True.</span>
<span class="sd">    node_size : int, optional</span>
<span class="sd">        The size of the rendered node in pixels. The default is 5.</span>
<span class="sd">    line_width : int, optional</span>
<span class="sd">        The width of lines rendered in the model. The default is 2.  Note that</span>
<span class="sd">        lines with a width of 1 may not show their color well in the final PDF.</span>
<span class="sd">    opacity : float, optional</span>
<span class="sd">        The opacity of the model, from 0 (transparent) to 1 (opaque). The</span>
<span class="sd">        default is 1.</span>
<span class="sd">    show_edges : bool, optional</span>
<span class="sd">        If True, edges will be drawn on element faces. The default is False.</span>
<span class="sd">    debug_js : bool or str, optional</span>
<span class="sd">        If True, the JavaScript programs will have various print statements</span>
<span class="sd">        enabled to help users debug.  If False, these will be commented out.</span>
<span class="sd">        String values of &#39;map&#39;, &#39;point&#39;, &#39;line&#39;, or &#39;face&#39; can also be specified</span>
<span class="sd">        to only print debug text for those operations. The default is False.</span>
<span class="sd">    displacement_scale : float, optional</span>
<span class="sd">        A scale factor applied to the shape displacements to achieve a</span>
<span class="sd">        reasonable deflection size. The default is 1.0.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    There is no support currently for Solid elements (e.g. tets or hexes).</span>
<span class="sd">    Only surface elements (tris and quads), lines (beam elements or tracelines),</span>
<span class="sd">    and points (nodes) are currently supported.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    None.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">face_map</span><span class="p">,</span> <span class="n">line_map</span><span class="p">,</span> <span class="n">point_map</span> <span class="o">=</span> <span class="n">_create_u3d_for_animation</span><span class="p">(</span><span class="n">u3d_name</span><span class="p">,</span>
                                                              <span class="n">geometry</span><span class="p">,</span> 
                                                              <span class="n">node_size</span><span class="p">,</span>
                                                              <span class="n">line_width</span><span class="p">,</span>
                                                              <span class="n">opacity</span><span class="p">,</span>
                                                              <span class="n">show_edges</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">shapes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>
    
    <span class="c1"># Need to get the shape information in the global coordinate system</span>
    <span class="n">node_displacement_dict</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">:</span>
        <span class="n">node_displacement_dict</span><span class="p">[</span><span class="n">node_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">shapes</span><span class="o">.</span><span class="n">size</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">shape_index</span><span class="p">,</span><span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
            <span class="n">coords</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">coordinate</span><span class="p">[(</span><span class="n">shape</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">node</span> <span class="o">==</span> <span class="n">node_id</span><span class="p">)</span> <span class="o">&amp;</span> <span class="n">np</span><span class="o">.</span><span class="n">in1d</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">shape</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">direction</span><span class="p">),[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">])])</span>
            <span class="n">shape_data</span> <span class="o">=</span> <span class="n">shape</span><span class="p">[</span><span class="n">coords</span><span class="p">]</span>
            <span class="n">coord_directions</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">global_deflection</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>
            <span class="n">global_deflection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">shape_data</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">coord_directions</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">node_displacement_dict</span><span class="p">[</span><span class="n">node_id</span><span class="p">][</span><span class="n">shape_index</span><span class="p">]</span> <span class="o">=</span> <span class="n">global_deflection</span>
    
    <span class="n">node_position_dict</span> <span class="o">=</span> <span class="p">{</span><span class="n">node_id</span><span class="p">:</span><span class="n">position</span> <span class="k">for</span> <span class="n">node_id</span><span class="p">,</span><span class="n">position</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">,</span><span class="n">geometry</span><span class="o">.</span><span class="n">global_node_coordinate</span><span class="p">())}</span>
    
    <span class="k">if</span> <span class="n">one_js</span><span class="p">:</span>
        <span class="n">js_indices</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">js_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
    
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">js_indices</span><span class="p">:</span>
        <span class="n">js_output_name</span> <span class="o">=</span> <span class="n">js_name</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">js_output_name</span><span class="p">,</span><span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;//Written by sdynpy_pdf3D.py on {date:}</span>
<span class="sd">    </span>
<span class="sd">    function pause(){{if(speed)lastspeed=speed; speed=0;}}</span>
<span class="sd">    function play(){{speed=lastspeed;}}</span>
<span class="sd">    function scaleSpeed(s){{lastspeed*=s; if(speed) speed=lastspeed;}}</span>
<span class="sd">    function scale(s){{scale*=s;}}</span>
<span class="sd">    </span>
<span class="sd">    var omega0=Math.PI; // init. angular frequency (half turn per second)</span>
<span class="sd">    var speed=1;        // speed multiplier</span>
<span class="sd">    var lastspeed=1;</span>
<span class="sd">    var theta=0;</span>
<span class="sd">    var scale={displacement_scale:};</span>
<span class="sd">    var shape={shape:};</span>
<span class="sd">    var num_shapes = {num_shapes:};</span>
<span class="sd">    var panel = 1</span>
<span class="sd">    var node_positions = {{}};</span>
<span class="sd">    var node_displacements = {{}};</span>
<span class="sd">    </span>
<span class="sd">    // Node and Shape Information</span>
<span class="sd">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">date</span><span class="o">=</span><span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="o">.</span><span class="n">now</span><span class="p">(),</span>
           <span class="n">shape</span><span class="o">=</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
           <span class="n">num_shapes</span><span class="o">=</span><span class="n">shapes</span><span class="o">.</span><span class="n">size</span><span class="p">,</span>
           <span class="n">displacement_scale</span><span class="o">=</span><span class="n">displacement_scale</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">node_id</span> <span class="ow">in</span> <span class="n">node_position_dict</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">node_positions[</span><span class="si">{:}</span><span class="s1">] = Vector3(</span><span class="si">{:}</span><span class="s1">,</span><span class="si">{:}</span><span class="s1">,</span><span class="si">{:}</span><span class="s1">);</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_id</span><span class="p">,</span><span class="o">*</span><span class="n">node_position_dict</span><span class="p">[</span><span class="n">node_id</span><span class="p">]))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;node_displacements[</span><span class="si">{:}</span><span class="s1">] = [</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node_id</span><span class="p">))</span>
                <span class="k">for</span> <span class="n">shape_vector</span> <span class="ow">in</span> <span class="n">node_displacement_dict</span><span class="p">[</span><span class="n">node_id</span><span class="p">]:</span>
                    <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    Vector3(</span><span class="si">{:}</span><span class="s1">,</span><span class="si">{:}</span><span class="s1">,</span><span class="si">{:}</span><span class="s1">),</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">shape_vector</span><span class="p">))</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;  ];</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">// Frequency Information</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;var mode_frequencies = [];</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span><span class="n">shape</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="o">.</span><span class="n">flatten</span><span class="p">()):</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;mode_frequencies[</span><span class="si">{:}</span><span class="s1">] = </span><span class="si">{:0.2f}</span><span class="s1">;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="n">shape</span><span class="o">.</span><span class="n">frequency</span><span class="p">))</span>
            <span class="c1"># Now we need to go through and collect the node information and</span>
            <span class="c1"># Map it back to node id numbers</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">// Connectivity Maps</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;face_map = [</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">face</span> <span class="ow">in</span> <span class="n">face_map</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;   </span><span class="si">{:}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">face</span><span class="p">))))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ];</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;line_map = [</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">line_map</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;   </span><span class="si">{:}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">line</span><span class="p">))))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ];</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;point_map = [</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">point</span> <span class="ow">in</span> <span class="n">point_map</span><span class="p">:</span>
                <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;   </span><span class="si">{:}</span><span class="s1">,</span><span class="se">\n</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">point</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;    ];</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    var scene = this.scene;</span>
<span class="s2">    var face_nodes = [];</span>
<span class="s2">    var line_nodes = [];</span>
<span class="s2">    var point_nodes = [];</span>
<span class="s2">    for (i=0; i &lt; scene.nodes.count; i++){{</span>
<span class="s2">        name = scene.nodes.getByIndex(i).name</span>
<span class="s2">        if (name.slice(0,4) === &quot;Mesh&quot;){{</span>
<span class="s2">            </span><span class="si">{debug:}</span><span class="s2">host.console.println(&quot;Mesh found at node &quot;+i+&quot; &quot;+ name)</span>
<span class="s2">            face_nodes.push(i);</span>
<span class="s2">        }} else if (name.slice(0,4) === &quot;Line&quot;){{</span>
<span class="s2">            </span><span class="si">{debug:}</span><span class="s2">host.console.println(&quot;Line found at node &quot;+i+&quot; &quot;+ name)</span>
<span class="s2">            line_nodes.push(i);</span>
<span class="s2">        }} else if (name.slice(0,4) === &quot;Poin&quot;){{</span>
<span class="s2">            </span><span class="si">{debug:}</span><span class="s2">host.console.println(&quot;Point found at node &quot;+i+&quot; &quot;+ name)</span>
<span class="s2">            point_nodes.push(i);</span>
<span class="s2">        }} else {{</span>
<span class="s2">            </span><span class="si">{debug:}</span><span class="s2">host.console.println(&quot;Unknown node &quot;+i+&quot; &quot;+name)</span>
<span class="s2">        }}</span>
<span class="s2">    }}</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">debug_js</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">debug_js</span><span class="o">==</span><span class="s1">&#39;map&#39;</span> <span class="k">else</span> <span class="s1">&#39;// &#39;</span><span class="p">))</span>

<span class="c1"># Now we need to go through and apply displacements</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    // Translate Nodes</span>
<span class="s1">    for (i=0; i &lt; point_nodes.length; i++){{</span>
<span class="s1">        geometry_node_id = point_map[i];</span>
<span class="s1">        model_node = scene.nodes.getByIndex(point_nodes[i]);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;Point Index &quot;+i+&quot; corresponds to model node &quot;+model_node.name+&quot; and geometry node id &quot;+geometry_node_id);</span>
<span class="s1">        model_node.transform.setIdentity();</span>
<span class="s1">        model_node.transform.translateInPlace(node_displacements[geometry_node_id][shape-1].scale(scale));</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString()+&quot;</span><span class="se">\\</span><span class="s1">n&quot;)</span>
<span class="s1">    }}&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">debug_js</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">debug_js</span><span class="o">==</span><span class="s1">&#39;point&#39;</span> <span class="k">else</span> <span class="s1">&#39;// &#39;</span><span class="p">))</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    // Translate Lines</span>
<span class="s1">    </span>
<span class="s1">    // Computation variables</span>
<span class="s1">    var p1;    // position of node 1</span>
<span class="s1">    var p2;    // position of node 2</span>
<span class="s1">    var d1;    // displacement of node 1</span>
<span class="s1">    var d2;    // displacement of node 2</span>
<span class="s1">    var v1;    // traceline vector from p1 to p2 (p2-p1)</span>
<span class="s1">    var v2;    // traceline vector after modification ((d2+p2)-(d1+p1))</span>
<span class="s1">    var vc1;   // traceline center ((p2+p1)/2)</span>
<span class="s1">    var vc2;   // traceline center after modification ((p2+d2+p1+d1)/2)</span>
<span class="s1">    var axis;  // axis of rotation v1 x v2 unit vector</span>
<span class="s1">    var angle; // angle of rotation cos(angle) = v1.v2/(|v1||v2|)</span>
<span class="s1">    var c;     // scale factor |v2|/|v1|</span>
<span class="s1">    var t;     // translate vc2 - c*vc1</span>
<span class="s1">    </span>
<span class="s1">    // Go through traceline nodes</span>
<span class="s1">    for (i=0; i &lt; line_nodes.length; i++){{</span>
<span class="s1">        model_node = scene.nodes.getByIndex(line_nodes[i]);</span>
<span class="s1">        geometry_node_ids = line_map[i];</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;Line Index &quot;+i+&quot; corresponds to model node &quot;+model_node.name+&quot; and geometry node ids &quot;+geometry_node_ids);</span>
<span class="s1">        model_node.transform.setIdentity();</span>
<span class="s1">        p1 = node_positions[geometry_node_ids[0]];</span>
<span class="s1">        p2 = node_positions[geometry_node_ids[1]];</span>
<span class="s1">        d1 = node_displacements[geometry_node_ids[0]][shape-1].scale(scale);</span>
<span class="s1">        d2 = node_displacements[geometry_node_ids[1]][shape-1].scale(scale);</span>
<span class="s1">        v1 = p2.add(p1.scale(-1));</span>
<span class="s1">        v2 = p2.add(d2).add(p1.add(d1).scale(-1));</span>
<span class="s1">        vc1 = p2.add(p1).scale(0.5);</span>
<span class="s1">        vc2 = p2.add(d2).add(p1).add(d1).scale(0.5);</span>
<span class="s1">        axis = v1.cross(v2);</span>
<span class="s1">        angle = Math.acos(v1.dot(v2)/(Math.sqrt(v1.dot(v1))*Math.sqrt(v2.dot(v2))));</span>
<span class="s1">        c = Math.sqrt(v2.dot(v2)/v1.dot(v1));</span>
<span class="s1">        t = vc2.add(vc1.scale(-c));</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;Transforming TL: &quot;+geometry_node_ids);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  p1: &quot;+p1)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  p2: &quot;+p2)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  d1: &quot;+d1)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  d2: &quot;+d2)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  v1: &quot;+v1)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  v2: &quot;+v2)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  vc1: &quot;+vc1)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  vc2: &quot;+vc2)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  axis: &quot;+axis)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  angle: &quot;+angle)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  c: &quot;+c)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  t: &quot;+t)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform prior to anything:&quot;)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString())</span>
<span class="s1">        //model_node.transform.rotateAboutLineInPlace(angle,vc1,vc1.add(axis)); //There seems to be a bug with this command...</span>
<span class="s1">        model_node.transform.translateInPlace(vc1.scale(-1));</span>
<span class="s1">        model_node.transform.rotateAboutVectorInPlace(angle,axis);</span>
<span class="s1">        model_node.transform.translateInPlace(vc1);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after rotation:&quot;)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString())</span>
<span class="s1">        model_node.transform.scaleInPlace(c,c,c);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after scaling:&quot;)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString())</span>
<span class="s1">        model_node.transform.translateInPlace(t);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after translation:&quot;)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString())</span>
<span class="s1">    }}&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">debug_js</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">debug_js</span><span class="o">==</span><span class="s1">&#39;line&#39;</span> <span class="k">else</span> <span class="s1">&#39;// &#39;</span><span class="p">))</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    // We want to compute the SVD of the transformation, so we will define a number of functions here</span>
<span class="s1">    var _gamma = 5.828427124;</span>
<span class="s1">    var _cstar = 0.923879532;</span>
<span class="s1">    var _sstar = 0.3826834323;</span>
<span class="s1">    var EPSILON = 1e-6;</span>
<span class="s1">    </span>
<span class="s1">    function condSwap(c, X, Y)</span>
<span class="s1">    {</span>
<span class="s1">        // used in step 2</span>
<span class="s1">        // var Z = X;</span>
<span class="s1">        // X = c ? Y : X;</span>
<span class="s1">        // Y = c ? Z : Y;</span>
<span class="s1">        return (c ? [Y,X] : [X,Y])</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function condNegSwap(c, X, Y)</span>
<span class="s1">    {</span>
<span class="s1">        // used in step 2 and 3</span>
<span class="s1">        // var Z = -X;</span>
<span class="s1">        // X = c ? Y : X;</span>
<span class="s1">        // Y = c ? Z : Y;</span>
<span class="s1">        return (c ? [Y,-X] : [X,Y])</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    // matrix multiplication M = A * B</span>
<span class="s1">    function multAB(a11, a12, a13,a21, a22, a23, a31, a32, a33, b11, b12, b13, b21, b22, b23, b31, b32, b33)</span>
<span class="s1">    {</span>
<span class="s1">        var m11=a11*b11 + a12*b21 + a13*b31; var m12=a11*b12 + a12*b22 + a13*b32; var m13=a11*b13 + a12*b23 + a13*b33;</span>
<span class="s1">        var m21=a21*b11 + a22*b21 + a23*b31; var m22=a21*b12 + a22*b22 + a23*b32; var m23=a21*b13 + a22*b23 + a23*b33;</span>
<span class="s1">        var m31=a31*b11 + a32*b21 + a33*b31; var m32=a31*b12 + a32*b22 + a33*b32; var m33=a31*b13 + a32*b23 + a33*b33;</span>
<span class="s1">        return [m11,m12,m13,m21,m22,m23,m31,m32,m33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    // matrix multiplication M = Transpose[A] * B</span>
<span class="s1">    function multAtB(a11, a12, a13,</span>
<span class="s1">                        a21, a22, a23,</span>
<span class="s1">                        a31, a32, a33,</span>
<span class="s1">                        b11, b12, b13,</span>
<span class="s1">                        b21, b22, b23,</span>
<span class="s1">                        b31, b32, b33)</span>
<span class="s1">    {</span>
<span class="s1">      var m11=a11*b11 + a21*b21 + a31*b31; var m12=a11*b12 + a21*b22 + a31*b32; var m13=a11*b13 + a21*b23 + a31*b33;</span>
<span class="s1">      var m21=a12*b11 + a22*b21 + a32*b31; var m22=a12*b12 + a22*b22 + a32*b32; var m23=a12*b13 + a22*b23 + a32*b33;</span>
<span class="s1">      var m31=a13*b11 + a23*b21 + a33*b31; var m32=a13*b12 + a23*b22 + a33*b32; var m33=a13*b13 + a23*b23 + a33*b33;</span>
<span class="s1">      return [m11,m12,m13,m21,m22,m23,m31,m32,m33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function quatToMat3(x,y,z,w)</span>
<span class="s1">    {</span>
<span class="s1">    	var qxx = x*x;</span>
<span class="s1">    	var qyy = y*y;</span>
<span class="s1">    	var qzz = z*z;</span>
<span class="s1">    	var qxz = x*z;</span>
<span class="s1">    	var qxy = x*y;</span>
<span class="s1">    	var qyz = y*z;</span>
<span class="s1">    	var qwx = w*x;</span>
<span class="s1">    	var qwy = w*y;</span>
<span class="s1">    	var qwz = w*z;</span>
<span class="s1">    </span>
<span class="s1">    	var m11=1 - 2*(qyy + qzz); var m12=2*(qxy - qwz); var m13=2*(qxz + qwy);</span>
<span class="s1">        var m21=2*(qxy + qwz); var m22=1 - 2*(qxx + qzz); var m23=2*(qyz - qwx);</span>
<span class="s1">        var m31=2*(qxz - qwy); var m32=2*(qyz + qwx); var m33=1 - 2*(qxx + qyy);</span>
<span class="s1">        return [m11,m12,m13,m21,m22,m23,m31,m32,m33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function approximateGivensQuaternion(a11, a12, a22)</span>
<span class="s1">    {</span>
<span class="s1">    /*</span>
<span class="s1">         * Given givens angle computed by approximateGivensAngles,</span>
<span class="s1">         * compute the corresponding rotation quaternion.</span>
<span class="s1">         */</span>
<span class="s1">        var ch = 2*(a11-a22);</span>
<span class="s1">        var sh = a12;</span>
<span class="s1">        var b = _gamma*sh*sh &lt; ch*ch;</span>
<span class="s1">        var w = 1/Math.sqrt(ch*ch+sh*sh);</span>
<span class="s1">        ch=b?w*ch:_cstar;</span>
<span class="s1">        sh=b?w*sh:_sstar;</span>
<span class="s1">        return [ch,sh]</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function jacobiConjugation(x, y, z, s11, s21, s22, s31, s32, s33, qV)</span>
<span class="s1">    {</span>
<span class="s1">        var return_val = approximateGivensQuaternion(s11,s21,s22);</span>
<span class="s1">        var ch = return_val[0];</span>
<span class="s1">        var sh = return_val[1];</span>
<span class="s1">    </span>
<span class="s1">    	var  scale = ch*ch+sh*sh;</span>
<span class="s1">        var a = (ch*ch-sh*sh)/scale;</span>
<span class="s1">        var b = (2*sh*ch)/scale;</span>
<span class="s1">    </span>
<span class="s1">        // make temp copy of S</span>
<span class="s1">        var _s11 = s11;</span>
<span class="s1">    	var _s21 = s21; var _s22 = s22;</span>
<span class="s1">    	var _s31 = s31; var _s32 = s32; var _s33 = s33;</span>
<span class="s1">    </span>
<span class="s1">    	// perform conjugation S = Q&#39;&#39;*S*Q</span>
<span class="s1">    	// Q already implicitly solved from a, b</span>
<span class="s1">        s11 = a*(a*_s11 + b*_s21) + b*(a*_s21 + b*_s22);</span>
<span class="s1">        s21 = a*(-b*_s11 + a*_s21) + b*(-b*_s21 + a*_s22);	s22=-b*(-b*_s11 + a*_s21) + a*(-b*_s21 + a*_s22);</span>
<span class="s1">        s31 = a*_s31 + b*_s32;								s32=-b*_s31 + a*_s32; s33=_s33;</span>
<span class="s1">    </span>
<span class="s1">    	// update cumulative rotation qV</span>
<span class="s1">        var tmp = [];</span>
<span class="s1">        tmp[0]=qV[0]*sh;</span>
<span class="s1">        tmp[1]=qV[1]*sh;</span>
<span class="s1">        tmp[2]=qV[2]*sh;</span>
<span class="s1">        sh *= qV[3];</span>
<span class="s1">    </span>
<span class="s1">        qV[0] *= ch;</span>
<span class="s1">        qV[1] *= ch;</span>
<span class="s1">        qV[2] *= ch;</span>
<span class="s1">        qV[3] *= ch;</span>
<span class="s1">    </span>
<span class="s1">        // (x,y,z) corresponds to ((0,1,2),(1,2,0),(2,0,1))</span>
<span class="s1">        // for (p,q) = ((0,1),(1,2),(0,2))</span>
<span class="s1">        qV[z] += sh;</span>
<span class="s1">        qV[3] -= tmp[z]; // w</span>
<span class="s1">        qV[x] += tmp[y];</span>
<span class="s1">        qV[y] -= tmp[x];</span>
<span class="s1">    </span>
<span class="s1">        // re-arrange matrix for next iteration</span>
<span class="s1">        _s11 = s22;</span>
<span class="s1">    	_s21 = s32; _s22 = s33;</span>
<span class="s1">    	_s31 = s21; _s32 = s31; _s33 = s11;</span>
<span class="s1">    	s11 = _s11;</span>
<span class="s1">    	s21 = _s21; s22 = _s22;</span>
<span class="s1">    	s31 = _s31; s32 = _s32; s33 = _s33;</span>
<span class="s1">        </span>
<span class="s1">        return [s11,s21,s22,s31,s32,s33,qV]</span>
<span class="s1">    </span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function dist2(x, y, z)</span>
<span class="s1">    {</span>
<span class="s1">        return x*x+y*y+z*z;</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function jacobiEigenanlysis(s11,s21,s22,s31,s32,s33)</span>
<span class="s1">    {</span>
<span class="s1">        var return_val;</span>
<span class="s1">        var qV = []</span>
<span class="s1">        qV[3]=1; qV[0]=0;qV[1]=0;qV[2]=0; // follow same indexing convention as GLM</span>
<span class="s1">        for (var i=0;i&lt;4;i++)</span>
<span class="s1">    	{</span>
<span class="s1">    		// we wish to eliminate the maximum off-diagonal element</span>
<span class="s1">            // on every iteration, but cycling over all 3 possible rotations</span>
<span class="s1">            // in fixed order (p,q) = (1,2) , (2,3), (1,3) still retains</span>
<span class="s1">            //  asymptotic convergence</span>
<span class="s1">            return_val = jacobiConjugation(0,1,2,s11,s21,s22,s31,s32,s33,qV); // p,q = 0,1</span>
<span class="s1">            s11 = return_val[0]; s21 = return_val[1]; s22 = return_val[2]; s31 = return_val[3];</span>
<span class="s1">            s32 = return_val[4]; s33 = return_val[5]; qV = return_val[6];</span>
<span class="s1">            return_val = jacobiConjugation(1,2,0,s11,s21,s22,s31,s32,s33,qV); // p,q = 1,2</span>
<span class="s1">            s11 = return_val[0]; s21 = return_val[1]; s22 = return_val[2]; s31 = return_val[3];</span>
<span class="s1">            s32 = return_val[4]; s33 = return_val[5]; qV = return_val[6];</span>
<span class="s1">            return_val = jacobiConjugation(2,0,1,s11,s21,s22,s31,s32,s33,qV); // p,q = 0,2</span>
<span class="s1">            s11 = return_val[0]; s21 = return_val[1]; s22 = return_val[2]; s31 = return_val[3];</span>
<span class="s1">            s32 = return_val[4]; s33 = return_val[5]; qV = return_val[6];</span>
<span class="s1">    	}</span>
<span class="s1">        return [s11,s21,s22,s31,s32,s33,qV]</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function sortSingularValues(b11, b12, b13,</span>
<span class="s1">    							b21, b22, b23,</span>
<span class="s1">    							b31, b32, b33,</span>
<span class="s1">    							v11, v12, v13,</span>
<span class="s1">    							v21, v22, v23,</span>
<span class="s1">                                v31, v32, v33)</span>
<span class="s1">    {</span>
<span class="s1">        var return_val;</span>
<span class="s1">        var rho1 = dist2(b11,b21,b31);</span>
<span class="s1">        var rho2 = dist2(b12,b22,b32);</span>
<span class="s1">        var rho3 = dist2(b13,b23,b33);</span>
<span class="s1">    	var c;</span>
<span class="s1">        c = rho1 &lt; rho2;</span>
<span class="s1">        return_val = condNegSwap(c,b11,b12);</span>
<span class="s1">        b11 = return_val[0]; b12 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,v11,v12);</span>
<span class="s1">        v11 = return_val[0]; v12 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,b21,b22); </span>
<span class="s1">        b21 = return_val[0]; b22 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,v21,v22); </span>
<span class="s1">        v21 = return_val[0]; v22 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,b31,b32); </span>
<span class="s1">        b31 = return_val[0]; b32 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,v31,v32); </span>
<span class="s1">        v31 = return_val[0]; v32 = return_val[1];</span>
<span class="s1">        return_val = condSwap(c,rho1,rho2); </span>
<span class="s1">        rho1 = return_val[0]; rho2 = return_val[1];</span>
<span class="s1">        c = rho1 &lt; rho3;</span>
<span class="s1">        return_val = condNegSwap(c,b11,b13); </span>
<span class="s1">        b11 = return_val[0]; b13 = return_val[1]; </span>
<span class="s1">        return_val = condNegSwap(c,v11,v13); </span>
<span class="s1">        v11 = return_val[0]; v13 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,b21,b23); </span>
<span class="s1">        b21 = return_val[0]; b23 = return_val[1]; </span>
<span class="s1">        return_val = condNegSwap(c,v21,v23); </span>
<span class="s1">        v21 = return_val[0]; v23 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,b31,b33); </span>
<span class="s1">        b31 = return_val[0]; b33 = return_val[1]; </span>
<span class="s1">        return_val = condNegSwap(c,v31,v33); </span>
<span class="s1">        v31 = return_val[0]; v33 = return_val[1];</span>
<span class="s1">        return_val = condSwap(c,rho1,rho3); </span>
<span class="s1">        rho1 = return_val[0]; rho3 = return_val[1];</span>
<span class="s1">        c = rho2 &lt; rho3;</span>
<span class="s1">        return_val = condNegSwap(c,b12,b13); </span>
<span class="s1">        b12 = return_val[0]; b13 = return_val[1]; </span>
<span class="s1">        return_val = condNegSwap(c,v12,v13); </span>
<span class="s1">        v12 = return_val[0]; v13 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,b22,b23); </span>
<span class="s1">        b22 = return_val[0]; b23 = return_val[1]; </span>
<span class="s1">        return_val = condNegSwap(c,v22,v23); </span>
<span class="s1">        v22 = return_val[0]; v23 = return_val[1];</span>
<span class="s1">        return_val = condNegSwap(c,b32,b33); </span>
<span class="s1">        b32 = return_val[0]; b33 = return_val[1]; </span>
<span class="s1">        return_val = condNegSwap(c,v32,v33); </span>
<span class="s1">        v32 = return_val[0]; v33 = return_val[1];</span>
<span class="s1">        return [b11, b12, b13, b21, b22, b23, b31, b32, b33, v11, v12, v13, v21, v22, v23, v31, v32, v33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function QRGivensQuaternion(a1, a2)</span>
<span class="s1">    {</span>
<span class="s1">        // a1 = pivot point on diagonal</span>
<span class="s1">        // a2 = lower triangular entry we want to annihilate</span>
<span class="s1">        var rho = Math.sqrt(a1*a1 + a2*a2);</span>
<span class="s1">    </span>
<span class="s1">        var sh = rho &gt; EPSILON ? a2 : 0;</span>
<span class="s1">        var ch = Math.abs(a1) + Math.max(rho,EPSILON);</span>
<span class="s1">        var b = a1 &lt; 0;</span>
<span class="s1">        var return_val = condSwap(b,sh,ch);</span>
<span class="s1">        sh = return_val[0]; ch = return_val[1];</span>
<span class="s1">        var w = 1/Math.sqrt(ch*ch+sh*sh);</span>
<span class="s1">        ch *= w;</span>
<span class="s1">        sh *= w;</span>
<span class="s1">        return [ch,sh];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function QRDecomposition(b11, b12, b13,</span>
<span class="s1">    							b21, b22, b23,</span>
<span class="s1">    							b31, b32, b33)</span>
<span class="s1">    {    </span>
<span class="s1">        var ch1,sh1,ch2,sh2,ch3,sh3;</span>
<span class="s1">        var a,b;</span>
<span class="s1">        var return_val;</span>
<span class="s1">        </span>
<span class="s1">        // first givens rotation (ch,0,0,sh)</span>
<span class="s1">        return_val = QRGivensQuaternion(b11,b21);</span>
<span class="s1">        ch1 = return_val[0]; sh1 = return_val[1]</span>
<span class="s1">        a=1-2*sh1*sh1;</span>
<span class="s1">        b=2*ch1*sh1;</span>
<span class="s1">        // apply B = Q&#39;&#39; * B</span>
<span class="s1">        var r11=a*b11+b*b21;  var r12=a*b12+b*b22;  var r13=a*b13+b*b23;</span>
<span class="s1">        var r21=-b*b11+a*b21; var r22=-b*b12+a*b22; var r23=-b*b13+a*b23;</span>
<span class="s1">        var r31=b31;          var r32=b32;          var r33=b33;</span>
<span class="s1">      </span>
<span class="s1">        // second givens rotation (ch,0,-sh,0)</span>
<span class="s1">        return_val = QRGivensQuaternion(r11,r31);</span>
<span class="s1">        ch2 = return_val[0]; sh2 = return_val[1];</span>
<span class="s1">        a=1-2*sh2*sh2;</span>
<span class="s1">        b=2*ch2*sh2;</span>
<span class="s1">        // apply B = Q&#39;&#39; * B;</span>
<span class="s1">        b11=a*r11+b*r31;  b12=a*r12+b*r32;  b13=a*r13+b*r33;</span>
<span class="s1">        b21=r21;           b22=r22;           b23=r23;</span>
<span class="s1">        b31=-b*r11+a*r31; b32=-b*r12+a*r32; b33=-b*r13+a*r33;</span>
<span class="s1">    </span>
<span class="s1">        // third givens rotation (ch,sh,0,0)</span>
<span class="s1">        return_val = QRGivensQuaternion(b22,b32);</span>
<span class="s1">        ch3 = return_val[0]; sh3 = return_val[1];</span>
<span class="s1">        a=1-2*sh3*sh3;</span>
<span class="s1">        b=2*ch3*sh3;</span>
<span class="s1">        // R is now set to desired value</span>
<span class="s1">        r11=b11;             r12=b12;           r13=b13;</span>
<span class="s1">        r21=a*b21+b*b31;     r22=a*b22+b*b32;   r23=a*b23+b*b33;</span>
<span class="s1">        r31=-b*b21+a*b31;    r32=-b*b22+a*b32;  r33=-b*b23+a*b33;</span>
<span class="s1">    </span>
<span class="s1">        // construct the cumulative rotation Q=Q1 * Q2 * Q3</span>
<span class="s1">        // the number of floating point operations for three quaternion multiplications</span>
<span class="s1">        // is more or less comparable to the explicit form of the joined matrix.</span>
<span class="s1">        // certainly more memory-efficient!</span>
<span class="s1">        var sh12=sh1*sh1;</span>
<span class="s1">        var sh22=sh2*sh2;</span>
<span class="s1">        var sh32=sh3*sh3;</span>
<span class="s1">    </span>
<span class="s1">        var q11=(-1+2*sh12)*(-1+2*sh22); </span>
<span class="s1">        var q12=4*ch2*ch3*(-1+2*sh12)*sh2*sh3+2*ch1*sh1*(-1+2*sh32); </span>
<span class="s1">        var q13=4*ch1*ch3*sh1*sh3-2*ch2*(-1+2*sh12)*sh2*(-1+2*sh32);</span>
<span class="s1">    </span>
<span class="s1">        var q21=2*ch1*sh1*(1-2*sh22); </span>
<span class="s1">        var q22=-8*ch1*ch2*ch3*sh1*sh2*sh3+(-1+2*sh12)*(-1+2*sh32); </span>
<span class="s1">        var q23=-2*ch3*sh3+4*sh1*(ch3*sh1*sh3+ch1*ch2*sh2*(-1+2*sh32));</span>
<span class="s1">        </span>
<span class="s1">        var q31=2*ch2*sh2; </span>
<span class="s1">        var q32=2*ch3*(1-2*sh22)*sh3; </span>
<span class="s1">        var q33=(-1+2*sh22)*(-1+2*sh32);</span>
<span class="s1">        </span>
<span class="s1">        return [q11,q12,q13,q21,q22,q23,q31,q32,q33,r11,r12,r13,r21,r22,r23,r31,r32,r33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function svd(a11, a12, a13,</span>
<span class="s1">    		 a21, a22, a23,</span>
<span class="s1">    		 a31, a32, a33)</span>
<span class="s1">    {</span>
<span class="s1">        var ata_return_val;</span>
<span class="s1">        var jacobi_return_val;</span>
<span class="s1">        var quat2mat_return_val;</span>
<span class="s1">        var b_return_vals;</span>
<span class="s1">        var ssv_return_vals;</span>
<span class="s1">        </span>
<span class="s1">    	// normal equations matrix</span>
<span class="s1">    	var ATA11, ATA12, ATA13;</span>
<span class="s1">    	var ATA21, ATA22, ATA23;</span>
<span class="s1">    	var ATA31, ATA32, ATA33;</span>
<span class="s1">        // host.console.println(&quot;Multiplying Matrices ATA &quot;);</span>
<span class="s1">    	ata_return_val = multAtB(a11,a12,a13,a21,a22,a23,a31,a32,a33,</span>
<span class="s1">                                 a11,a12,a13,a21,a22,a23,a31,a32,a33);</span>
<span class="s1">        // host.console.println(&quot;result = &quot; + ata_return_val);</span>
<span class="s1">        ATA11=ata_return_val[0];</span>
<span class="s1">        ATA12=ata_return_val[1];</span>
<span class="s1">        ATA13=ata_return_val[2];</span>
<span class="s1">        ATA21=ata_return_val[3];</span>
<span class="s1">        ATA22=ata_return_val[4];</span>
<span class="s1">        ATA23=ata_return_val[5];</span>
<span class="s1">        ATA31=ata_return_val[6];</span>
<span class="s1">        ATA32=ata_return_val[7];</span>
<span class="s1">        ATA33=ata_return_val[8];</span>
<span class="s1">    </span>
<span class="s1">    	// symmetric eigenalysis</span>
<span class="s1">        // host.console.println(&quot;Jacobi Eigenanalysis&quot;);</span>
<span class="s1">        jacobi_return_val = jacobiEigenanlysis( ATA11,ATA21,ATA22, ATA31,ATA32,ATA33);</span>
<span class="s1">        // host.console.println(&quot;result = &quot; + jacobi_return_val);</span>
<span class="s1">        ATA11 = jacobi_return_val[0];</span>
<span class="s1">        ATA21 = jacobi_return_val[1];</span>
<span class="s1">        ATA22 = jacobi_return_val[2];</span>
<span class="s1">        ATA31 = jacobi_return_val[3];</span>
<span class="s1">        ATA32 = jacobi_return_val[4];</span>
<span class="s1">        ATA33 = jacobi_return_val[5];</span>
<span class="s1">        var qV = jacobi_return_val[6];</span>
<span class="s1">        </span>
<span class="s1">        // host.console.println(&quot;Quat2Mat3&quot;);</span>
<span class="s1">    	quat2mat_return_val = quatToMat3(qV[0],qV[1],qV[2],qV[3]);</span>
<span class="s1">        // host.console.println(&quot;result = &quot; + jacobi_return_val);</span>
<span class="s1">        v11=quat2mat_return_val[0];</span>
<span class="s1">        v12=quat2mat_return_val[1];</span>
<span class="s1">        v13=quat2mat_return_val[2];</span>
<span class="s1">        v21=quat2mat_return_val[3];</span>
<span class="s1">        v22=quat2mat_return_val[4];</span>
<span class="s1">        v23=quat2mat_return_val[5];</span>
<span class="s1">        v31=quat2mat_return_val[6];</span>
<span class="s1">        v32=quat2mat_return_val[7];</span>
<span class="s1">        v33=quat2mat_return_val[8];</span>
<span class="s1">        </span>
<span class="s1">    	var b11, b12, b13;</span>
<span class="s1">    	var b21, b22, b23;</span>
<span class="s1">    	var b31, b32, b33;</span>
<span class="s1">    	b_return_vals = multAB(a11,a12,a13,a21,a22,a23,a31,a32,a33,</span>
<span class="s1">    		v11,v12,v13,v21,v22,v23,v31,v32,v33);</span>
<span class="s1">        b11=b_return_vals[0]; </span>
<span class="s1">        b12=b_return_vals[1]; </span>
<span class="s1">        b13=b_return_vals[2]; </span>
<span class="s1">        b21=b_return_vals[3]; </span>
<span class="s1">        b22=b_return_vals[4]; </span>
<span class="s1">        b23=b_return_vals[5]; </span>
<span class="s1">        b31=b_return_vals[6]; </span>
<span class="s1">        b32=b_return_vals[7]; </span>
<span class="s1">        b33=b_return_vals[8];</span>
<span class="s1">    </span>
<span class="s1">    	// sort singular values and find V</span>
<span class="s1">    	ssv_return_vals = sortSingularValues(b11, b12, b13, b21, b22, b23, b31, b32, b33,</span>
<span class="s1">                                             v11,v12,v13,v21,v22,v23,v31,v32,v33);</span>
<span class="s1">        b11=ssv_return_vals[0];</span>
<span class="s1">        b12=ssv_return_vals[1];</span>
<span class="s1">        b13=ssv_return_vals[2];</span>
<span class="s1">        b21=ssv_return_vals[3];</span>
<span class="s1">        b22=ssv_return_vals[4];</span>
<span class="s1">        b23=ssv_return_vals[5];</span>
<span class="s1">        b31=ssv_return_vals[6];</span>
<span class="s1">        b32=ssv_return_vals[7];</span>
<span class="s1">        b33=ssv_return_vals[8];</span>
<span class="s1">        v11=ssv_return_vals[9];</span>
<span class="s1">        v12=ssv_return_vals[10];</span>
<span class="s1">        v13=ssv_return_vals[11];</span>
<span class="s1">        v21=ssv_return_vals[12];</span>
<span class="s1">        v22=ssv_return_vals[13];</span>
<span class="s1">        v23=ssv_return_vals[14];</span>
<span class="s1">        v31=ssv_return_vals[15];</span>
<span class="s1">        v32=ssv_return_vals[16];</span>
<span class="s1">        v33=ssv_return_vals[17];</span>
<span class="s1">        </span>
<span class="s1">    	// QR decomposition</span>
<span class="s1">    	qr_return_vals = QRDecomposition(b11, b12, b13, b21, b22, b23, b31, b32, b33);</span>
<span class="s1">        u11=qr_return_vals[0];</span>
<span class="s1">        u12=qr_return_vals[1];</span>
<span class="s1">        u13=qr_return_vals[2];</span>
<span class="s1">        u21=qr_return_vals[3];</span>
<span class="s1">        u22=qr_return_vals[4];</span>
<span class="s1">        u23=qr_return_vals[5];</span>
<span class="s1">        u31=qr_return_vals[6];</span>
<span class="s1">        u32=qr_return_vals[7];</span>
<span class="s1">        u33=qr_return_vals[8];</span>
<span class="s1">        s11=qr_return_vals[9];</span>
<span class="s1">        s12=qr_return_vals[10];</span>
<span class="s1">        s13=qr_return_vals[11];</span>
<span class="s1">        s21=qr_return_vals[12];</span>
<span class="s1">        s22=qr_return_vals[13];</span>
<span class="s1">        s23=qr_return_vals[14];</span>
<span class="s1">        s31=qr_return_vals[15];</span>
<span class="s1">        s32=qr_return_vals[16];</span>
<span class="s1">        s33=qr_return_vals[17];</span>
<span class="s1">        </span>
<span class="s1">        return [u11, u12, u13,</span>
<span class="s1">                u21, u22, u23,</span>
<span class="s1">                u31, u32, u33,</span>
<span class="s1">                s11, s12, s13,</span>
<span class="s1">                s21, s22, s23,</span>
<span class="s1">                s31, s32, s33,</span>
<span class="s1">                v11, v12, v13,</span>
<span class="s1">                v21, v22, v23,</span>
<span class="s1">                v31, v32, v33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function mat_inv(n00,n01,n02,n10,n11,n12,n20,n21,n22)</span>
<span class="s1">    {</span>
<span class="s1">        var v1 = (n11 * n22 - n21 * n12);</span>
<span class="s1">        var v2 = (n10 * n22 - n12 * n20);</span>
<span class="s1">        var v3 = (n10 * n21 - n11 * n20);</span>
<span class="s1">        </span>
<span class="s1">        var det = (n00 * v1) - (n01 * v2) + (n02 * v3);</span>
<span class="s1">        </span>
<span class="s1">        var invdet = 1/det;</span>
<span class="s1">        </span>
<span class="s1">        var ninv00 = v1 * invdet;</span>
<span class="s1">        var ninv01 = (n02 * n21 - n01 * n22) * invdet;</span>
<span class="s1">        var ninv02 = (n01 * n12 - n02 * n11) * invdet;</span>
<span class="s1">        var ninv10 = -v2 * invdet;</span>
<span class="s1">        var ninv11 = (n00 * n22 - n02 * n20) * invdet;</span>
<span class="s1">        var ninv12 = (n10 * n02 - n00 * n12) * invdet;</span>
<span class="s1">        var ninv20 = v3 * invdet;</span>
<span class="s1">        var ninv21 = (n20 * n01 - n00 * n21) * invdet;</span>
<span class="s1">        var ninv22 = (n00 * n11 - n10 * n01) * invdet;</span>
<span class="s1">        </span>
<span class="s1">        return [ninv00,ninv01,ninv02,ninv10,ninv11,ninv12,ninv20,ninv21,ninv22]</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function AmultAT3x4(a11,a12,a13,a14,a21,a22,a23,a24,a31,a32,a33,a34)</span>
<span class="s1">    {</span>
<span class="s1">        var AAT11 = a11*a11 + a12*a12 + a13*a13 + a14*a14;</span>
<span class="s1">        var AAT12 = a11*a21 + a12*a22 + a13*a23 + a14*a24;</span>
<span class="s1">        var AAT13 = a11*a31 + a12*a32 + a13*a33 + a14*a34;</span>
<span class="s1">        var AAT21 = a11*a21 + a12*a22 + a13*a23 + a14*a24;</span>
<span class="s1">        var AAT22 = a21*a21 + a22*a22 + a23*a23 + a24*a24;</span>
<span class="s1">        var AAT23 = a21*a31 + a22*a32 + a23*a33 + a24*a34;</span>
<span class="s1">        var AAT31 = a11*a31 + a12*a32 + a13*a33 + a14*a34;</span>
<span class="s1">        var AAT32 = a21*a31 + a22*a32 + a23*a33 + a24*a34;</span>
<span class="s1">        var AAT33 = a31*a31 + a32*a32 + a33*a33 + a34*a34;</span>
<span class="s1">        </span>
<span class="s1">        return [AAT11,AAT12,AAT13,AAT21,AAT22,AAT23,AAT31,AAT32,AAT33];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function matmul4x3x3(a11,a12,a13,a21,a22,a23,a31,a32,a33,a41,a42,a43,</span>
<span class="s1">                         b11,b12,b13,b21,b22,b23,b31,b32,b33)</span>
<span class="s1">    {</span>
<span class="s1">        var C11 = a11*b11 + a12*b21 + a13*b31;</span>
<span class="s1">        var C12 = a11*b12 + a12*b22 + a13*b32;</span>
<span class="s1">        var C13 = a11*b13 + a12*b23 + a13*b33;</span>
<span class="s1">        var C21 = a21*b11 + a22*b21 + a23*b31;</span>
<span class="s1">        var C22 = a21*b12 + a22*b22 + a23*b32;</span>
<span class="s1">        var C23 = a21*b13 + a22*b23 + a23*b33;</span>
<span class="s1">        var C31 = a31*b11 + a32*b21 + a33*b31;</span>
<span class="s1">        var C32 = a31*b12 + a32*b22 + a33*b32;</span>
<span class="s1">        var C33 = a31*b13 + a32*b23 + a33*b33;</span>
<span class="s1">        var C41 = a41*b11 + a42*b21 + a43*b31;</span>
<span class="s1">        var C42 = a41*b12 + a42*b22 + a43*b32;</span>
<span class="s1">        var C43 = a41*b13 + a42*b23 + a43*b33;</span>
<span class="s1">        </span>
<span class="s1">        return [C11,C12,C13,C21,C22,C23,C31,C32,C33,C41,C42,C43];</span>
<span class="s1">    }</span>
<span class="s1">    </span>
<span class="s1">    function matrix_axis_angle(a,b,c,d,e,f,g,h,i)</span>
<span class="s1">    {</span>
<span class="s1">        var axis = Vector3(h-f,c-g,d-b);</span>
<span class="s1">        var angle = Math.atan2(axis.length,(a+e+i-1));</span>
<span class="s1">        axis = axis.scale(1/axis.length);</span>
<span class="s1">        return [axis,angle]</span>
<span class="s1">    }</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">)</span>
    
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    // Go through element nodes</span>
<span class="s1">    for (i=0; i &lt; face_nodes.length; i++){{</span>
<span class="s1">        model_node = scene.nodes.getByIndex(face_nodes[i]);</span>
<span class="s1">        geometry_node_ids = face_map[i];</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;Element Index &quot;+i+&quot; corresponds to model node &quot;+model_node.name+&quot; and geometry node ids &quot;+geometry_node_ids);</span>
<span class="s1">        model_node.transform.setIdentity();</span>
<span class="s1">        p1 = node_positions[geometry_node_ids[0]];</span>
<span class="s1">        p2 = node_positions[geometry_node_ids[1]];</span>
<span class="s1">        p3 = node_positions[geometry_node_ids[2]];</span>
<span class="s1">        centroid = p1.add(p2.add(p3)).scale(.3333333333333333);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Initial Transformation:&quot;);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString());</span>
<span class="s1">        model_node.transform.translateInPlace(centroid.scale(-1));</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after removing centroid &quot;+centroid+&quot;:&quot;);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString());</span>
<span class="s1">        p1 = p1.subtract(centroid)</span>
<span class="s1">        p2 = p2.subtract(centroid)</span>
<span class="s1">        p3 = p3.subtract(centroid)</span>
<span class="s1">        d1 = node_displacements[geometry_node_ids[0]][shape-1].scale(scale);</span>
<span class="s1">        d2 = node_displacements[geometry_node_ids[1]][shape-1].scale(scale);</span>
<span class="s1">        d3 = node_displacements[geometry_node_ids[2]][shape-1].scale(scale);</span>
<span class="s1">        pd1 = p1.add(d1);</span>
<span class="s1">        pd2 = p2.add(d2);</span>
<span class="s1">        pd3 = p3.add(d3);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;Transforming Element: &quot;+geometry_node_ids);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  p1: &quot;+p1)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  p2: &quot;+p2)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  p3: &quot;+p3)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  pd1: &quot;+pd1)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  pd2: &quot;+pd2)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  pd3: &quot;+pd3)</span>
<span class="s1">        var AAT = AmultAT3x4(p1.x,p1.y,p1.z,1,p2.x,p2.y,p2.z,1,p3.x,p3.y,p3.z,1);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  AAT: &quot;+AAT)</span>
<span class="s1">        var pinvA = matmul4x3x3.apply(this,[p1.x,p2.x,p3.x,p1.y,p2.y,p3.y,p1.z,p2.z,p3.z,1,1,1].concat(mat_inv.apply(this,AAT)));</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  pinvA: &quot;+pinvA)</span>
<span class="s1">        var b = [pd1.x,pd1.y,pd1.z,pd2.x,pd2.y,pd2.z,pd3.x,pd3.y,pd3.z];</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  b: &quot;+b)</span>
<span class="s1">        var x = matmul4x3x3.apply(this,pinvA.concat(b));</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  x: &quot;+x)</span>
<span class="s1">        T = [x[0],x[3],x[6],x[1],x[4],x[7],x[2],x[5],x[8]];</span>
<span class="s1">        t = Vector3(x[9],x[10],x[11]);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  T: &quot;+T)</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  t: &quot;+t)</span>
<span class="s1">        svd_res = svd.apply(this,T);</span>
<span class="s1">        U = svd_res.slice(0,9);</span>
<span class="s1">        S = svd_res.slice(9,18);</span>
<span class="s1">        V = svd_res.slice(18);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  U: &quot;+U);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  S: &quot;+S);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  V: &quot;+V);</span>
<span class="s1">        uvar = matrix_axis_angle.apply(this,U);</span>
<span class="s1">        uaxis = uvar[0]; uangle = uvar[1];</span>
<span class="s1">        vvar = matrix_axis_angle.apply(this,V);</span>
<span class="s1">        vaxis = vvar[0]; vangle = vvar[1];</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  U axis: &quot;+uaxis);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  U angle: &quot;+uangle);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  V axis: &quot;+vaxis);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;  V angle: &quot;+vangle);</span>
<span class="s1">        model_node.transform.rotateAboutVectorInPlace(-vangle,vaxis);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after rotation about &quot;+vaxis+&quot; by &quot;+(-vangle)+&quot;:&quot;);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString());</span>
<span class="s1">        model_node.transform.scaleInPlace(S[0],S[4],1);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after scaling by &quot;+[S[0],S[4],1]+&quot;:&quot;);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString());</span>
<span class="s1">        model_node.transform.rotateAboutVectorInPlace(uangle,uaxis);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after rotation about &quot;+uaxis+&quot; by &quot;+(-uangle)+&quot;:&quot;);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString());</span>
<span class="s1">        model_node.transform.translateInPlace(t.add(centroid));</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(&quot;</span><span class="se">\\</span><span class="s1">n  Transform after translation by t and centroid &quot;+t.add(centroid)+&quot;:&quot;);</span>
<span class="s1">        </span><span class="si">{debug:}</span><span class="s1">host.console.println(model_node.transform.toString());</span>
<span class="s1">        </span>
<span class="s1">    }}</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">debug</span><span class="o">=</span><span class="s1">&#39;&#39;</span> <span class="k">if</span> <span class="n">debug_js</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">or</span> <span class="n">debug_js</span><span class="o">==</span><span class="s1">&#39;face&#39;</span> <span class="k">else</span> <span class="s1">&#39;// &#39;</span><span class="p">))</span>

<span class="c1"># Note: there should be some way to build the transformation matrix without an</span>
<span class="c1"># SVD.  However, it results in one of the dimensions of the transformation</span>
<span class="c1"># getting squashed to zero, which doesn&#39;t have any affect on the resulting</span>
<span class="c1"># geometry, but it does mess with the shading due to the surface normal being</span>
<span class="c1"># kind of screwed up.  I&#39;m not sure exactly the solution apart from computing an</span>
<span class="c1"># SVD and making all singular values positive (which is exactly what I do now)</span>
<span class="c1"># function matmul4x4x4(</span>
<span class="c1">#     a00, a01, a02, a03,</span>
<span class="c1">#     a10, a11, a12, a13,</span>
<span class="c1">#     a20, a21, a22, a23,</span>
<span class="c1">#     a30, a31, a32, a33,</span>
<span class="c1">#     b00, b01, b02, b03,</span>
<span class="c1">#     b10, b11, b12, b13,</span>
<span class="c1">#     b20, b21, b22, b23,</span>
<span class="c1">#     b30, b31, b32, b33</span>
<span class="c1"># ) {</span>
<span class="c1">#     const result = [</span>
<span class="c1">#             a00 * b00 + a01 * b10 + a02 * b20 + a03 * b30,</span>
<span class="c1">#             a00 * b01 + a01 * b11 + a02 * b21 + a03 * b31,</span>
<span class="c1">#             a00 * b02 + a01 * b12 + a02 * b22 + a03 * b32,</span>
<span class="c1">#             a00 * b03 + a01 * b13 + a02 * b23 + a03 * b33,</span>
<span class="c1">#             a10 * b00 + a11 * b10 + a12 * b20 + a13 * b30,</span>
<span class="c1">#             a10 * b01 + a11 * b11 + a12 * b21 + a13 * b31,</span>
<span class="c1">#             a10 * b02 + a11 * b12 + a12 * b22 + a13 * b32,</span>
<span class="c1">#             a10 * b03 + a11 * b13 + a12 * b23 + a13 * b33,</span>
<span class="c1">#             a20 * b00 + a21 * b10 + a22 * b20 + a23 * b30,</span>
<span class="c1">#             a20 * b01 + a21 * b11 + a22 * b21 + a23 * b31,</span>
<span class="c1">#             a20 * b02 + a21 * b12 + a22 * b22 + a23 * b32,</span>
<span class="c1">#             a20 * b03 + a21 * b13 + a22 * b23 + a23 * b33,</span>
<span class="c1">#             a30 * b00 + a31 * b10 + a32 * b20 + a33 * b30,</span>
<span class="c1">#             a30 * b01 + a31 * b11 + a32 * b21 + a33 * b31,</span>
<span class="c1">#             a30 * b02 + a31 * b12 + a32 * b22 + a33 * b32,</span>
<span class="c1">#             a30 * b03 + a31 * b13 + a32 * b23 + a33 * b33,</span>
<span class="c1">#     ];</span>

<span class="c1">#     return result;</span>
<span class="c1"># }</span>
<span class="c1"># // Try the same thing by just building the transformation without SVDs</span>
<span class="c1"># T_raw = [1,0,0,0, //indices 0-3</span>
<span class="c1">#          0,1,0,0, //indices 4-7</span>
<span class="c1">#          0,0,1,0, //indices 8-11</span>
<span class="c1">#          0,0,0,1]; //indices 12-15</span>
<span class="c1"># {debug:}host.console.println(&quot;\\n  Initial Transformation:&quot;);</span>
<span class="c1"># {debug:}host.console.println(T_raw);</span>
<span class="c1"># T_raw[12] -= centroid.x;</span>
<span class="c1"># T_raw[13] -= centroid.y;</span>
<span class="c1"># T_raw[14] -= centroid.z;</span>
<span class="c1"># {debug:}host.console.println(&quot;\\n  With Removal of Centroid:&quot;);</span>
<span class="c1"># {debug:}host.console.println(T_raw);</span>
<span class="c1"># X = [x[0],x[1],x[2],0,</span>
<span class="c1">#      x[3],x[4],x[5],0,</span>
<span class="c1">#      x[6],x[7],x[8],0,</span>
<span class="c1">#      x[9],x[10],x[11],1];</span>
<span class="c1"># T_raw = matmul4x4x4.apply(this,T_raw.concat(X));</span>
<span class="c1"># {debug:}host.console.println(&quot;\\n  After Rotation, Scaling, and Translation:&quot;);</span>
<span class="c1"># {debug:}host.console.println(T_raw);</span>
<span class="c1"># T_raw[12] += centroid.x;</span>
<span class="c1"># T_raw[13] += centroid.y;</span>
<span class="c1"># T_raw[14] += centroid.z;</span>
<span class="c1"># {debug:}host.console.println(&quot;\\n  After Addition of Centroid:&quot;);</span>
<span class="c1"># {debug:}host.console.println(T_raw);</span>
<span class="c1"># model_node.transform.set(T_raw);</span>
<span class="c1"># break;</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">    scene.update();</span>
<span class="s1">    </span>
<span class="s1">    </span>
<span class="s1">    timeEvHnd=new TimeEventHandler();</span>
<span class="s1">    timeEvHnd.onEvent=function(event) {</span>
<span class="s1">        var dtheta=speed*omega0*event.deltaTime;</span>
<span class="s1">        if (dtheta!=0){</span>
<span class="s1">    &#39;&#39;&#39;</span><span class="p">)</span>
    
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            // Translate Nodes</span>
<span class="s1">            for (i=0; i &lt; point_nodes.length; i++){{</span>
<span class="s1">                geometry_node_id = point_map[i];</span>
<span class="s1">                model_node = scene.nodes.getByIndex(point_nodes[i]);</span>
<span class="s1">                model_node.transform.setIdentity();</span>
<span class="s1">                model_node.transform.translateInPlace(node_displacements[geometry_node_id][shape-1].scale(scale*Math.cos(theta)));</span>
<span class="s1">            }}&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">())</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            // Translate and Rotate Lines</span>
<span class="s1">            for (i=0; i &lt; line_nodes.length; i++){{</span>
<span class="s1">                model_node = scene.nodes.getByIndex(line_nodes[i]);</span>
<span class="s1">                geometry_node_ids = line_map[i];</span>
<span class="s1">                model_node.transform.setIdentity();</span>
<span class="s1">                p1 = node_positions[geometry_node_ids[0]];</span>
<span class="s1">                p2 = node_positions[geometry_node_ids[1]];</span>
<span class="s1">                d1 = node_displacements[geometry_node_ids[0]][shape-1].scale(scale*Math.cos(theta));</span>
<span class="s1">                d2 = node_displacements[geometry_node_ids[1]][shape-1].scale(scale*Math.cos(theta));</span>
<span class="s1">                v1 = p2.add(p1.scale(-1));</span>
<span class="s1">                v2 = p2.add(d2).add(p1.add(d1).scale(-1));</span>
<span class="s1">                vc1 = p2.add(p1).scale(0.5);</span>
<span class="s1">                vc2 = p2.add(d2).add(p1).add(d1).scale(0.5);</span>
<span class="s1">                axis = v1.cross(v2);</span>
<span class="s1">                angle = Math.acos(v1.dot(v2)/(Math.sqrt(v1.dot(v1))*Math.sqrt(v2.dot(v2))));</span>
<span class="s1">                c = Math.sqrt(v2.dot(v2)/v1.dot(v1));</span>
<span class="s1">                t = vc2.add(vc1.scale(-c));</span>
<span class="s1">                //model_node.transform.rotateAboutLineInPlace(angle,vc1,vc1.add(axis)); //There seems to be a bug with this command...</span>
<span class="s1">                if (angle &gt; 0.00175) {{</span>
<span class="s1">                    model_node.transform.translateInPlace(vc1.scale(-1));</span>
<span class="s1">                    model_node.transform.rotateAboutVectorInPlace(angle,axis);</span>
<span class="s1">                    model_node.transform.translateInPlace(vc1);</span>
<span class="s1">                }}</span>
<span class="s1">                model_node.transform.scaleInPlace(c,c,c);</span>
<span class="s1">                model_node.transform.translateInPlace(t);</span>
<span class="s1">            }}&#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">())</span>
            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;&#39;&#39;</span>
<span class="s1">            // Go through element nodes</span>
<span class="s1">            for (i=0; i &lt; face_nodes.length; i++){{</span>
<span class="s1">                model_node = scene.nodes.getByIndex(face_nodes[i]);</span>
<span class="s1">                geometry_node_ids = face_map[i];</span>
<span class="s1">                model_node.transform.setIdentity();</span>
<span class="s1">                p1 = node_positions[geometry_node_ids[0]];</span>
<span class="s1">                p2 = node_positions[geometry_node_ids[1]];</span>
<span class="s1">                p3 = node_positions[geometry_node_ids[2]];</span>
<span class="s1">                centroid = p1.add(p2.add(p3)).scale(.3333333333333333);</span>
<span class="s1">                model_node.transform.translateInPlace(centroid.scale(-1));</span>
<span class="s1">                p1 = p1.subtract(centroid)</span>
<span class="s1">                p2 = p2.subtract(centroid)</span>
<span class="s1">                p3 = p3.subtract(centroid)</span>
<span class="s1">                d1 = node_displacements[geometry_node_ids[0]][shape-1].scale(scale*Math.cos(theta));</span>
<span class="s1">                d2 = node_displacements[geometry_node_ids[1]][shape-1].scale(scale*Math.cos(theta));</span>
<span class="s1">                d3 = node_displacements[geometry_node_ids[2]][shape-1].scale(scale*Math.cos(theta));</span>
<span class="s1">                pd1 = p1.add(d1);</span>
<span class="s1">                pd2 = p2.add(d2);</span>
<span class="s1">                pd3 = p3.add(d3);</span>
<span class="s1">                var AAT = AmultAT3x4(p1.x,p1.y,p1.z,1,p2.x,p2.y,p2.z,1,p3.x,p3.y,p3.z,1);</span>
<span class="s1">                var pinvA = matmul4x3x3.apply(this,[p1.x,p2.x,p3.x,p1.y,p2.y,p3.y,p1.z,p2.z,p3.z,1,1,1].concat(mat_inv.apply(this,AAT)));</span>
<span class="s1">                var b = [pd1.x,pd1.y,pd1.z,pd2.x,pd2.y,pd2.z,pd3.x,pd3.y,pd3.z];</span>
<span class="s1">                var x = matmul4x3x3.apply(this,pinvA.concat(b));</span>
<span class="s1">                T = [x[0],x[3],x[6],x[1],x[4],x[7],x[2],x[5],x[8]];</span>
<span class="s1">                t = Vector3(x[9],x[10],x[11]);</span>
<span class="s1">                svd_res = svd.apply(this,T);</span>
<span class="s1">                U = svd_res.slice(0,9);</span>
<span class="s1">                S = svd_res.slice(9,18);</span>
<span class="s1">                V = svd_res.slice(18);</span>
<span class="s1">                uvar = matrix_axis_angle.apply(this,U);</span>
<span class="s1">                uaxis = uvar[0]; uangle = uvar[1];</span>
<span class="s1">                vvar = matrix_axis_angle.apply(this,V);</span>
<span class="s1">                vaxis = vvar[0]; vangle = vvar[1];</span>
<span class="s1">                model_node.transform.rotateAboutVectorInPlace(-vangle,vaxis);</span>
<span class="s1">                model_node.transform.scaleInPlace(S[0],S[4],1);</span>
<span class="s1">                model_node.transform.rotateAboutVectorInPlace(uangle,uaxis);</span>
<span class="s1">                model_node.transform.translateInPlace(t.add(centroid));</span>
<span class="s1">                </span>
<span class="s1">            }}</span>
<span class="s1">            &#39;&#39;&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">())</span>

            <span class="n">f</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
<span class="w">    </span><span class="sd">&#39;&#39;&#39;        </span>
<span class="sd">            theta+=dtheta+2*Math.PI;</span>
<span class="sd">            theta %= 2*Math.PI;</span>
<span class="sd">            scene.update();</span>
<span class="sd">    </span>
<span class="sd">        }</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    </span>
<span class="sd">    menuEvHnd = new MenuEventHandler();</span>
<span class="sd">    menuEvHnd.onEvent=function(event) {</span>
<span class="sd">        if(event.menuItemName === &quot;inc_mode&quot;){</span>
<span class="sd">            shape += 1;</span>
<span class="sd">            if (shape &gt; num_shapes) {</span>
<span class="sd">                shape = num_shapes;</span>
<span class="sd">            }</span>
<span class="sd">            host.console.show();</span>
<span class="sd">            host.console.println(&quot;Now displaying Mode &quot;+shape+&quot; at &quot;+mode_frequencies[shape-1]+&quot; Hz in panel &quot;+panel);</span>
<span class="sd">        }</span>
<span class="sd">        if(event.menuItemName === &quot;dec_mode&quot;){</span>
<span class="sd">            shape -= 1;</span>
<span class="sd">            if (shape &lt; 1) {</span>
<span class="sd">                shape = 1;</span>
<span class="sd">            }</span>
<span class="sd">            host.console.show();</span>
<span class="sd">            host.console.println(&quot;Now displaying Mode &quot;+shape+&quot; at &quot;+mode_frequencies[shape-1]+&quot; Hz in panel &quot;+panel);</span>
<span class="sd">        }</span>
<span class="sd">        if(event.menuItemName === &quot;scale_up&quot;){</span>
<span class="sd">            scale *= 1.25;</span>
<span class="sd">        }</span>
<span class="sd">        if(event.menuItemName === &quot;scale_down&quot;){</span>
<span class="sd">            scale *= 0.8;</span>
<span class="sd">        }</span>
<span class="sd">        if(event.menuItemName === &quot;speed_up&quot;){</span>
<span class="sd">            speed *= 1.25;</span>
<span class="sd">        }</span>
<span class="sd">        if(event.menuItemName === &quot;speed_down&quot;){</span>
<span class="sd">            speed *= 0.8;</span>
<span class="sd">        }</span>
<span class="sd">    }</span>
<span class="sd">    </span>
<span class="sd">    keyEvHnd = new KeyEventHandler();</span>
<span class="sd">    keyEvHnd.onEvent = function(event) {</span>
<span class="sd">        //host.console.show();</span>
<span class="sd">        //host.console.println(&quot;Key pressed: Code = &quot;+event.characterCode);</span>
<span class="sd">        if (event.characterCode === 44) {</span>
<span class="sd">            shape -= 1;</span>
<span class="sd">            if (shape &lt; 1) {</span>
<span class="sd">                shape = 1;</span>
<span class="sd">            }</span>
<span class="sd">            host.console.show();</span>
<span class="sd">            host.console.println(&quot;Now displaying Mode &quot;+shape+&quot; at &quot;+mode_frequencies[shape-1]+&quot; Hz in panel &quot;+panel);</span>
<span class="sd">        }</span>
<span class="sd">        if (event.characterCode === 46) {</span>
<span class="sd">            shape += 1;</span>
<span class="sd">            if (shape &gt; num_shapes) {</span>
<span class="sd">                shape = num_shapes;</span>
<span class="sd">            }</span>
<span class="sd">            host.console.show();</span>
<span class="sd">            host.console.println(&quot;Now displaying Mode &quot;+shape+&quot; at &quot;+mode_frequencies[shape-1]+&quot; Hz in panel &quot;+panel);</span>
<span class="sd">        }</span>
<span class="sd">        if(event.characterCode === 43){</span>
<span class="sd">            scale *= 1.25;</span>
<span class="sd">        }</span>
<span class="sd">        if(event.characterCode === 45){</span>
<span class="sd">            scale *= 0.8;</span>
<span class="sd">        }</span>
<span class="sd">        if(event.characterCode === 102){</span>
<span class="sd">            speed *= 1.25;</span>
<span class="sd">        }</span>
<span class="sd">        if(event.characterCode === 115){</span>
<span class="sd">            speed *= 0.8;</span>
<span class="sd">        }</span>
<span class="sd">    }</span>
<span class="sd">    runtime.addEventHandler(timeEvHnd);</span>
<span class="sd">    runtime.addCustomMenuItem(&quot;inc_mode&quot;,&quot;Next Mode                  .&quot;,&quot;default&quot;,false);</span>
<span class="sd">    runtime.addCustomMenuItem(&quot;dec_mode&quot;,&quot;Previous Mode           ,&quot;,&quot;default&quot;,false);</span>
<span class="sd">    runtime.addCustomMenuItem(&quot;scale_up&quot;,&quot;Scale 1.25x                  +&quot;,&quot;default&quot;,false);</span>
<span class="sd">    runtime.addCustomMenuItem(&quot;scale_down&quot;,&quot;Scale 0.8x                    -&quot;,&quot;default&quot;,false);</span>
<span class="sd">    runtime.addCustomMenuItem(&quot;speed_up&quot;,&quot;Speed 1.25x                 f&quot;,&quot;default&quot;,false);</span>
<span class="sd">    runtime.addCustomMenuItem(&quot;speed_down&quot;,&quot;Speed 0.8x                   s&quot;,&quot;default&quot;,false);</span>
<span class="sd">    runtime.addEventHandler(menuEvHnd);</span>
<span class="sd">    runtime.addEventHandler(keyEvHnd);&#39;&#39;&#39;</span><span class="p">)</span></div>
    
    
<div class="viewcode-block" id="get_view_parameters_from_plotter"><a class="viewcode-back" href="../../../_autosummary/sdynpy.fileio.sdynpy_pdf3D.get_view_parameters_from_plotter.html#sdynpy.fileio.sdynpy_pdf3D.get_view_parameters_from_plotter">[docs]</a><span class="k">def</span><span class="w"> </span><span class="nf">get_view_parameters_from_plotter</span><span class="p">(</span><span class="n">plotter</span><span class="p">):</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">plotter</span><span class="o">.</span><span class="n">camera</span>
    <span class="n">camera_position</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">position</span><span class="p">)</span>
    <span class="n">focus</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">focal_point</span><span class="p">)</span>
    <span class="n">view_angle</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">view_angle</span>
    <span class="n">c2c</span> <span class="o">=</span> <span class="n">camera_position</span> <span class="o">-</span> <span class="n">focus</span> <span class="c1"># Center of orbit to camera</span>
    <span class="n">c2c</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">c2c</span><span class="p">)</span>
    <span class="n">view_axis</span> <span class="o">=</span> <span class="o">-</span><span class="n">c2c</span>
    <span class="n">view_up</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">up</span><span class="p">)</span> <span class="c1"># This is the general up direction and may not be the actual up direction of the camera</span>
    <span class="n">view_up</span> <span class="o">-=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">view_axis</span><span class="p">,</span><span class="n">view_up</span><span class="p">)</span><span class="o">*</span><span class="n">view_axis</span><span class="p">)</span>
    <span class="n">view_up</span> <span class="o">/=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">view_up</span><span class="p">)</span>
    <span class="n">yaw</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">view_axis</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">view_axis</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">pitch</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">view_axis</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
    <span class="n">roll</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arcsin</span><span class="p">(</span><span class="n">view_up</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">yaw</span><span class="p">)</span><span class="o">-</span><span class="n">view_up</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">yaw</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Yaw: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">Pitch: </span><span class="si">{:}</span><span class="se">\n</span><span class="s1">Roll: </span><span class="si">{:}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">yaw</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                                                   <span class="n">pitch</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span>
                                                   <span class="n">roll</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">))</span>
    <span class="n">bounding_box</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">plotter</span><span class="o">.</span><span class="n">bounds</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">bounding_distance</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">bounding_box</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">bounding_box</span><span class="p">[:,</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">media9</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">media9</span><span class="p">[</span><span class="s1">&#39;3Dortho&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="mi">1</span><span class="o">/</span><span class="n">bounding_distance</span><span class="p">)</span>
    <span class="n">media9</span><span class="p">[</span><span class="s1">&#39;3Droll&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">roll</span><span class="o">*</span><span class="mi">180</span><span class="o">/</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
    <span class="n">media9</span><span class="p">[</span><span class="s1">&#39;3Dc2c&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">c2c</span><span class="p">])</span>
    <span class="n">media9</span><span class="p">[</span><span class="s1">&#39;3Dcoo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39; &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">focus</span><span class="p">])</span> <span class="c1"># Center of orbit of virtual camera</span>
    <span class="n">media9</span><span class="p">[</span><span class="s1">&#39;3Droo&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">camera_position</span> <span class="o">-</span> <span class="n">focus</span><span class="p">))</span>
    <span class="n">media9</span><span class="p">[</span><span class="s1">&#39;3Daac&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">view_angle</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">media9</span></div>
    
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
<jinja2.runtime.BlockReference object at 0x7fc922315e90>
<img src="_images/snl.jpg" alt="Sandia National Laboratories" style="height:40px">

  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>