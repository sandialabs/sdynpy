<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>SDynPy Showcase &mdash; SDynPy 0.19.0 documentation</title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css" />
      <link rel="stylesheet" type="text/css" href="_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="_static/copybutton.css" />
      <link rel="stylesheet" type="text/css" href="_static/custom.css" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/sphinx_highlight.js"></script>
        <script src="_static/clipboard.min.js"></script>
        <script src="_static/copybutton.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Core Functionality" href="core_functionality.html" />
    <link rel="prev" title="Usage" href="usage.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html">
            
              <img src="_static/logo_horizontal_light.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="usage.html">Usage</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">SDynPy Showcase</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#imports">Imports</a></li>
<li class="toctree-l2"><a class="reference internal" href="#creating-a-simple-beam-model">Creating a Simple Beam Model</a></li>
<li class="toctree-l2"><a class="reference internal" href="#geometry-in-sdynpy">Geometry in SDynPy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#nodes">Nodes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#coordinate-systems">Coordinate Systems</a></li>
<li class="toctree-l3"><a class="reference internal" href="#elements">Elements</a></li>
<li class="toctree-l3"><a class="reference internal" href="#tracelines">Tracelines</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plotting-geometry">Plotting Geometry</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#systems-in-sdynpy">Systems in SDynPy</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#coordinates">Coordinates</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plotting-coordinates">Plotting Coordinates</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#computing-modes-of-the-system">Computing Modes of the System</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#shapes">Shapes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plotting-shapes">Plotting Shapes</a></li>
<li class="toctree-l3"><a class="reference internal" href="#assigning-to-sdynpy-array-fields-and-array-views-versus-copies">Assigning to SDynpy Array Fields and Array Views versus Copies</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#indexing-using-a-single-integer-index">Indexing using a Single Integer Index</a></li>
<li class="toctree-l4"><a class="reference internal" href="#indexing-using-a-slice">Indexing using a Slice</a></li>
<li class="toctree-l4"><a class="reference internal" href="#indexing-with-logical-arrays">Indexing with Logical Arrays</a></li>
<li class="toctree-l4"><a class="reference internal" href="#indexing-with-integer-arrays">Indexing with Integer Arrays</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#computing-a-modal-system">Computing a Modal System</a></li>
<li class="toctree-l2"><a class="reference internal" href="#data-in-sdynpy">Data in SDynPy</a></li>
<li class="toctree-l2"><a class="reference internal" href="#integrating-equations-of-motion-to-produce-time-data">Integrating Equations of Motion to Produce Time Data</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#generating-an-excitation-signal">Generating an Excitation Signal</a></li>
<li class="toctree-l3"><a class="reference internal" href="#performing-the-time-integration">Performing the Time Integration</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#computing-frequency-response-functions">Computing Frequency Response Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#code-based-frequency-response-function-computations">Code-based Frequency Response Function Computations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#mode-indicator-functions">Mode Indicator Functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="#graphical-frequency-response-function-computation">Graphical Frequency Response Function Computation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#plotting-deflection-shapes">Plotting Deflection Shapes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#fitting-modes-to-frequency-response-functions">Fitting Modes to Frequency Response Functions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#polypy">PolyPy</a></li>
<li class="toctree-l3"><a class="reference internal" href="#synthesize-modes-and-correlate-smac">Synthesize Modes and Correlate (SMAC)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#comparing-modes">Comparing Modes</a></li>
<li class="toctree-l2"><a class="reference internal" href="#adding-another-beam">Adding Another Beam</a></li>
<li class="toctree-l2"><a class="reference internal" href="#applying-constraints-to-the-system">Applying Constraints to the System</a></li>
<li class="toctree-l2"><a class="reference internal" href="#frequency-based-substructuring">Frequency-Based Substructuring</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="core_functionality.html">Core Functionality</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">SDynpy Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="modal_tutorials.html">Modal Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="modules.html">SDynPy Programming Interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="bibliography.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">SDynPy</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">SDynPy Showcase</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/sdynpy_showcase.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sdynpy-showcase">
<h1><a class="toc-backref" href="#id64">SDynPy Showcase</a><a class="headerlink" href="#sdynpy-showcase" title="Permalink to this heading"></a></h1>
<p>This document will demonstrate the Structural Dynamics capabilities in SDynPy,
from the basics such as computing mode shapes, to complex analyses such as
substructuring.</p>
<div class="contents topic" id="contents">
<p class="topic-title">Contents</p>
<ul class="simple">
<li><p><a class="reference internal" href="#sdynpy-showcase" id="id64">SDynPy Showcase</a></p>
<ul>
<li><p><a class="reference internal" href="#imports" id="id65">Imports</a></p></li>
<li><p><a class="reference internal" href="#creating-a-simple-beam-model" id="id66">Creating a Simple Beam Model</a></p></li>
<li><p><a class="reference internal" href="#geometry-in-sdynpy" id="id67">Geometry in SDynPy</a></p>
<ul>
<li><p><a class="reference internal" href="#nodes" id="id68">Nodes</a></p></li>
<li><p><a class="reference internal" href="#coordinate-systems" id="id69">Coordinate Systems</a></p></li>
<li><p><a class="reference internal" href="#elements" id="id70">Elements</a></p></li>
<li><p><a class="reference internal" href="#tracelines" id="id71">Tracelines</a></p></li>
<li><p><a class="reference internal" href="#plotting-geometry" id="id72">Plotting Geometry</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#systems-in-sdynpy" id="id73">Systems in SDynPy</a></p>
<ul>
<li><p><a class="reference internal" href="#coordinates" id="id74">Coordinates</a></p></li>
<li><p><a class="reference internal" href="#plotting-coordinates" id="id75">Plotting Coordinates</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#computing-modes-of-the-system" id="id76">Computing Modes of the System</a></p>
<ul>
<li><p><a class="reference internal" href="#shapes" id="id77">Shapes</a></p></li>
<li><p><a class="reference internal" href="#plotting-shapes" id="id78">Plotting Shapes</a></p></li>
<li><p><a class="reference internal" href="#assigning-to-sdynpy-array-fields-and-array-views-versus-copies" id="id79">Assigning to SDynpy Array Fields and Array Views versus Copies</a></p>
<ul>
<li><p><a class="reference internal" href="#indexing-using-a-single-integer-index" id="id80">Indexing using a Single Integer Index</a></p></li>
<li><p><a class="reference internal" href="#indexing-using-a-slice" id="id81">Indexing using a Slice</a></p></li>
<li><p><a class="reference internal" href="#indexing-with-logical-arrays" id="id82">Indexing with Logical Arrays</a></p></li>
<li><p><a class="reference internal" href="#indexing-with-integer-arrays" id="id83">Indexing with Integer Arrays</a></p></li>
</ul>
</li>
</ul>
</li>
<li><p><a class="reference internal" href="#computing-a-modal-system" id="id84">Computing a Modal System</a></p></li>
<li><p><a class="reference internal" href="#data-in-sdynpy" id="id85">Data in SDynPy</a></p></li>
<li><p><a class="reference internal" href="#integrating-equations-of-motion-to-produce-time-data" id="id86">Integrating Equations of Motion to Produce Time Data</a></p>
<ul>
<li><p><a class="reference internal" href="#generating-an-excitation-signal" id="id87">Generating an Excitation Signal</a></p></li>
<li><p><a class="reference internal" href="#performing-the-time-integration" id="id88">Performing the Time Integration</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#computing-frequency-response-functions" id="id89">Computing Frequency Response Functions</a></p>
<ul>
<li><p><a class="reference internal" href="#code-based-frequency-response-function-computations" id="id90">Code-based Frequency Response Function Computations</a></p></li>
<li><p><a class="reference internal" href="#mode-indicator-functions" id="id91">Mode Indicator Functions</a></p></li>
<li><p><a class="reference internal" href="#graphical-frequency-response-function-computation" id="id92">Graphical Frequency Response Function Computation</a></p></li>
<li><p><a class="reference internal" href="#plotting-deflection-shapes" id="id93">Plotting Deflection Shapes</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#fitting-modes-to-frequency-response-functions" id="id94">Fitting Modes to Frequency Response Functions</a></p>
<ul>
<li><p><a class="reference internal" href="#polypy" id="id95">PolyPy</a></p></li>
<li><p><a class="reference internal" href="#synthesize-modes-and-correlate-smac" id="id96">Synthesize Modes and Correlate (SMAC)</a></p></li>
</ul>
</li>
<li><p><a class="reference internal" href="#comparing-modes" id="id97">Comparing Modes</a></p></li>
<li><p><a class="reference internal" href="#adding-another-beam" id="id98">Adding Another Beam</a></p></li>
<li><p><a class="reference internal" href="#applying-constraints-to-the-system" id="id99">Applying Constraints to the System</a></p></li>
<li><p><a class="reference internal" href="#frequency-based-substructuring" id="id100">Frequency-Based Substructuring</a></p></li>
</ul>
</li>
</ul>
</div>
<section id="imports">
<h2><a class="toc-backref" href="#id65">Imports</a><a class="headerlink" href="#imports" title="Permalink to this heading"></a></h2>
<p>In order to use SDynPy, we will need to import it into our Python script.  We
will alias <code class="docutils literal notranslate"><span class="pre">sdynpy</span></code> as <code class="docutils literal notranslate"><span class="pre">sdpy</span></code> to make it somewhat shorter to type.</p>
<p>We will also import <code class="docutils literal notranslate"><span class="pre">numpy</span></code> and <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> for numerics and 2D plotting,
respectively.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sdynpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">sdpy</span>           <span class="c1"># For Structural Dynamics</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>              <span class="c1"># For Numerics</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">matplotlib.pyplot</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">plt</span> <span class="c1"># For 2D Plotting</span>
</pre></div>
</div>
</section>
<section id="creating-a-simple-beam-model">
<h2><a class="toc-backref" href="#id66">Creating a Simple Beam Model</a><a class="headerlink" href="#creating-a-simple-beam-model" title="Permalink to this heading"></a></h2>
<p>In structural dynamics, beams are the classic academic structure, so we will
start with one here.  We will create a beam using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.beam" title="sdynpy.core.sdynpy_system.System.beam"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.System.beam</span></code></a> class method,
which returns a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object as well as a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object representing the
beam.  The beam will be 20 cm x 1 cm x 0.5 cm and made out of steel.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">system</span><span class="p">,</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">System</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span>
    <span class="n">length</span> <span class="o">=</span> <span class="mf">0.2</span><span class="p">,</span> <span class="c1"># Meters</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="c1"># Meters</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="c1"># Meters</span>
    <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">21</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s1">&#39;steel&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="geometry-in-sdynpy">
<h2><a class="toc-backref" href="#id67">Geometry in SDynPy</a><a class="headerlink" href="#geometry-in-sdynpy" title="Permalink to this heading"></a></h2>
<p>We will first explore the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">geometry</span></code></a> object that was
created by the previous method.  Typing <code class="docutils literal notranslate"><span class="pre">geometry</span></code> into the Python console
after running the previous method will print a representation of the geometry
object.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [1]: geometry</span>
<span class="go">Out[1]:</span>
<span class="go">Node</span>
<span class="go">   Index,     ID,        X,        Y,        Z, DefCS, DisCS</span>
<span class="go">    (0,),      1,    0.000,    0.000,    0.000,     1,     1</span>
<span class="go">    (1,),      2,    0.010,    0.000,    0.000,     1,     1</span>
<span class="go">    (2,),      3,    0.020,    0.000,    0.000,     1,     1</span>
<span class="go">    (3,),      4,    0.030,    0.000,    0.000,     1,     1</span>
<span class="go">    (4,),      5,    0.040,    0.000,    0.000,     1,     1</span>
<span class="go">    (5,),      6,    0.050,    0.000,    0.000,     1,     1</span>
<span class="go">    (6,),      7,    0.060,    0.000,    0.000,     1,     1</span>
<span class="go">    (7,),      8,    0.070,    0.000,    0.000,     1,     1</span>
<span class="go">    (8,),      9,    0.080,    0.000,    0.000,     1,     1</span>
<span class="go">    (9,),     10,    0.090,    0.000,    0.000,     1,     1</span>
<span class="go">   (10,),     11,    0.100,    0.000,    0.000,     1,     1</span>
<span class="go">   (11,),     12,    0.110,    0.000,    0.000,     1,     1</span>
<span class="go">   (12,),     13,    0.120,    0.000,    0.000,     1,     1</span>
<span class="go">   (13,),     14,    0.130,    0.000,    0.000,     1,     1</span>
<span class="go">   (14,),     15,    0.140,    0.000,    0.000,     1,     1</span>
<span class="go">   (15,),     16,    0.150,    0.000,    0.000,     1,     1</span>
<span class="go">   (16,),     17,    0.160,    0.000,    0.000,     1,     1</span>
<span class="go">   (17,),     18,    0.170,    0.000,    0.000,     1,     1</span>
<span class="go">   (18,),     19,    0.180,    0.000,    0.000,     1,     1</span>
<span class="go">   (19,),     20,    0.190,    0.000,    0.000,     1,     1</span>
<span class="go">   (20,),     21,    0.200,    0.000,    0.000,     1,     1</span>

<span class="go">Coordinate_system</span>
<span class="go">   Index,     ID,                 Name, Color,       Type</span>
<span class="go">    (0,),      1,                     ,     1,  Cartesian</span>

<span class="go">Traceline</span>
<span class="go">   Index,     ID,          Description, Color, # Nodes</span>
<span class="go">    (0,),      1,                     ,     1,      21</span>

<span class="go">Element</span>
<span class="go">   Index,     ID, Type, Color, # Nodes</span>
<span class="go">----------- Empty -------------</span>
</pre></div>
</div>
<p>Here we see there are four “sections” of a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">geometry</span></code></a> object.  These are</p>
<blockquote>
<div><ol class="arabic simple">
<li><p>Nodes – define the positions of points in space as well as assigning
coordinate systems to those points in space</p></li>
<li><p>Coordinate Systems – define various coordinate systems in the model,
which could be used for defining node positions or defining the
displacement directions of nodes</p></li>
<li><p>Tracelines – define 1D connections between nodes that are used to aid in
visualizing the geometry</p></li>
<li><p>Elements – define 2D or 3D connections between nodes that are used to
aid in visualizing the geometry.</p></li>
</ol>
</div></blockquote>
<p>The present <code class="docutils literal notranslate"><span class="pre">geometry</span></code> has 21 nodes, 1 coordinate system, 1 traceline
containing 21 nodes, and no elements.  We can access the different sections of
the geometry by accessing the <code class="docutils literal notranslate"><span class="pre">node</span></code>, <code class="docutils literal notranslate"><span class="pre">coordinate_system</span></code>, <code class="docutils literal notranslate"><span class="pre">traceline</span></code>,
or <code class="docutils literal notranslate"><span class="pre">element</span></code> attributes of the object, for example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [2]: geometry.node</span>
<span class="go">Out[2]:</span>
<span class="go">   Index,     ID,        X,        Y,        Z, DefCS, DisCS</span>
<span class="go">    (0,),      1,    0.000,    0.000,    0.000,     1,     1</span>
<span class="go">    (1,),      2,    0.010,    0.000,    0.000,     1,     1</span>
<span class="go">    (2,),      3,    0.020,    0.000,    0.000,     1,     1</span>
<span class="go">    (3,),      4,    0.030,    0.000,    0.000,     1,     1</span>
<span class="go">    (4,),      5,    0.040,    0.000,    0.000,     1,     1</span>
<span class="go">    (5,),      6,    0.050,    0.000,    0.000,     1,     1</span>
<span class="go">    (6,),      7,    0.060,    0.000,    0.000,     1,     1</span>
<span class="go">    (7,),      8,    0.070,    0.000,    0.000,     1,     1</span>
<span class="go">    (8,),      9,    0.080,    0.000,    0.000,     1,     1</span>
<span class="go">    (9,),     10,    0.090,    0.000,    0.000,     1,     1</span>
<span class="go">   (10,),     11,    0.100,    0.000,    0.000,     1,     1</span>
<span class="go">   (11,),     12,    0.110,    0.000,    0.000,     1,     1</span>
<span class="go">   (12,),     13,    0.120,    0.000,    0.000,     1,     1</span>
<span class="go">   (13,),     14,    0.130,    0.000,    0.000,     1,     1</span>
<span class="go">   (14,),     15,    0.140,    0.000,    0.000,     1,     1</span>
<span class="go">   (15,),     16,    0.150,    0.000,    0.000,     1,     1</span>
<span class="go">   (16,),     17,    0.160,    0.000,    0.000,     1,     1</span>
<span class="go">   (17,),     18,    0.170,    0.000,    0.000,     1,     1</span>
<span class="go">   (18,),     19,    0.180,    0.000,    0.000,     1,     1</span>
<span class="go">   (19,),     20,    0.190,    0.000,    0.000,     1,     1</span>
<span class="go">   (20,),     21,    0.200,    0.000,    0.000,     1,     1</span>
</pre></div>
</div>
<section id="nodes">
<h3><a class="toc-backref" href="#id68">Nodes</a><a class="headerlink" href="#nodes" title="Permalink to this heading"></a></h3>
<p>We will start by exploring the nodes of the geometry, which are stored as a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> object revealed by
<code class="docutils literal notranslate"><span class="pre">geometry.node</span></code>.  The
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> class is a subclass of
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>, which is
itself a subclass of NumPy’s
<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html">ndarray</a>.
All subclasses of <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>
can therefore take advantage of NumPy functions such as <code class="docutils literal notranslate"><span class="pre">intersect1d</span></code>,
<code class="docutils literal notranslate"><span class="pre">unique</span></code>, or <code class="docutils literal notranslate"><span class="pre">concatenate</span></code> and also handle indexing and broadcasting
identically to the NumPy <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<p>Subclasses of <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>
store their data internally as a structured array variant of the <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.
This allows multiple data fields to be stored within each entry of the array.
For example, the above has 21 nodes, and each node has an identification number,
a position in space, and other information defined information defined.
However, as an alternative to accessing the field data using the syntax
<code class="docutils literal notranslate"><span class="pre">array['fieldname']</span></code>,
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a> allows accessing
the fields as if they were attributes using the syntax <code class="docutils literal notranslate"><span class="pre">array.fieldname</span></code>.
Many integrated development environments will not recognize these added attributes
so all <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a> subclasses
have a <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray.fields" title="sdynpy.core.sdynpy_array.SdynpyArray.fields"><code class="xref py py-attr docutils literal notranslate"><span class="pre">fields</span></code></a>
attribute that lists the fields stored in the array that can be accessed.</p>
<p>Returning to the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">geometry.node</span></code></a>, we can
identify the fields in the object using the command</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [3]: geometry.node.fields</span>
<span class="go">Out[3]: (&#39;id&#39;, &#39;coordinate&#39;, &#39;color&#39;, &#39;def_cs&#39;, &#39;disp_cs&#39;)</span>
</pre></div>
</div>
<p>Here we see the five fields of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> object.  We can
obtain even more information about the shape and type of each of these fields
using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> attribute, which is inherited from NumPy’s <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [4]: geometry.node.dtype</span>
<span class="go">Out[4]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;coordinate&#39;, &#39;&lt;f8&#39;, (3,)),</span>
<span class="go">               (&#39;color&#39;, &#39;&lt;u2&#39;), (&#39;def_cs&#39;, &#39;&lt;u8&#39;), (&#39;disp_cs&#39;, &#39;&lt;u8&#39;)])</span>
</pre></div>
</div>
<p>Here we see that the <code class="docutils literal notranslate"><span class="pre">geometry.node.id</span></code> array, which contains the node ID
number, is a 8-byte (64-bit) unsigned integer.  The <code class="docutils literal notranslate"><span class="pre">geometry.node.disp_cs</span></code>
and <code class="docutils literal notranslate"><span class="pre">geometry.node.def_cs</span></code> arrays, which contain references to the
coordinate system in which the node is defined and in which the node
displaces, respectively, are also this data type.  The <code class="docutils literal notranslate"><span class="pre">geometry.node.color</span></code>
array, while still an unsigned integer, is only 2 bytes, or 16 bits.  Finally,
the <code class="docutils literal notranslate"><span class="pre">geometry.node.coordinate</span></code>, which contains the 3D position of the node
as defined in the <code class="docutils literal notranslate"><span class="pre">geometry.node.def_cs</span></code> coordinate system, consists of
8-byte (64-bit)
floating-point data, and also has a shape of <code class="docutils literal notranslate"><span class="pre">(3,)</span></code>, which signifies there
are three values of the coordinate for each entry in the <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code>
array.  These extra dimensions of the field arrays are appended at the end of
dimension of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_array.SdynpyArray.html#sdynpy.core.sdynpy_array.SdynpyArray" title="sdynpy.core.sdynpy_array.SdynpyArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">SdynpyArray</span></code></a>
subclass.  For example, if we compare the shape of the <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code> array
to the <code class="docutils literal notranslate"><span class="pre">geometry.node.coordinate</span></code> array, we will see that the shapes are
identical except for the appending of the length-3 extra dimension on the
latter array.  Here the <code class="docutils literal notranslate"><span class="pre">shape</span></code> attribute is also an attribute inherited
from NumPy’s <code class="docutils literal notranslate"><span class="pre">ndarray</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [5]: geometry.node.shape</span>
<span class="go">Out[5]: (21,)</span>

<span class="go">In [6]: geometry.node.coordinate.shape</span>
<span class="go">Out[6]: (21, 3)</span>
</pre></div>
</div>
<p>We see that the shape of our <code class="docutils literal notranslate"><span class="pre">geometry.node</span></code> array is 21, meaning the
geometry we are examining has that many nodes.  We then see that the shape of
our <code class="docutils literal notranslate"><span class="pre">geometry.node.coordinate</span></code> array is 21 x 3, showing that there are
three coordinate values for each of the 21 nodes.</p>
</section>
<section id="coordinate-systems">
<h3><a class="toc-backref" href="#id69">Coordinate Systems</a><a class="headerlink" href="#coordinate-systems" title="Permalink to this heading"></a></h3>
<p>Coordinate systems in the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object are stored
in a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
object that can be accessed by <code class="docutils literal notranslate"><span class="pre">geometry.coordinate_system</span></code>.  We will again
explore the fields of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
using the <code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [7]: geometry.coordinate_system.dtype</span>
<span class="go">Out[7]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;name&#39;, &#39;&lt;U40&#39;), (&#39;color&#39;, &#39;&lt;u2&#39;),</span>
<span class="go">               (&#39;cs_type&#39;, &#39;&lt;u2&#39;), (&#39;matrix&#39;, &#39;&lt;f8&#39;, (4, 3))])</span>
</pre></div>
</div>
<p>We now see some new types of fields.  We still have <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code>,
which are consistent with the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> object we
previously explored.  We now have another integer field <code class="docutils literal notranslate"><span class="pre">cs_type</span></code> which
stores the type of coordinate system (0 - cartesian, 1 - cylindrical,
2 - spherical) in a 16-bit unsigned integer field.  We also have a <code class="docutils literal notranslate"><span class="pre">name</span></code>
field, which stores a name of the coordinate system in a string of less than
40 characters.  Finally, there is the coordinate system’s transformation matrix,
stored in the <code class="docutils literal notranslate"><span class="pre">matrix</span></code> field, which is stored in a 4 x 3 array of 64-bit
floating point numbers.  Again, recall the shape of the fields are appended to
the shape of the base object, so comparing the shape of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
to the shape of its <code class="docutils literal notranslate"><span class="pre">matrix</span></code> field, we will see that the latter has 2 extra
dimensions of length 4 and 3.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [8]: geometry.coordinate_system.shape</span>
<span class="go">Out[8]: (1,)</span>

<span class="go">In [9]: geometry.coordinate_system.matrix.shape</span>
<span class="go">Out[9]: (1, 4, 3)</span>
</pre></div>
</div>
<p>In SDynPy, the upper 3 rows of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray's</span></code></a>
<code class="docutils literal notranslate"><span class="pre">matrix</span></code> field represent a rotation matrix, whereas the last row represents a
translation vector.  The translation vector specifies the origin of the
coordinate system, and the rows of the rotation matrix represent the local
coordinate system directions.</p>
</section>
<section id="elements">
<h3><a class="toc-backref" href="#id70">Elements</a><a class="headerlink" href="#elements" title="Permalink to this heading"></a></h3>
<p>Elements in the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> are stored in an
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementArray</span></code></a> object, which
can be accessed using the <code class="docutils literal notranslate"><span class="pre">geometry.element</span></code> attribute.  The fields of this
object are</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [10]: geometry.element.dtype</span>
<span class="go">Out[10]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;type&#39;, &#39;u1&#39;), (&#39;color&#39;, &#39;&lt;u2&#39;),</span>
<span class="go">                (&#39;connectivity&#39;, &#39;O&#39;)])</span>
</pre></div>
</div>
<p>Like <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.NodeArray.html#sdynpy.core.sdynpy_geometry.NodeArray" title="sdynpy.core.sdynpy_geometry.NodeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NodeArray</span></code></a> and
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.CoordinateSystemArray.html#sdynpy.core.sdynpy_geometry.CoordinateSystemArray" title="sdynpy.core.sdynpy_geometry.CoordinateSystemArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateSystemArray</span></code></a>
objects, the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementArray</span></code></a>
object also has <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code> fields.  Each element also has a <code class="docutils literal notranslate"><span class="pre">type</span></code>
field, which is an 8-bit unsigned integer representing the element type as
defined by the universal file format dataset 2412.  Finally, the element
<code class="docutils literal notranslate"><span class="pre">connectivity</span></code> field is stored as an object array, where each entry in the
element array is a NumPy <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> with length equal to the number of nodes
in the element.  This construction is necessary as each element might have a
different number of nodes, so a single array of fixed size is not possible.</p>
<p>The current geometry has no elements associated with it, so if we compute its
shape, we will find that it has length zero.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [11]: geometry.element.shape</span>
<span class="go">Out[11]: (0,)</span>
</pre></div>
</div>
</section>
<section id="tracelines">
<h3><a class="toc-backref" href="#id71">Tracelines</a><a class="headerlink" href="#tracelines" title="Permalink to this heading"></a></h3>
<p>The final visualization tool in the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object is the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a>,
which represents a line connecting nodes in the geometry.  The fields of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a> object
are</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [12]: geometry.traceline.dtype</span>
<span class="go">Out[12]: dtype([(&#39;id&#39;, &#39;&lt;u8&#39;), (&#39;color&#39;, &#39;&lt;u2&#39;), (&#39;description&#39;, &#39;&lt;U40&#39;),</span>
<span class="go">                (&#39;connectivity&#39;, &#39;O&#39;)])</span>
</pre></div>
</div>
<p>Similarly to the other geometry objects,
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a> objects
have <code class="docutils literal notranslate"><span class="pre">id</span></code> and <code class="docutils literal notranslate"><span class="pre">color</span></code>, and like the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.ElementArray.html#sdynpy.core.sdynpy_geometry.ElementArray" title="sdynpy.core.sdynpy_geometry.ElementArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ElementArray</span></code></a> object, it
has a <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> array that specifies the node IDs to connect with a
line.  The <code class="docutils literal notranslate"><span class="pre">description</span></code> field stores a name or description of each item in
the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a> as
a string with less than 40 characters.</p>
<p>The present geometry has single traceline that connects all of the nodes in the
model.  Note that due to how object arrays are used in NumPy, investigating the
shape of the <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> field will not immediately tell the user how many
nodes are in each connectivity array, but will rather just return the shape of
the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.TracelineArray.html#sdynpy.core.sdynpy_geometry.TracelineArray" title="sdynpy.core.sdynpy_geometry.TracelineArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TracelineArray</span></code></a>
itself (note the dtype definition previously, where the <code class="docutils literal notranslate"><span class="pre">connectivity</span></code> field
has no additional shape associated with it).  However, if we actually index into
a single connectivity array, we can then see how big it is.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [13]: geometry.traceline.connectivity.shape</span>
<span class="go">Out[13]: (1,)</span>

<span class="go">In [14]: geometry.traceline.connectivity[0].shape</span>
<span class="go">Out[14]: (21,)</span>
</pre></div>
</div>
<p>The entries in the connectivity array will determine how the nodes are
connected.  We see here that the traceline connects each node together from 1
to 21.  Note that a <code class="docutils literal notranslate"><span class="pre">0</span></code> entry in a traceline array is equivalent to a line
break; the line will stop at the previous node and resume at the next node,
leaving a gap.  Discontinuous lines may also be constructed using multiple
tracelines.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [15]: geometry.traceline.connectivity[0]</span>
<span class="go">Out[15]:</span>
<span class="go">array([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16, 17,</span>
<span class="go">       18, 19, 20, 21])</span>
</pre></div>
</div>
</section>
<section id="plotting-geometry">
<h3><a class="toc-backref" href="#id72">Plotting Geometry</a><a class="headerlink" href="#plotting-geometry" title="Permalink to this heading"></a></h3>
<p>While it can be illustrative to examine the underlying data in a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object, the more
intuitive view is gained by plotting the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object.  SDynPy can
produce a 3D interactive representation of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object by calling its
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot" title="sdynpy.core.sdynpy_geometry.Geometry.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot</span></code></a> method.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id4">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Geometry.png"><img alt="beam geometry" src="_images/Showcase_Beam_Geometry.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Geometry of the Beam</span><a class="headerlink" href="#id4" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="systems-in-sdynpy">
<h2><a class="toc-backref" href="#id73">Systems in SDynPy</a><a class="headerlink" href="#systems-in-sdynpy" title="Permalink to this heading"></a></h2>
<p>The <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object is designed to
store the mass, stiffness, and damping matrices associated with a dynamic
system.  These are stored in the <code class="docutils literal notranslate"><span class="pre">mass</span></code>, <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>, and <code class="docutils literal notranslate"><span class="pre">damping</span></code>
attributes of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object.</p>
<p>Typing <code class="docutils literal notranslate"><span class="pre">system</span></code> into the into the Python console will report the number of
the degrees of freedom in the system.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [16]: system</span>
<span class="go">Out[16]: System with 126 DoFs (126 internal DoFs)</span>
</pre></div>
</div>
<p>We can plot the system matrices to see the element connectivity.  Each matrix
should have numbers of rows and columns equal to the reported number of internal
degrees of freedom, which will be 126 for this</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the figure and axes</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;System Matrices&#39;</span><span class="p">,</span>
                      <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1"># Plot the matrices</span>
<span class="n">mimg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="n">dimg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">damping</span><span class="p">)</span>
<span class="n">simg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">stiffness</span><span class="p">)</span>
<span class="c1"># Add colorbar</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mimg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">dimg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">simg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="c1"># Label each plot</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Mass&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Damping&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stiffness&#39;</span><span class="p">)</span>
<span class="c1"># Set to tight layout</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id5">
<a class="reference internal image-reference" href="_images/Showcase_Beam_System_Matrices.png"><img alt="System matrices" src="_images/Showcase_Beam_System_Matrices.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Mass, Stiffness, and Damping matrices for the <code class="docutils literal notranslate"><span class="pre">system</span></code> object.</span><a class="headerlink" href="#id5" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Note that due to the system deriving from a finite element model, the damping
is zero.</p>
<p>In addition to the <code class="docutils literal notranslate"><span class="pre">mass</span></code>, <code class="docutils literal notranslate"><span class="pre">stiffness</span></code>, and <code class="docutils literal notranslate"><span class="pre">damping</span></code> matrices, SDynPy
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> objects also track
transformations between internal state degrees of freedom, as well as which
degrees of freedom are associated with rows and columns of the matrices.</p>
<p>For the current <code class="docutils literal notranslate"><span class="pre">system</span></code> object, the transformation, accessed using the
<code class="docutils literal notranslate"><span class="pre">system.transformation</span></code> attribute, is the identity matrix.
This is because the system matrices are already represented in physical
coordinates.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Create the figure and axes</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;System Transformation&#39;</span><span class="p">,</span>
                      <span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span><span class="mf">3.5</span><span class="p">))</span>
<span class="c1"># Plot the matrices</span>
<span class="n">timg</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span>
<span class="c1"># Add colorbar</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">timg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">)</span>
<span class="c1"># Label each plot</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Transformation&#39;</span><span class="p">)</span>
<span class="c1"># Set to tight layout</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id6">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Transformation.png"><img alt="System matrices" src="_images/Showcase_Beam_Transformation.png" style="width: 300px;" /></a>
<figcaption>
<p><span class="caption-text">Transformation matrix for the <code class="docutils literal notranslate"><span class="pre">system</span></code> object.</span><a class="headerlink" href="#id6" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The degrees of freedom corresponding to the rows and columns of the system
matrices can be accessed using the <code class="docutils literal notranslate"><span class="pre">system.coordinate</span></code> attribute.  This
provides a <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object containing the degrees of freedom (node and local direction).</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [17]: system.coordinate</span>
<span class="go">Out[17]:</span>
<span class="go">coordinate_array(string_array=</span>
<span class="go">array([&#39;1X+&#39;, &#39;1Y+&#39;, &#39;1Z+&#39;, &#39;1RX+&#39;, &#39;1RY+&#39;, &#39;1RZ+&#39;, &#39;2X+&#39;, &#39;2Y+&#39;, &#39;2Z+&#39;,</span>
<span class="go">       &#39;2RX+&#39;, &#39;2RY+&#39;, &#39;2RZ+&#39;, &#39;3X+&#39;, &#39;3Y+&#39;, &#39;3Z+&#39;, &#39;3RX+&#39;, &#39;3RY+&#39;,</span>
<span class="go">       &#39;3RZ+&#39;, &#39;4X+&#39;, &#39;4Y+&#39;, &#39;4Z+&#39;, &#39;4RX+&#39;, &#39;4RY+&#39;, &#39;4RZ+&#39;, &#39;5X+&#39;, &#39;5Y+&#39;,</span>
<span class="go">       &#39;5Z+&#39;, &#39;5RX+&#39;, &#39;5RY+&#39;, &#39;5RZ+&#39;, &#39;6X+&#39;, &#39;6Y+&#39;, &#39;6Z+&#39;, &#39;6RX+&#39;, &#39;6RY+&#39;,</span>
<span class="go">       &#39;6RZ+&#39;, &#39;7X+&#39;, &#39;7Y+&#39;, &#39;7Z+&#39;, &#39;7RX+&#39;, &#39;7RY+&#39;, &#39;7RZ+&#39;, &#39;8X+&#39;, &#39;8Y+&#39;,</span>
<span class="go">       &#39;8Z+&#39;, &#39;8RX+&#39;, &#39;8RY+&#39;, &#39;8RZ+&#39;, &#39;9X+&#39;, &#39;9Y+&#39;, &#39;9Z+&#39;, &#39;9RX+&#39;, &#39;9RY+&#39;,</span>
<span class="go">       &#39;9RZ+&#39;, &#39;10X+&#39;, &#39;10Y+&#39;, &#39;10Z+&#39;, &#39;10RX+&#39;, &#39;10RY+&#39;, &#39;10RZ+&#39;, &#39;11X+&#39;,</span>
<span class="go">       &#39;11Y+&#39;, &#39;11Z+&#39;, &#39;11RX+&#39;, &#39;11RY+&#39;, &#39;11RZ+&#39;, &#39;12X+&#39;, &#39;12Y+&#39;, &#39;12Z+&#39;,</span>
<span class="go">       &#39;12RX+&#39;, &#39;12RY+&#39;, &#39;12RZ+&#39;, &#39;13X+&#39;, &#39;13Y+&#39;, &#39;13Z+&#39;, &#39;13RX+&#39;,</span>
<span class="go">       &#39;13RY+&#39;, &#39;13RZ+&#39;, &#39;14X+&#39;, &#39;14Y+&#39;, &#39;14Z+&#39;, &#39;14RX+&#39;, &#39;14RY+&#39;,</span>
<span class="go">       &#39;14RZ+&#39;, &#39;15X+&#39;, &#39;15Y+&#39;, &#39;15Z+&#39;, &#39;15RX+&#39;, &#39;15RY+&#39;, &#39;15RZ+&#39;, &#39;16X+&#39;,</span>
<span class="go">       &#39;16Y+&#39;, &#39;16Z+&#39;, &#39;16RX+&#39;, &#39;16RY+&#39;, &#39;16RZ+&#39;, &#39;17X+&#39;, &#39;17Y+&#39;, &#39;17Z+&#39;,</span>
<span class="go">       &#39;17RX+&#39;, &#39;17RY+&#39;, &#39;17RZ+&#39;, &#39;18X+&#39;, &#39;18Y+&#39;, &#39;18Z+&#39;, &#39;18RX+&#39;,</span>
<span class="go">       &#39;18RY+&#39;, &#39;18RZ+&#39;, &#39;19X+&#39;, &#39;19Y+&#39;, &#39;19Z+&#39;, &#39;19RX+&#39;, &#39;19RY+&#39;,</span>
<span class="go">       &#39;19RZ+&#39;, &#39;20X+&#39;, &#39;20Y+&#39;, &#39;20Z+&#39;, &#39;20RX+&#39;, &#39;20RY+&#39;, &#39;20RZ+&#39;, &#39;21X+&#39;,</span>
<span class="go">       &#39;21Y+&#39;, &#39;21Z+&#39;, &#39;21RX+&#39;, &#39;21RY+&#39;, &#39;21RZ+&#39;], dtype=&#39;&lt;U5&#39;))</span>
</pre></div>
</div>
<section id="coordinates">
<h3><a class="toc-backref" href="#id74">Coordinates</a><a class="headerlink" href="#coordinates" title="Permalink to this heading"></a></h3>
<p>Here again is a good place to explore what makes up a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object.  We can examine the data type of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
to see that it contains fields for a 64-bit unsigned integer as the <code class="docutils literal notranslate"><span class="pre">node</span></code>
field and an 8-bit signed integer for the <code class="docutils literal notranslate"><span class="pre">direction</span></code> field.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [18]: system.coordinate.dtype</span>
<span class="go">Out[18]: dtype([(&#39;node&#39;, &#39;&lt;u8&#39;), (&#39;direction&#39;, &#39;i1&#39;)])</span>
</pre></div>
</div>
<p><a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects store the direction as an integer with encoding:</p>
<table class="docutils align-default">
<colgroup>
<col style="width: 40%" />
<col style="width: 60%" />
</colgroup>
<thead>
<tr class="row-odd"><th class="head"><p>Direction</p></th>
<th class="head"><p>Integer Encoding</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>X+</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>Y+</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-even"><td><p>Z+</p></td>
<td><p>3</p></td>
</tr>
<tr class="row-odd"><td><p>RX+</p></td>
<td><p>4</p></td>
</tr>
<tr class="row-even"><td><p>RY+</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>RZ+</p></td>
<td><p>6</p></td>
</tr>
<tr class="row-even"><td><p>X-</p></td>
<td><p>-1</p></td>
</tr>
<tr class="row-odd"><td><p>Y-</p></td>
<td><p>-2</p></td>
</tr>
<tr class="row-even"><td><p>Z-</p></td>
<td><p>-3</p></td>
</tr>
<tr class="row-odd"><td><p>RX-</p></td>
<td><p>-4</p></td>
</tr>
<tr class="row-even"><td><p>RY-</p></td>
<td><p>-5</p></td>
</tr>
<tr class="row-odd"><td><p>RZ-</p></td>
<td><p>-6</p></td>
</tr>
<tr class="row-even"><td><p>None</p></td>
<td><p>0</p></td>
</tr>
</tbody>
</table>
<p>Note that the directions with <code class="docutils literal notranslate"><span class="pre">R</span></code> are rotations about the respective axis.</p>
<p>When we want to examine
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects, the integer directions are typically transformed into the more
readable direction strings shown in the first column of the above table.  For
example, if we type a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a> object
into the console, the representation of the
object displays the string array version of the coordinates, as shown above.</p>
<p>From the above, we can see that the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> we just created
contains a degree of freedom for each of the positive X, Y, Z translations and
each of the positive X, Y, Z rotations each node.</p>
<p>Many SDynPy objects allow indexing with a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object to automatically handle the bookkeeping aspect of selecting the right
data for each coordinate.</p>
</section>
<section id="plotting-coordinates">
<h3><a class="toc-backref" href="#id75">Plotting Coordinates</a><a class="headerlink" href="#plotting-coordinates" title="Permalink to this heading"></a></h3>
<p>At this point, we would like to plot our coordinates on top of our geometry.
For this we use the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_coordinate" title="sdynpy.core.sdynpy_geometry.Geometry.plot_coordinate"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_coordinate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">system</span><span class="o">.</span><span class="n">coordinate</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
</pre></div>
</div>
<p>Note that due to the density of the mesh, we had to make the <code class="docutils literal notranslate"><span class="pre">arrow_scale</span></code>
smaller than the default, otherwise the arrows would overlap.</p>
<figure class="align-center" id="id7">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Coordinates.png"><img alt="beam coordinates" src="_images/Showcase_Beam_Coordinates.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Coordinates defined on the beam.</span><a class="headerlink" href="#id7" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>If we zoom into the coordinate systems on the figure, we see more clearly that
there are rotations and translations defined at each node.</p>
<figure class="align-center" id="id8">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Coordinates_Zoomed.png"><img alt="beam coordinates zoomed" src="_images/Showcase_Beam_Coordinates_Zoomed.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Zoom of coordinates defined on the beam.</span><a class="headerlink" href="#id8" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
</section>
<section id="computing-modes-of-the-system">
<h2><a class="toc-backref" href="#id76">Computing Modes of the System</a><a class="headerlink" href="#computing-modes-of-the-system" title="Permalink to this heading"></a></h2>
<p>With mass, stiffness, and damping matrices, there are several types of
structural dynamics analyses that could be performed.  One popular analysis
that is performed in structural dynamics is modal analysis.  In this type of
analysis, we will compute the
<a class="reference external" href="modal_tutorials/Modal_04_Modal_Analysis/Modal_04_Modal_Analysis.html#Solving-for-the-Eigenvalues">Generalized Eigensolution</a>
of the mass and stiffness matrices.  While we could extract these matrices from
the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object and perform
the eigensolution using a linear algebra package such as that in SciPy, we can
instead use the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.eigensolution" title="sdynpy.core.sdynpy_system.System.eigensolution"><code class="xref py py-func docutils literal notranslate"><span class="pre">System.eigensolution</span></code></a>
method to compute the modes and handle all of the bookkeeping.  This method
accepts arguments to determine which modes to compute.  For example, we can
easily compute all modes below a certain frequency (say 4000 Hz).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">eigensolution</span><span class="p">(</span><span class="n">maximum_frequency</span><span class="o">=</span><span class="mi">4000</span><span class="p">)</span>
</pre></div>
</div>
<p>This produces a <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>
object, which is used by SDynPy to represent mode shapes and deflection shapes.</p>
<p>We can type the variable name <code class="docutils literal notranslate"><span class="pre">shapes</span></code> into the Python console to see more
information about the mode shapes.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [19]: shapes</span>
<span class="go">Out[19]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0153,    0.0000%,        126</span>
<span class="go">    (4,),     0.0153,    0.0000%,        126</span>
<span class="go">    (5,),     0.0153,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>Here we see there were 11 modes below 4000 Hz.  6 of the modes are rigid body
modes, with natural frequency of approximately 0 Hz.  5 of the modes are elastic
modes.  Each of the modes has 0% damping (due to the damping matrix being equal
to the zero matrix), and each mode has 126 degrees of freedom.</p>
<section id="shapes">
<h3><a class="toc-backref" href="#id77">Shapes</a><a class="headerlink" href="#shapes" title="Permalink to this heading"></a></h3>
<p>At this point, it is useful to explore briefly the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object in the
Python console.  The data type of the object is:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [20]: shapes.dtype</span>
<span class="go">Out[20]: dtype([(&#39;frequency&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                (&#39;damping&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                (&#39;coordinate&#39;, [(&#39;node&#39;, &#39;&lt;u8&#39;),</span>
<span class="go">                                (&#39;direction&#39;, &#39;i1&#39;)], (126,)),</span>
<span class="go">                (&#39;shape_matrix&#39;, &#39;&lt;f8&#39;, (126,)),</span>
<span class="go">                (&#39;modal_mass&#39;, &#39;&lt;f8&#39;),</span>
<span class="go">                (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment5&#39;, &#39;&lt;U80&#39;)])</span>
</pre></div>
</div>
<p>The data type of
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> objects can change
depending on what type of shape and how many degrees of freedom are in the
shape.  <code class="docutils literal notranslate"><span class="pre">frequency</span></code> and <code class="docutils literal notranslate"><span class="pre">damping</span></code> fields are stored as 64-bit floating
point numbers with one value per entry in the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>.  <code class="docutils literal notranslate"><span class="pre">modal_mass</span></code>
is also stored in the present
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>, but if the shape
is complex, then the modal mass might also be complex.  The <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code>
field holds the underlying shape data.  It has one entry for every degree of
freedom in the shape, and is represented by a floating point number for
normal modes or a complex number for complex modes.  Similarly, the
<code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field identifies which degree of freedom belongs to which entry
in the <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field.  The <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field stores data as
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects, and thus has the same data type as
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>.
Finally, there are five fields available for comments, which store string data
up to 80 characters which can be used to store any data the user feels is
relevant to the analysis.</p>
<p>One thing to note is that the <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field, due to the dimension of
the field being appended at the end of the array, will be transposed from the
typical representation of a mode shape matrix (degrees of freedom as rows and
mode indices as columns). The <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field will instead have the
shape of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>
object itself as its first dimensions, and then the size of the <code class="docutils literal notranslate"><span class="pre">coordinate</span></code>
field as its last dimension.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [21]: shapes.shape</span>
<span class="go">Out[21]: (11,)</span>

<span class="go">In [22]: shapes.shape_matrix.shape</span>
<span class="go">Out[22]: (11, 126)</span>
</pre></div>
</div>
<p>To access the mode shape matrix in a more familiar format, users can instead
access the <code class="docutils literal notranslate"><span class="pre">modeshape</span></code> attribute of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object.  This will
be identical data to the <code class="docutils literal notranslate"><span class="pre">shape_matrix</span></code> field, except it will have the last
two dimensions of the array transposed.  For a 1D array of shapes, this will
produce a modeshape matrix with degrees of freedom indices as the rows of the
matrix and mode indices as the columns of the matrix.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [23]: shapes.modeshape.shape</span>
<span class="go">Out[23]: (126, 11)</span>
</pre></div>
</div>
</section>
<section id="plotting-shapes">
<h3><a class="toc-backref" href="#id78">Plotting Shapes</a><a class="headerlink" href="#plotting-shapes" title="Permalink to this heading"></a></h3>
<p>While it may be useful to access the raw mode shape data in matrix form, the most
intutive view of the shapes is often obtained when the shapes are plotted on
the geometry.  This is easily done in SDynPy by using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_shape" title="sdynpy.core.sdynpy_geometry.Geometry.plot_shape"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_shape</span></code></a> method of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object, and passing
the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object as the
argument.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>
</pre></div>
</div>
<p>This will bring up the shape plotter window, shown below.</p>
<figure class="align-center" id="id9">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Shape_Plotter_Overview.png"><img alt="shape plotter window" src="_images/Showcase_Beam_Shape_Plotter_Overview.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Shape Plotter window that appears when modes are plotted on the geometry.</span><a class="headerlink" href="#id9" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The Shape Plotter window is an interactive, animated 3D plot that allows users
to visualize the mode shapes of the system.  We will briefly highlight some of
the key features of this tool.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">File</span></code> menu contains tools for saving images from the window.  The
<code class="docutils literal notranslate"><span class="pre">Take</span> <span class="pre">Screenshot</span></code> action allows saving an image of the current window.  The
<code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">Animation</span></code> action will save an animated GIF of the shape from the
current view.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">View</span></code> menu contains tools for adjusting the view of the window, as well
as plotting utility widgets.  The <code class="docutils literal notranslate"><span class="pre">Camera</span></code> <code class="docutils literal notranslate"><span class="pre">Toggle</span> <span class="pre">Parallel</span> <span class="pre">Projection</span></code>
action will switch between perspective and parallel camera projections.  A
small coordinate axis triad can be plotted by displaying the
<code class="docutils literal notranslate"><span class="pre">Orientation</span> <span class="pre">Marker</span></code>, and labelled axes can be plotted by selecting
<code class="docutils literal notranslate"><span class="pre">Bounds</span> <span class="pre">Axes</span></code>.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Shape</span></code> menu contains tools for adjusting how the shapes are presented.
The shape complexity can be adjusted, as well as the shape scaling and animation
speed.  The text showing the mode number, frequency, damping, and any comments
can also be shown or hidden.</p>
<p>The toolbars in the widget offer features as well.  The camera can be set to
several default views along the principal axes.  Camera views can be saved and
recalled as well.  The mode that is being shown can be changed by clicking the
<code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> buttons.  The animation can be started or stopped by pressing
the <code class="docutils literal notranslate"><span class="pre">Play</span></code> and <code class="docutils literal notranslate"><span class="pre">Stop</span></code> Buttons.</p>
<figure class="align-center" id="id10">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Mode_Animation.gif"><img alt="mode shape animation" src="_images/Showcase_Beam_Mode_Animation.gif" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Mode shape of the beam animated on the geometry.</span><a class="headerlink" href="#id10" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="assigning-to-sdynpy-array-fields-and-array-views-versus-copies">
<h3><a class="toc-backref" href="#id79">Assigning to SDynpy Array Fields and Array Views versus Copies</a><a class="headerlink" href="#assigning-to-sdynpy-array-fields-and-array-views-versus-copies" title="Permalink to this heading"></a></h3>
<p>Often, one may wish to assign values to specific fields of the SDynPy objects.
For example, the first six modes of the structure should be rigid body modes;
however, the eigensolution has left three of the first six natural frequencies
with small positive values.  Let’s set these values to zero.  SDynPy arrays,
as well as the fields of the arrays, inherit all properties of NumPy’s
<code class="docutils literal notranslate"><span class="pre">ndarray</span></code> object, and can therefore be indexed identically.  We can use this
indexing either to get specific portions of the array or to assign values to
certain portions of the array.  For example, if we want to assign the first
six natural frequencies to zero, we can use the command:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes</span><span class="o">.</span><span class="n">frequency</span><span class="p">[:</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
</pre></div>
</div>
<p>We can then check that the values are indeed set to zero.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [24]: shapes</span>
<span class="go">Out[24]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>Note that when utilizing NumPy <code class="docutils literal notranslate"><span class="pre">ndarray</span></code> objects, one should always be aware
what type of object is returned from an indexing or slicing operation.  NumPy
can either return a <em>copy</em> of the original array or a <em>view</em> into the original
array.  A <em>copy</em> is a completely new array that contains equivalent data to the
original array, but has no connection back to it.  Changing a value in a copy
of an array will not modify that same value in the original array.  A <em>view</em>
is simply a window into the original array, meaning it shares the same memory
as the original array.  Changing a value in a view of an array <em>will also modify</em>
the data in the original array.  Views are useful in that they do not duplicate
memory, so when working with large arrays, using views is much more efficient
than using copies.  However, if a user assumes that they are working with a
copy of an array but are actually working with a view of an array, there may
be unintended side-effects when the value of the original array is unintentionally
modified.  For a full treatment of indexing in NumPy, users are directed to the
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">documentation on indexing</a>
for NumPy <code class="docutils literal notranslate"><span class="pre">ndarrays</span></code>.  The present documentation will simply show some examples
of when different types of indexing are used, and what the ramifications could
be if users are not careful.</p>
<section id="indexing-using-a-single-integer-index">
<h4><a class="toc-backref" href="#id80">Indexing using a Single Integer Index</a><a class="headerlink" href="#indexing-using-a-single-integer-index" title="Permalink to this heading"></a></h4>
<p>The simplest indexing approach for NumPy objects is to index with a single
integer.  This will generally return a view of the object.  For example, we can
access the first shape in the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object with the
syntax</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [25]: first_shape = shapes[0]</span>
</pre></div>
</div>
<p>If we then set the frequency of <code class="docutils literal notranslate"><span class="pre">first_shape</span></code> equal to some value, we will
see that our original shape matrix also has that value assigned as the first
frequency.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [26]: first_shape.frequency = 10</span>

<span class="go">In [27]: shapes</span>
<span class="go">Out[27]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),    10.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>Here we see that we assigned a variable when we modified <code class="docutils literal notranslate"><span class="pre">first_shape</span></code>’s
frequency to 10, the first frequency of <code class="docutils literal notranslate"><span class="pre">shapes</span></code> also became 10, because they
point to the same position in memory.</p>
</section>
<section id="indexing-using-a-slice">
<h4><a class="toc-backref" href="#id81">Indexing using a Slice</a><a class="headerlink" href="#indexing-using-a-slice" title="Permalink to this heading"></a></h4>
<p>A second common method of indexing an array is using a slice.  Slices can be
defined with a start index, a stop index, and a step size.  For example, a slice
<code class="docutils literal notranslate"><span class="pre">0:10:2</span></code> would return indices from zero up to just before 10, and only return
every second index, which would be 0, 2, 4, 6, and 8.</p>
<p>For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [29]: indexed_shapes = shapes[:6:2]</span>

<span class="go">In [30]: indexed_shapes.frequency = 2</span>

<span class="go">In [31]: shapes</span>
<span class="go">Out[31]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     2.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     2.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     2.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>We can see that the 0, 2, and 4 indices were set to have frequencies of 2, which
corresponds to the original slice.</p>
<p>Note we could also do the indexing directly on the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field.
For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [32]: indexed_frequencies = shapes.frequency[:6:2]</span>

<span class="go">In [33]: indexed_frequencies[:] = 3</span>

<span class="go">In [34]: shapes</span>
<span class="go">Out[34]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     3.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     3.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     3.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>Note the syntax <code class="docutils literal notranslate"><span class="pre">indexed_frequencies[:]</span> <span class="pre">=</span> <span class="pre">3</span></code>.  Had we simply typed
<code class="docutils literal notranslate"><span class="pre">indexed_frequencies</span> <span class="pre">=</span> <span class="pre">3</span></code>, this would have <em>not</em> overwritten the original
frequencies as this latter syntax is simply a redefinition of the variable
<code class="docutils literal notranslate"><span class="pre">indexed_frequencies</span></code> to a different value rather than a reassignment of the
values <em>in</em> <code class="docutils literal notranslate"><span class="pre">indexed_frequencies</span></code> to a different value.  The former syntax
reassigns values at the <code class="docutils literal notranslate"><span class="pre">indexed_frequencies</span></code> memory location, and the latter
assigns <code class="docutils literal notranslate"><span class="pre">indexed_frequencies</span></code> to a different memory location, which breaks
the connection to the original memory location, so <code class="docutils literal notranslate"><span class="pre">indexed_frequencies</span></code> is
no longer a view into <code class="docutils literal notranslate"><span class="pre">shapes</span></code>.  For example:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [35]: indexed_frequencies = 6</span>

<span class="go">In [36]: shapes</span>
<span class="go">Out[36]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     3.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     3.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     3.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>In the previous example the values of the 0, 2, and 4 frequency indices were
not modified from three to six.</p>
</section>
<section id="indexing-with-logical-arrays">
<h4><a class="toc-backref" href="#id82">Indexing with Logical Arrays</a><a class="headerlink" href="#indexing-with-logical-arrays" title="Permalink to this heading"></a></h4>
<p>NumPy <code class="docutils literal notranslate"><span class="pre">ndarrays</span></code> can also be indexed with logical (or boolean) arrays.  These
are arrays full of <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">False</span></code> values.  These are often returned due
to comparison operations.  For example, if we want all of the frequencies less
than ten hertz, we can perform the operation:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [37]: logical_array = shapes.frequency &lt; 10</span>

<span class="go">In [38]: logical_array</span>
<span class="go">Out[38]:</span>
<span class="go">array([ True,  True,  True,  True,  True,  True, False, False, False,</span>
<span class="go">       False, False])</span>
</pre></div>
</div>
<p>This last set of commands has produced a logical array where the first six
indices are <code class="docutils literal notranslate"><span class="pre">True</span></code> and the last five are <code class="docutils literal notranslate"><span class="pre">False</span></code>.  If we index the <code class="docutils literal notranslate"><span class="pre">shapes</span></code>
object with this, we will return only the shapes where the logical array is
<code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [39]: rigid_shapes = shapes[logical_array]</span>

<span class="go">In [40]: rigid_shapes</span>
<span class="go">Out[40]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     3.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     3.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     3.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
</pre></div>
</div>
<p>However, unlike the last indexing types, this type of indexing will generally
return a <em>copy</em> of the array, rather than a view into the array.  For example,
if we redefine values of the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field in <code class="docutils literal notranslate"><span class="pre">rigid_shapes</span></code>, it will
<strong>not</strong> update the frequency in the original <code class="docutils literal notranslate"><span class="pre">shapes</span></code> variable.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [41]: rigid_shapes.frequency = 0</span>

<span class="go">In [42]: rigid_shapes</span>
<span class="go">Out[42]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>

<span class="go">In [43]: shapes</span>
<span class="go">Out[43]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     3.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     3.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     3.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>Here we see that there is no memory link between <code class="docutils literal notranslate"><span class="pre">rigid_shapes</span></code> and <code class="docutils literal notranslate"><span class="pre">shapes</span></code>
because they have different values of their <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field.  Note that if
we wish to perform assignments using logical indexing, we need to make sure that
the indexing is performed as the last operation.  For example, consider the
following code.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [44]: shapes[logical_array].frequency = 0</span>

<span class="go">In [45]: shapes</span>
<span class="go">Out[45]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     3.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     3.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     3.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>Looking at the first command naively, it would seem that we would take the
shapes specified by <code class="docutils literal notranslate"><span class="pre">logical_array</span></code> (i.e. the first six modes) and assign their
frequencies to 0.  However, if we look at the contents of <code class="docutils literal notranslate"><span class="pre">shapes</span></code> immediately
afterwards, we can see that no such assignment has taken place.  Instead, the
first six modes have their original values of alternating three and zero.
If we think a bit harder and remember that we make a copy of the array when we
index with a logical array, we will realize that we have created a copy of the
first six modes of the <code class="docutils literal notranslate"><span class="pre">shapes</span></code> array, and assigned the frequencies of that
copy to zero.  However, since that copy was never assigned to any variable, it
is immediately discarded by the Python interpreter as unused.  The original
<code class="docutils literal notranslate"><span class="pre">shapes</span></code> array remains unmodified.  To achieve the desired result, we should
instead make sure the indexing occurs last.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [46]: shapes.frequency[logical_array] = 0</span>

<span class="go">In [47]: shapes</span>
<span class="go">Out[47]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>In this latter case, we have accessed the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field of the original
<code class="docutils literal notranslate"><span class="pre">shapes</span></code> array, rather than a copy of the <code class="docutils literal notranslate"><span class="pre">frequency</span></code> field, therefore when
we assign to those values, the original <code class="docutils literal notranslate"><span class="pre">shapes</span></code> array is modified.</p>
</section>
<section id="indexing-with-integer-arrays">
<h4><a class="toc-backref" href="#id83">Indexing with Integer Arrays</a><a class="headerlink" href="#indexing-with-integer-arrays" title="Permalink to this heading"></a></h4>
<p>The final indexing approach discussed here is indexing with integer arrays.
This is useful when specific indices are desired, but one does not want to set
up the entire logical array.  For example, to get the first six modes, we could
construct an integer array:</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [48]: integer_array = [0,1,2,3,4,5]</span>

<span class="go">In [49]: rigid_shapes = shapes[integer_array]</span>

<span class="go">In [50]: rigid_shapes</span>
<span class="go">Out[50]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
</pre></div>
</div>
<p>We can see that we were able to access the first six modes of <code class="docutils literal notranslate"><span class="pre">shapes</span></code> this
way.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [51]: rigid_shapes.frequency = 10</span>

<span class="go">In [52]: shapes</span>
<span class="go">Out[52]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.0000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.0000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.0000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.0000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.0000%,        126</span>
</pre></div>
</div>
<p>We can see that the changes to <code class="docutils literal notranslate"><span class="pre">rigid_shapes</span></code> were not propogated back to
<code class="docutils literal notranslate"><span class="pre">shapes</span></code>, because it is only a copy of the original array.</p>
<p>As a general rule of thumb, indexing using a single integer or slice produces a
view into the original array, but indexing with a logical or index array produces
a copy.  If the reader still does not understand these concepts, they are
encouraged to read and understand the NumPy
<a class="reference external" href="https://numpy.org/doc/stable/user/basics.indexing.html">documentation on indexing</a>,
otherwise misapplying these nuanced concepts can introduce bugs into analyses
performed using SDynPy.</p>
</section>
</section>
</section>
<section id="computing-a-modal-system">
<h2><a class="toc-backref" href="#id84">Computing a Modal System</a><a class="headerlink" href="#computing-a-modal-system" title="Permalink to this heading"></a></h2>
<p>Given that our <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object
came from a beam finite element model without any damping defined, it might be
useful to assign damping to the shapes to more realistically simulate a real
beam.  We will assign a small amount of damping to all modes.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes</span><span class="o">.</span><span class="n">damping</span> <span class="o">=</span> <span class="mf">0.005</span>
</pre></div>
</div>
<p>Now, if we investigate the <code class="docutils literal notranslate"><span class="pre">shapes</span></code> variable in the console, we will see
that the damping is no longer zero.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [53]: shapes</span>
<span class="go">Out[53]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.5000%,        126</span>
<span class="go">    (1,),     0.0000,    0.5000%,        126</span>
<span class="go">    (2,),     0.0000,    0.5000%,        126</span>
<span class="go">    (3,),     0.0000,    0.5000%,        126</span>
<span class="go">    (4,),     0.0000,    0.5000%,        126</span>
<span class="go">    (5,),     0.0000,    0.5000%,        126</span>
<span class="go">    (6,),   648.5603,    0.5000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.5000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.5000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.5000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.5000%,        126</span>
</pre></div>
</div>
<p>If we wanted to perform simulations with this new model that has damping
incorporated, we can easily transform the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> object into a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object by using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.system" title="sdynpy.core.sdynpy_shape.ShapeArray.system"><code class="xref py py-class docutils literal notranslate"><span class="pre">system</span></code></a> method of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> class.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">modal_system</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="n">system</span><span class="p">()</span>
</pre></div>
</div>
<p>This will construct a <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>
object, but unlike our original <code class="docutils literal notranslate"><span class="pre">system</span></code> variable, this <code class="docutils literal notranslate"><span class="pre">modal_system</span></code> will
be a <em>reduced</em> system.  Instead of the internal system states being equivalent
to physical degrees of freedom, the internal system states are now <em>modal</em>
degrees of freedom.</p>
<p>If we type the <code class="docutils literal notranslate"><span class="pre">modal_system</span></code> variable into the console, we see that while it
still has 126 degrees of freedom, it only contains 11 internal degrees of
freedom.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">In</span> <span class="p">[</span><span class="mi">53</span><span class="p">]:</span> <span class="n">modal_system</span>
<span class="n">Out</span><span class="p">[</span><span class="mi">53</span><span class="p">]:</span> <span class="n">System</span> <span class="k">with</span> <span class="mi">126</span> <span class="n">DoFs</span> <span class="p">(</span><span class="mi">11</span> <span class="n">internal</span> <span class="n">DoFs</span><span class="p">)</span>
</pre></div>
</div>
<p>We can plot the system matrices.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Plot the modal system matrices</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;Modal System Matrices&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">3</span><span class="p">))</span>
<span class="c1"># Transformation</span>
<span class="n">timg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">modal_system</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Transformation&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">timg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Mass</span>
<span class="n">mimg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">modal_system</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Mass&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mimg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># Damping</span>
<span class="n">dimg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">modal_system</span><span class="o">.</span><span class="n">damping</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Damping&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">dimg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="c1"># Stiffness</span>
<span class="n">simg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">modal_system</span><span class="o">.</span><span class="n">stiffness</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stiffness&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Modal DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">simg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id11">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Modal_System_Matrices.png"><img alt="Modal system matrices" src="_images/Showcase_Beam_Modal_System_Matrices.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Transformation, Mass, Damping and System matrices for the <code class="docutils literal notranslate"><span class="pre">modal_system</span></code>
object.</span><a class="headerlink" href="#id11" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can see that the mass, stiffness, and
damping matrices of <code class="docutils literal notranslate"><span class="pre">modal_system</span></code> are now the modal mass, modal stiffness,
and modal damping matrices.  SDynPy also tracks the transformation between internal
degrees of freedom and physical degrees of freedom, which in this case is the
mode shape matrix <span class="math notranslate nohighlight">\(\mathbf{\Phi}\)</span>, which transforms modal degrees of freedom <span class="math notranslate nohighlight">\(\mathbf{q}\)</span>
to physical degrees of freedom <span class="math notranslate nohighlight">\(\mathbf{x}\)</span> by the well-known modal
transformation</p>
<div class="math notranslate nohighlight">
\[\mathbf{x} = \mathbf{\Phi}\mathbf{q}\]</div>
<p>We can see that the coordinates of the original <code class="docutils literal notranslate"><span class="pre">system</span></code> and <code class="docutils literal notranslate"><span class="pre">modal_system</span></code>
are identical, meaning the same physical degrees of freedom exist in each.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [54]: np.all(system.coordinate == modal_system.coordinate)</span>
<span class="go">Out[54]: True</span>
</pre></div>
</div>
<p>Because SDynPy tracks the transformation between internal and physical degrees
of freedom and applies it when necessary, the reduced <code class="docutils literal notranslate"><span class="pre">modal_system</span></code> can be
utilized identically to the original <code class="docutils literal notranslate"><span class="pre">system</span></code> consisting of physical degrees
of freedom.  For example, we can compute the eigensolution of <code class="docutils literal notranslate"><span class="pre">modal_system</span></code>
and find that it produces the exact same modes as the original shapes.  The
transformation is automatically applied to the mode shape matrix to produce
shapes at the physical degrees of freedom.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [55]: modal_system.eigensolution()</span>
<span class="go">Out[55]:</span>
<span class="go">   Index,  Frequency,    Damping,     # DoFs</span>
<span class="go">    (0,),     0.0000,    0.0000%,        126</span>
<span class="go">    (1,),     0.0000,    0.0000%,        126</span>
<span class="go">    (2,),     0.0000,    0.0000%,        126</span>
<span class="go">    (3,),     0.0000,    0.0000%,        126</span>
<span class="go">    (4,),     0.0000,    0.0000%,        126</span>
<span class="go">    (5,),     0.0000,    0.0000%,        126</span>
<span class="go">    (6,),   648.5603,    0.5000%,        126</span>
<span class="go">    (7,),  1297.1207,    0.5000%,        126</span>
<span class="go">    (8,),  1787.8068,    0.5000%,        126</span>
<span class="go">    (9,),  3504.9762,    0.5000%,        126</span>
<span class="go">   (10,),  3575.6135,    0.5000%,        126</span>
</pre></div>
</div>
<p>The modal system is useful because it can give approximately the same results
as the physical system (at least over the bandwidth of interest) with
significantly less computational cost.  Rather than performing computations on
a coupled, 126-degree-of-freedom system, we can instead perform computations on
an uncoupled, 11-degree-of-freedom system, and then apply a simple
transformation to convert the results back to physical degrees of freedom.</p>
</section>
<section id="data-in-sdynpy">
<h2><a class="toc-backref" href="#id85">Data in SDynPy</a><a class="headerlink" href="#data-in-sdynpy" title="Permalink to this heading"></a></h2>
<p>Data in SDynPy is stored as subclasses of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a> object, which
represents all types of data in SDynPy (time histories, frequency response
functions, power spectral density arrays, etc.).  Functionality for specific
data types are stored in their respective subclasses.  For example, time history
signals are stored in
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> objects
and frequency response functions are stored in
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
objects.</p>
<p>In general, to create a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a> object, users will
utilize the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.data_array.html#sdynpy.core.sdynpy_data.data_array" title="sdynpy.core.sdynpy_data.data_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">data_array</span></code></a> function.  This
function accepts a type specifier defined by the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.FunctionTypes.html#sdynpy.core.sdynpy_data.FunctionTypes" title="sdynpy.core.sdynpy_data.FunctionTypes"><code class="xref py py-class docutils literal notranslate"><span class="pre">FunctionTypes</span></code></a> enumeration.
It will also accept the abscissa (independent variable, e.g., frequency or time),
the ordinate (dependent variable, e.g., acceleration or force), the coordinate
(degree of freedom information for the signal), as well as up to five comments.
For example, we can construct a set of sine waves with different amplitudes</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">times</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">100</span><span class="p">)</span><span class="o">/</span><span class="mi">100</span>
<span class="n">amplitudes</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="n">signal</span> <span class="o">=</span> <span class="n">amplitudes</span><span class="p">[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="o">*</span><span class="mi">5</span><span class="o">*</span><span class="n">times</span><span class="p">)</span>
<span class="n">coordinates</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span>
    <span class="n">string_array</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;101X+&#39;</span><span class="p">,</span><span class="s1">&#39;101Y-&#39;</span><span class="p">])[:,</span><span class="n">np</span><span class="o">.</span><span class="n">newaxis</span><span class="p">]</span>

<span class="n">time_history</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">data_array</span><span class="p">(</span>
    <span class="n">data_type</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">FunctionTypes</span><span class="o">.</span><span class="n">TIME_RESPONSE</span><span class="p">,</span>
    <span class="n">abscissa</span> <span class="o">=</span> <span class="n">times</span><span class="p">,</span>
    <span class="n">ordinate</span> <span class="o">=</span> <span class="n">signal</span><span class="p">,</span>
    <span class="n">coordinate</span> <span class="o">=</span> <span class="n">coordinates</span><span class="p">)</span>
</pre></div>
</div>
<p>There are numerous function types defined in SDynPy.  Referencing the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.html#module-sdynpy.core.sdynpy_data" title="sdynpy.core.sdynpy_data"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sdpy.data</span></code></a> module will show the different
subclasses available.</p>
<p>Let’s take this time to explore of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a> class before moving
on.  First, let’s examine the fields available by looking at the object’s
<code class="docutils literal notranslate"><span class="pre">dtype</span></code>.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [56]: time_history.dtype</span>
<span class="go">Out[56]: dtype([(&#39;abscissa&#39;, &#39;&lt;f8&#39;, (100,)),</span>
<span class="go">                (&#39;ordinate&#39;, &#39;&lt;f8&#39;, (100,)),</span>
<span class="go">                (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment5&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;coordinate&#39;, [(&#39;node&#39;, &#39;&lt;u8&#39;),</span>
<span class="go">                                (&#39;direction&#39;, &#39;i1&#39;)], (1,))])</span>
</pre></div>
</div>
<p>The <code class="docutils literal notranslate"><span class="pre">abscissa</span></code> field consists of the independent variable, which in the case
of this time history, is the time value at each step.  Different function types
will have different abscissa data types.  For example, a spectral quantity may
have frequency lines as its abscissa.  The <code class="docutils literal notranslate"><span class="pre">ordinate</span></code> field consists of the
dependant variable.  For a time history, this is a real quantity, but for a
frequency-domain function such as a frequency response function, this may be a
complex value.  Both <code class="docutils literal notranslate"><span class="pre">abscissa</span></code> and <code class="docutils literal notranslate"><span class="pre">ordinate</span></code> have a shape of <code class="docutils literal notranslate"><span class="pre">(100,)</span></code>, which
is the length of the time signal.  Like the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a>,
there are five fields available for comments, which store string data
up to 80 characters which can be used to store any data the user feels is
relevant to the analysis.  Finally, the <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field stores degree of
freedom data as
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects, and thus has the same data type as
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>.
Different function types will have different shaped <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> fields.
For example, a time history only has one degree of freedom associated with each
signal, so its shape is <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>.  Note, however that this makes the coordinate
field for the entire array <code class="docutils literal notranslate"><span class="pre">(2,1)</span></code>, which is why the new axis needed to be
added to the coordinates <code class="docutils literal notranslate"><span class="pre">coordinates</span></code> variable in the previous code block.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [57]: time_history.shape</span>
<span class="go">Out[57]: (2,)</span>

<span class="go">In [58]: time_history.coordinate.shape</span>
<span class="go">Out[58]: (2, 1)</span>
</pre></div>
</div>
<p>Other types of functions may have differently-shaped <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> fields.
For example, a frequency response function will generally have a response
coordinate and a reference coordinate for each entry in the matrix, so it will
have a <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field of shape <code class="docutils literal notranslate"><span class="pre">(2,)</span></code>.</p>
<p>There are many ways to visualize data in SDynPy, but the simplest is generally
to call the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.plot" title="sdynpy.core.sdynpy_data.NDDataArray.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot</span></code></a> method of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a> object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">time_history</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<p>This will produce a plot window with the signals displayed in it.  This is more
useful for smaller datasets.  The plots produced by this method can get quite
busy if many signals are plotted.</p>
<figure class="align-center" id="id12">
<a class="reference internal image-reference" href="_images/Showcase_Time_History_Demo.png"><img alt="example time history" src="_images/Showcase_Time_History_Demo.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Time history displayed using its
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.plot" title="sdynpy.core.sdynpy_data.NDDataArray.plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot</span></code></a> method.</span><a class="headerlink" href="#id12" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="integrating-equations-of-motion-to-produce-time-data">
<h2><a class="toc-backref" href="#id86">Integrating Equations of Motion to Produce Time Data</a><a class="headerlink" href="#integrating-equations-of-motion-to-produce-time-data" title="Permalink to this heading"></a></h2>
<p>While <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a> objects can
be created manually, many functions and methods in SDynPy will return various
data.  One common operation is to integrate the equations of motion of a system
to create a simulated time response to an imposed excitation or an imposed
initial condition.  The
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">time_integrate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> class can be
used to integrate the dynamic system to produce time responses.  We will
demonstrate this analysis in this section.</p>
<section id="generating-an-excitation-signal">
<h3><a class="toc-backref" href="#id87">Generating an Excitation Signal</a><a class="headerlink" href="#generating-an-excitation-signal" title="Permalink to this heading"></a></h3>
<p>When setting up the time integration, we must consider the excitation that will
be applied to the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>, as well
as the initial conditions.  For this case, we will consider the system starting
at rest.  We will excite the structure with a pair of perpendicular random
vibration signals at the beam tip.  We can easily create these signals using
SDynPy’s <a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.html#module-sdynpy.signal_processing.sdynpy_generator" title="sdynpy.signal_processing.sdynpy_generator"><code class="xref py py-mod docutils literal notranslate"><span class="pre">sdpy.generator</span></code></a>
sub-module.  This contains functions to produce common signals used in
structural dynamics such as
<a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.sine.html#sdynpy.signal_processing.sdynpy_generator.sine" title="sdynpy.signal_processing.sdynpy_generator.sine"><code class="xref py py-func docutils literal notranslate"><span class="pre">sine</span></code></a>,
<a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.chirp.html#sdynpy.signal_processing.sdynpy_generator.chirp" title="sdynpy.signal_processing.sdynpy_generator.chirp"><code class="xref py py-func docutils literal notranslate"><span class="pre">chirp</span></code></a>,
<a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.pseudorandom.html#sdynpy.signal_processing.sdynpy_generator.pseudorandom" title="sdynpy.signal_processing.sdynpy_generator.pseudorandom"><code class="xref py py-func docutils literal notranslate"><span class="pre">pseudorandom</span></code></a>,
<a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.random.html#sdynpy.signal_processing.sdynpy_generator.random" title="sdynpy.signal_processing.sdynpy_generator.random"><code class="xref py py-func docutils literal notranslate"><span class="pre">random</span></code></a>,
<a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.burst_random.html#sdynpy.signal_processing.sdynpy_generator.burst_random" title="sdynpy.signal_processing.sdynpy_generator.burst_random"><code class="xref py py-func docutils literal notranslate"><span class="pre">burst_random</span></code></a>,
and <a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.pulse.html#sdynpy.signal_processing.sdynpy_generator.pulse" title="sdynpy.signal_processing.sdynpy_generator.pulse"><code class="xref py py-func docutils literal notranslate"><span class="pre">pulse</span></code></a>.</p>
<p>We will look at the <a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_generator.random.html#sdynpy.signal_processing.sdynpy_generator.random" title="sdynpy.signal_processing.sdynpy_generator.random"><code class="xref py py-func docutils literal notranslate"><span class="pre">random</span></code></a>
function to generate the input signals for this analysis.  We will set up some
initial signal processing parameters prior to generating the signal.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Set up sampling parameters</span>
<span class="n">signal_bandwidth</span> <span class="o">=</span> <span class="mi">4000</span> <span class="c1"># Hz</span>
<span class="n">sample_rate</span> <span class="o">=</span> <span class="n">signal_bandwidth</span><span class="o">*</span><span class="mi">2</span>
<span class="n">dt</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="n">sample_rate</span>
<span class="n">samples_per_frame</span> <span class="o">=</span> <span class="mi">2000</span>
<span class="n">num_frames</span> <span class="o">=</span> <span class="mi">30</span>
<span class="n">total_samples</span> <span class="o">=</span> <span class="n">samples_per_frame</span><span class="o">*</span><span class="n">num_frames</span>
<span class="n">rms_level</span> <span class="o">=</span> <span class="mf">1.0</span>
<span class="n">num_signals</span> <span class="o">=</span> <span class="mi">2</span>

<span class="c1"># Generate the signals</span>
<span class="n">signals</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">generator</span><span class="o">.</span><span class="n">random</span><span class="p">((</span><span class="n">num_signals</span><span class="p">,),</span><span class="n">total_samples</span><span class="p">,</span><span class="n">rms_level</span><span class="p">,</span><span class="n">dt</span><span class="p">)</span>

<span class="c1"># Plot the signals</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">num_signals</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;Random Signals&#39;</span><span class="p">,</span>
                      <span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">total_samples</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">signals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Signal 1 (N)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">total_samples</span><span class="p">)</span><span class="o">*</span><span class="n">dt</span><span class="p">,</span><span class="n">signals</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">linewidth</span><span class="o">=</span><span class="mf">0.5</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Signal 2 (N)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Time (s)&#39;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id13">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Random_Excitation.png"><img alt="random signal" src="_images/Showcase_Beam_Random_Excitation.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Random signal used to excite the structure</span><a class="headerlink" href="#id13" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="performing-the-time-integration">
<h3><a class="toc-backref" href="#id88">Performing the Time Integration</a><a class="headerlink" href="#performing-the-time-integration" title="Permalink to this heading"></a></h3>
<p>We can then apply the signal to the structure using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">time_integrate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> class.
We need to chose which degrees of freedom to plot on the structure.  Recall
we can plot degrees of freedom using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_coordinate" title="sdynpy.core.sdynpy_geometry.Geometry.plot_coordinate"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_coordinate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object.
By not specifying a set of coordinates to plot, it will simply plot all
translational coordinates.  Additionally, we can pass the optional keyword
argument <code class="docutils literal notranslate"><span class="pre">label_dofs</span> <span class="pre">=</span> <span class="pre">True</span></code> to tell the plotter to label the degrees of
freedom in the plot.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.02</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id14">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Labelled_Coordinates.png"><img alt="beam with labelled coordinates" src="_images/Showcase_Beam_Labelled_Coordinates.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Beam geometry with coordinate labels plotted</span><a class="headerlink" href="#id14" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We will place the excitation forces at the tip of the beam in the two transverse
directions.  This corresponds to degrees of freedom <code class="docutils literal notranslate"><span class="pre">21Y+</span></code> and <code class="docutils literal notranslate"><span class="pre">21Z+</span></code>.
We can define a new coordinate array using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.coordinate_array.html#sdynpy.core.sdynpy_coordinate.coordinate_array" title="sdynpy.core.sdynpy_coordinate.coordinate_array"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.coordinate_array</span></code></a>
function.  This function can define new
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
objects in multiple ways.  In this case, we will provide it the <code class="docutils literal notranslate"><span class="pre">string_array</span></code>
keyword argument, and pass the coordinates that we desire in as strings.
Alternatively, they could also be passed in as separate nodes and directions,
which is useful for longer coordinate arrays.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">excitation_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span>
    <span class="n">string_array</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;21Y+&#39;</span><span class="p">,</span><span class="s1">&#39;21Z+&#39;</span><span class="p">])</span>

<span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">excitation_dofs</span><span class="p">,</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.05</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id15">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Excitation_DoFs.png"><img alt="excitation degrees of freedom" src="_images/Showcase_Beam_Excitation_DoFs.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Excitation degrees of freedom plotted on the beam geometry</span><a class="headerlink" href="#id15" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We might also specify the degrees of freedom at which we would like responses.
One could argue that it is quite difficult to measure rotations of a structure,
so we could construct our simulation such that it only returns the translational
degrees of freedom.  We can easily get a list of all translational degrees of
freedom using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.from_nodelist.html#sdynpy.core.sdynpy_coordinate.from_nodelist" title="sdynpy.core.sdynpy_coordinate.from_nodelist"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.coordinate.from_nodelist</span></code></a>
function, which accepts a list of nodes and returns translational degrees of
freedom (by default, though can be modified) at each node in the list.  We can
generate this list of node identification numbers from our <code class="docutils literal notranslate"><span class="pre">geometry</span></code> object.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">response_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate</span><span class="o">.</span><span class="n">from_nodelist</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">node</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
<span class="n">geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">response_dofs</span><span class="p">,</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">arrow_scale</span><span class="o">=</span><span class="mf">0.025</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id16">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Response_DoFs.png"><img alt="response degrees of freedom" src="_images/Showcase_Beam_Response_DoFs.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Response degrees of freedom plotted on the beam geometry</span><a class="headerlink" href="#id16" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can then integrate equations of motion for the system using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">time_integrate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">responses</span><span class="p">,</span><span class="n">forces</span> <span class="o">=</span> <span class="n">modal_system</span><span class="o">.</span><span class="n">time_integrate</span><span class="p">(</span>
    <span class="n">signals</span><span class="p">,</span> <span class="n">dt</span><span class="p">,</span> <span class="n">responses</span> <span class="o">=</span> <span class="n">response_dofs</span><span class="p">,</span> <span class="n">references</span><span class="o">=</span><span class="n">excitation_dofs</span><span class="p">,</span>
    <span class="n">displacement_derivative</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="n">integration_oversample</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span>
</pre></div>
</div>
<p>In addition to variables previously defined, we have also defined keyword
arguments <code class="docutils literal notranslate"><span class="pre">displacement_derivative</span> <span class="pre">=</span> <span class="pre">2</span></code> and <code class="docutils literal notranslate"><span class="pre">integration_oversample</span> <span class="pre">=</span> <span class="pre">10</span></code>.
The <code class="docutils literal notranslate"><span class="pre">displacement_derivative</span></code> keyword specifies what data type to return.
Specifying a two for this value will return an acceleration quantity, which is
the second derivative of displacement.  Specifying zero or one for this value
will result in displacement or velocity being returned, respectively.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">integration_oversample</span></code> keyword determines the degree of oversampling
that occurs in the integration.  The defined forces used a sample rate of
8000 Hz, so an oversample value of 10 will result in an integration time step
of 80000 steps per second of integration time.  One must be wary of using this
keyword argument, as it relies on zero-padding the Fourier Transform of the
signal, which is not an appropriate approach to oversample certain functions.
For example, if the excitation is a ramp, this zero-padding will produce
strange end effects.  If such a signal is used as the excitation, it is
recommended to simply generate the signal such that it is already oversampled,
and not use the <code class="docutils literal notranslate"><span class="pre">integration_oversample</span></code> argument of this function.
Note also that the
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.signal.lsim.html">scipy.signal.lsim</a>
function is used to perform the integration, so a factor of 10x is generally
sufficient for integration accuracy due to the linear system assumption.</p>
<p>Let’s investigate the output of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.time_integrate" title="sdynpy.core.sdynpy_system.System.time_integrate"><code class="xref py py-func docutils literal notranslate"><span class="pre">time_integrate</span></code></a>
method.  Two outputs were produced, <code class="docutils literal notranslate"><span class="pre">responses</span></code> and <code class="docutils literal notranslate"><span class="pre">forces</span></code>.  These are the
responses to the input signal, as well as the input signal itself, both
transformed into SDynPy
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> objects.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [59]: responses</span>
<span class="go">Out[59]: TimeHistoryArray with shape 63 and 60000 elements per function</span>

<span class="go">In [60]: forces</span>
<span class="go">Out[60]: TimeHistoryArray with shape 2 and 60000 elements per function</span>
</pre></div>
</div>
<p>Here we see that there are 63 response signals, and 2 force signals.
Here is an example where using the basic
<code class="xref py py-func docutils literal notranslate"><span class="pre">plot</span></code> method of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> object
may be unsatisfactory, as too many lines will be plotted on the figure.  Instead
we will use the interactive 2D plotter
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a>, which will allow us to
interactively chose which signals to show.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [61]: sdpy.GUIPlot(responses)</span>
<span class="go">Out[61]: &lt;sdynpy.core.sdynpy_data.GUIPlot at 0xXXXXXXXXXXX&gt;</span>
</pre></div>
</div>
<figure class="align-center" id="id17">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Response_GUIPlot.png"><img alt="interactive plot of response" src="_images/Showcase_Beam_Response_GUIPlot.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> allows users to select
which functions to plot.</span><a class="headerlink" href="#id17" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Another approach to visualizing the response of the system is to plot it.
Plotting displacements is perhaps more meaningful than plotting accelerations,
which we have computed here.  Nonetheless, it is valuable to show how this
can be done in SDynPy.  The
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_transient" title="sdynpy.core.sdynpy_geometry.Geometry.plot_transient"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_transient</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> object
can be used to show the time responses as displacements on the geometry.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [62]: geometry.plot_transient(responses,displacement_scale=0.003)</span>
<span class="go">Out[62]: &lt;sdynpy.core.sdynpy_geometry.TransientPlotter at 0xXXXXXXXXXXX&gt;</span>
</pre></div>
</div>
<figure class="align-center" id="id18">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Plot_Transient.png"><img alt="transient plotter" src="_images/Showcase_Beam_Plot_Transient.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.TransientPlotter.html#sdynpy.core.sdynpy_geometry.TransientPlotter" title="sdynpy.core.sdynpy_geometry.TransientPlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransientPlotter</span></code></a>
showing the acceleration shape at each time step in the analysis</span><a class="headerlink" href="#id18" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The transient plotter is similar to the mode shape plotter shown previously,
except instead of animating a single shape vibrating back and forth, it animates
a series of shapes one after another.  The user can adjust the current timestep
using the <code class="docutils literal notranslate"><span class="pre">|&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">&gt;</span></code>, or <code class="docutils literal notranslate"><span class="pre">&gt;|</span></code> buttons, or by sliding the cursor
across the time history representation at the bottom of the window.
The animation can be started by clicking one of the <code class="docutils literal notranslate"><span class="pre">&lt;</span> <span class="pre">Play</span></code> or <code class="docutils literal notranslate"><span class="pre">Play</span> <span class="pre">&gt;</span></code>
buttons, which will plan the animation in reverse or forward, respectively.  The
animation can be stopped by clicking the <code class="docutils literal notranslate"><span class="pre">Stop</span></code> button.  The <code class="docutils literal notranslate"><span class="pre">Shape</span></code> menu
has options for scaling the displacement level and animation speed, as well as
setting the animation to loop.</p>
</section>
</section>
<section id="computing-frequency-response-functions">
<h2><a class="toc-backref" href="#id89">Computing Frequency Response Functions</a><a class="headerlink" href="#computing-frequency-response-functions" title="Permalink to this heading"></a></h2>
<p>SDynPy offers several approaches to compute frequency response functions.
These can be computed directly from a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object using its
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.frequency_response" title="sdynpy.core.sdynpy_system.System.frequency_response"><code class="xref py py-func docutils literal notranslate"><span class="pre">frequency_response</span></code></a> method,
in which the dynamic stiffness matrix will be inverted and transformations
applied.  Frequency response functions can also be computed from
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray" title="sdynpy.core.sdynpy_shape.ShapeArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">ShapeArray</span></code></a> objects using its
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.compute_frf" title="sdynpy.core.sdynpy_shape.ShapeArray.compute_frf"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_frf</span></code></a> method.
Finally, frequency response functions can be computed from
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> using
the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data" title="sdynpy.core.sdynpy_data.TransferFunctionArray.from_time_data"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray.from_time_data</span></code></a>
function, or alternatively the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>.</p>
<section id="code-based-frequency-response-function-computations">
<h3><a class="toc-backref" href="#id90">Code-based Frequency Response Function Computations</a><a class="headerlink" href="#code-based-frequency-response-function-computations" title="Permalink to this heading"></a></h3>
<p>Let’s set up some initial parameters to use to compute frequency response
functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">df</span> <span class="o">=</span> <span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">dt</span><span class="o">*</span><span class="n">samples_per_frame</span><span class="p">)</span>
<span class="n">frequency_lines</span> <span class="o">=</span> <span class="n">df</span><span class="o">*</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">samples_per_frame</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can compute the frequency response functions with the approaches
described above.  First we will consider the code-based approaches.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># From the original undamped system</span>
<span class="n">frfs_system</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">frequency_response</span><span class="p">(</span><span class="n">frequency_lines</span><span class="p">,</span>
                                        <span class="n">response_dofs</span><span class="p">,</span>
                                        <span class="n">excitation_dofs</span><span class="p">,</span>
                                        <span class="n">displacement_derivative</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># From the reduced system with damping added</span>
<span class="n">frfs_modal_system</span> <span class="o">=</span> <span class="n">modal_system</span><span class="o">.</span><span class="n">frequency_response</span><span class="p">(</span>
    <span class="n">frequency_lines</span><span class="p">,</span>
    <span class="n">response_dofs</span><span class="p">,</span>
    <span class="n">excitation_dofs</span><span class="p">,</span>
    <span class="n">displacement_derivative</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># From the eigensolution</span>
<span class="n">frfs_shapes</span> <span class="o">=</span> <span class="n">shapes</span><span class="o">.</span><span class="n">compute_frf</span><span class="p">(</span><span class="n">frequency_lines</span><span class="p">,</span>
                                 <span class="n">response_dofs</span><span class="p">,</span>
                                 <span class="n">excitation_dofs</span><span class="p">,</span>
                                 <span class="n">displacement_derivative</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="c1"># From time data</span>
<span class="n">frfs_time</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">TransferFunctionArray</span><span class="o">.</span><span class="n">from_time_data</span><span class="p">(</span>
    <span class="n">forces</span><span class="p">,</span> <span class="n">responses</span><span class="p">,</span> <span class="n">samples_per_frame</span><span class="p">,</span>
    <span class="n">overlap</span> <span class="o">=</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">window</span> <span class="o">=</span> <span class="s1">&#39;hann&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>Before we go too much further, let’s explore the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray</span></code></a>
object returned by these analyses.  First, by typing the variable name into
the console, we can see the shape of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray</span></code></a>
as well as how many elements (frequency lines) are in each function.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [63]: frfs_system</span>
<span class="go">Out[63]: TransferFunctionArray with shape 63 x 2 and 1000 elements per function</span>
</pre></div>
</div>
<p>We can also examine the <code class="docutils literal notranslate"><span class="pre">dtype</span></code> of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray</span></code></a>,
in particular comparing it to that of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a></p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [64]: responses.dtype</span>
<span class="go">Out[64]: dtype([(&#39;abscissa&#39;, &#39;&lt;f8&#39;, (60000,)),</span>
<span class="go">                (&#39;ordinate&#39;, &#39;&lt;f8&#39;, (60000,)),</span>
<span class="go">                (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment5&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;coordinate&#39;, [(&#39;node&#39;, &#39;&lt;u8&#39;),</span>
<span class="go">                                (&#39;direction&#39;, &#39;i1&#39;)], (1,))])</span>

<span class="go">In [65]: frfs_system.dtype</span>
<span class="go">Out[65]: dtype([(&#39;abscissa&#39;, &#39;&lt;f8&#39;, (1000,)),</span>
<span class="go">                (&#39;ordinate&#39;, &#39;&lt;c16&#39;, (1000,)),</span>
<span class="go">                (&#39;comment1&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment2&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment3&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment4&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;comment5&#39;, &#39;&lt;U80&#39;),</span>
<span class="go">                (&#39;coordinate&#39;, [(&#39;node&#39;, &#39;&lt;u8&#39;),</span>
<span class="go">                                (&#39;direction&#39;, &#39;i1&#39;)], (2,))])</span>
</pre></div>
</div>
<p>Because both the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray</span></code></a>
<code class="docutils literal notranslate"><span class="pre">frfs_system</span></code> and the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> <code class="docutils literal notranslate"><span class="pre">responses</span></code>
are subclasses of the base <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray" title="sdynpy.core.sdynpy_data.NDDataArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">NDDataArray</span></code></a>
class, which represents all data in SDynPy, they will have the same fields.
However, the shapes and data types of the fields are different.  We see that the
<code class="docutils literal notranslate"><span class="pre">ordinate</span></code> field of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TimeHistoryArray.html#sdynpy.core.sdynpy_data.TimeHistoryArray" title="sdynpy.core.sdynpy_data.TimeHistoryArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TimeHistoryArray</span></code></a> object
is a floating point number <code class="docutils literal notranslate"><span class="pre">f8</span></code>, whereas the <code class="docutils literal notranslate"><span class="pre">ordinate</span></code> field of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray</span></code></a>
object is a complex number <code class="docutils literal notranslate"><span class="pre">c16</span></code>, because in general, frequency response
functions are complex.  Additionally, we see that the the <code class="docutils literal notranslate"><span class="pre">coordinate</span></code> field
now no longer has shape <code class="docutils literal notranslate"><span class="pre">(1,)</span></code>, but now has shape <code class="docutils literal notranslate"><span class="pre">(2,)</span></code>.  This is because
there are two degrees of freedom associated with each entry in the frequency
response function matrix, a response coordinate and a reference coordinate.</p>
<p>In each of the frequency response functions we have computed, there are
63 responses and 2 forces, meaning a total of 126 frequency response
functions have been generated.  Rather than comparing all of these functions,
we will just compare the drive point frequency response functions.  This can
be easily selected by identifying the functions where the response coordinate
is equal to the reference coordinate (allowing for a difference in sign to occur
between the two).</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">drive_frfs_system</span> <span class="o">=</span> <span class="n">frfs_system</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_system</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">)</span>
        <span class="o">==</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_system</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))]</span>

<span class="n">drive_frfs_modal_system</span> <span class="o">=</span> <span class="n">frfs_modal_system</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_modal_system</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">)</span>
        <span class="o">==</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_modal_system</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))]</span>

<span class="n">drive_frfs_shapes</span> <span class="o">=</span> <span class="n">frfs_shapes</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_shapes</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">)</span>
        <span class="o">==</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_shapes</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))]</span>

<span class="n">drive_frfs_time</span> <span class="o">=</span> <span class="n">frfs_time</span><span class="p">[</span>
    <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_time</span><span class="o">.</span><span class="n">response_coordinate</span><span class="p">)</span>
        <span class="o">==</span>
        <span class="nb">abs</span><span class="p">(</span><span class="n">frfs_time</span><span class="o">.</span><span class="n">reference_coordinate</span><span class="p">))]</span>
</pre></div>
</div>
<p>We can then plot the drive point frequency response functions on the same plots
to compare them.</p>
<figure class="align-center" id="id19">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Drive_FRFs.png"><img alt="drive point frequency response" src="_images/Showcase_Beam_Drive_FRFs.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Frequency response functions computed from different approaches.</span><a class="headerlink" href="#id19" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>It may aid understanding to zoom in on a specific peak of the frequency response
function to understand the subtle differences between the approaches.</p>
<figure class="align-center" id="id20">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Drive_FRFs_Closeup.png"><img alt="drive point frequency response closeup" src="_images/Showcase_Beam_Drive_FRFs_Closeup.png" style="width: 400px;" /></a>
<figcaption>
<p><span class="caption-text">Zoom of frequency response functions computed from different approaches.</span><a class="headerlink" href="#id20" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The most obvious difference between the four plots is in the <code class="docutils literal notranslate"><span class="pre">System</span></code> plot.
This original system, derived from a finite element model, had no damping
associated with it.  Therefore the peak is very sharp (indeed, infinitely sharp
if we had plotted with infinite frequency resolution) compared to the other
three where we had added 0.5% modal damping.  The <code class="docutils literal notranslate"><span class="pre">Modal</span> <span class="pre">System</span></code> and <code class="docutils literal notranslate"><span class="pre">Shape</span></code>
derived frequency response functions are nominally identical due to them being
constructed from nominally identical data.  Finally, the <code class="docutils literal notranslate"><span class="pre">Time</span></code> curve is slightly
more blunt than the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> or <code class="docutils literal notranslate"><span class="pre">Modal</span> <span class="pre">System</span></code> curves due to the artificial
damping added to the system from the Hann window applied during the frequency
response function computation.</p>
<p>If users would like to compare all frequency response functions rather than just
the drive points, the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> is
again helpful.  Two data sets can be passed simultaneously into the class
to allow for comparisons of large datasets to be performed interactively.
SDynPy by default plots frequency response functions as log magnitude and phase.
However, the complex plotting and logarithmic scaling of the axes can be modified
in the <code class="docutils literal notranslate"><span class="pre">Plot</span></code> menu.</p>
<figure class="align-center" id="id21">
<a class="reference internal image-reference" href="_images/Showcase_Beam_GUIPlot_FRFs.png"><img alt="frequency response functions in GUIPlot" src="_images/Showcase_Beam_GUIPlot_FRFs.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Frequency response functions compared in
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a>.</span><a class="headerlink" href="#id21" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="mode-indicator-functions">
<h3><a class="toc-backref" href="#id91">Mode Indicator Functions</a><a class="headerlink" href="#mode-indicator-functions" title="Permalink to this heading"></a></h3>
<p>Another way to perform data reduction from a large number of frequency response
functions to an overall view of the system is to compute mode indicator functions.
Most popular are the Complex Mode Indicator Function (CMIF), the Normal Mode Indicator
Function (NMIF), and the Multi-Mode Indicator Function (MMIF).  One may also hear
of the QMIF, which is a variant of the CMIF that is computed using only the
imaginary part of the frequency response function (or real part when considering
velocity/force frequency response functions).</p>
<p>SDynPy can compute the mode indicator functions using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_cmif" title="sdynpy.core.sdynpy_data.TransferFunctionArray.compute_cmif"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_cmif</span></code></a>,
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_nmif" title="sdynpy.core.sdynpy_data.TransferFunctionArray.compute_nmif"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_nmif</span></code></a>,
and
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.compute_mmif" title="sdynpy.core.sdynpy_data.TransferFunctionArray.compute_mmif"><code class="xref py py-func docutils literal notranslate"><span class="pre">compute_mmif</span></code></a>
methods of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">sdpy.TransferFunctionArray</span></code></a>
object.  See their respective documentation for additional arguments that
can be passed to these functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># CMIF</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">frfs_shapes</span><span class="o">.</span><span class="n">compute_cmif</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;CMIF&#39;</span><span class="p">)</span>
<span class="c1"># NMIF</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">frfs_shapes</span><span class="o">.</span><span class="n">compute_nmif</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;NMIF&#39;</span><span class="p">)</span>
<span class="c1"># MMIF</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">frfs_shapes</span><span class="o">.</span><span class="n">compute_mmif</span><span class="p">()</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Frequency (Hz)&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;MMIF&#39;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id22">
<a class="reference internal image-reference" href="_images/Showcase_Beam_CMIF.png"><img alt="complex mode indicator function" src="_images/Showcase_Beam_CMIF.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Complex mode indicator function for the beam frequency response functions</span><a class="headerlink" href="#id22" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id23">
<a class="reference internal image-reference" href="_images/Showcase_Beam_NMIF.png"><img alt="normal mode indicator function" src="_images/Showcase_Beam_NMIF.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Normal mode indicator function for the beam frequency response functions</span><a class="headerlink" href="#id23" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id24">
<a class="reference internal image-reference" href="_images/Showcase_Beam_MMIF.png"><img alt="multi-mode indicator function" src="_images/Showcase_Beam_MMIF.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Multi-mode indicator function for the beam frequency response functions</span><a class="headerlink" href="#id24" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="graphical-frequency-response-function-computation">
<h3><a class="toc-backref" href="#id92">Graphical Frequency Response Function Computation</a><a class="headerlink" href="#graphical-frequency-response-function-computation" title="Permalink to this heading"></a></h3>
<p>While code-based frequency response function computations are nice in that they
can be automated very easily, some users may prefer a more graphical approach.
The <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
provides a way to do this.  We pass it all of our time histories (references and
responses) and then a window appears which provides various signal processing
parameters that can be selected.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Concatenate all time signals into one array</span>
<span class="n">all_time_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">forces</span><span class="p">,</span><span class="n">responses</span><span class="p">))</span>
<span class="c1"># Pass the entire set of time histories into the SignalProcessingGUI</span>
<span class="n">spgui</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">SignalProcessingGUI</span><span class="p">(</span><span class="n">all_time_data</span><span class="p">)</span>
<span class="c1"># Assign the geometry to the GUI so we don&#39;t have to load it from disk</span>
<span class="n">spgui</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span>
</pre></div>
</div>
<figure class="align-center" id="id25">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI.png"><img alt="initial SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
that initially appears for our test case.</span><a class="headerlink" href="#id25" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Let’s first explore the SignalProcessingGUI Window.  On the top left is a set of <code class="docutils literal notranslate"><span class="pre">Information</span></code>
about the signals that are loaded.  We see there are 65 signals total, of
which 0 are references and 65 are responses (we will fix this shortly).  There
are 60000 samples for a duration of 7.5 seconds, and the sample rate is 8000 Hz.</p>
<p>Below the information we have the <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Range</span></code>.  This allows us to select a range
over which the computation will be performed.  This is useful for targetting
portions of an environment, or for discarding portions of data that are not yet
at steady state.</p>
<p>Below that are the <code class="docutils literal notranslate"><span class="pre">Averaging</span> <span class="pre">and</span> <span class="pre">Triggering</span></code> settings.  This allows users to
specify when the frames occur in the signal, either by setting them up every
so many samples, or detecting some kind of trigger signal to use to locate the
measurement frames.</p>
<p>Below that are the <code class="docutils literal notranslate"><span class="pre">Sampling</span></code> options, where the frame length is specified.</p>
<p>Finally, the last options are for <code class="docutils literal notranslate"><span class="pre">Windowing</span></code>.  Certain windows may have extra
parameters that will appear in this box, for example, the decay of an exponential
window.</p>
<p>In the center of the window, we see two plots that are currently empty except
for some green boxes.  These green boxes represent the measurement frames in
the signal.  Currently no signals are plotted, because we have not selected any
signals from the lists on the right side of the window.  There are currently no
signals listed in the <code class="docutils literal notranslate"><span class="pre">References</span></code> list; all are currently in the <code class="docutils literal notranslate"><span class="pre">Responses</span></code>
list.  Signals can be moved from reference to response and vice versa by
double-clicking the signal name in the list on the right side.  Note also that
when a signal is selected, it will be shown in the respective plot.</p>
<p>Finally, on the bottom right corner of the window, we have signal processing
computations that can be performed.  The check boxes denote which functions
to compute when the <code class="docutils literal notranslate"><span class="pre">Compute</span></code> button is pressed.  Once a function is computed,
it can be plotted or saved to a file.</p>
<p>There are also menus at the top of the window that contain additional functionality.
The <code class="docutils literal notranslate"><span class="pre">File</span></code> menu allows data to be loaded directly from the disk.  The
<code class="docutils literal notranslate"><span class="pre">Visualize</span></code> menu allows the data to be sent to the transient or deflection shape
plotters once a geometry is loaded (or assigned via code as we have done).
The <code class="docutils literal notranslate"><span class="pre">Analyze</span></code> menu allows data to be sent to curve fitting software,
though these are currently disabled until frequency response functions have been
computed.</p>
<p>To start with, we will send our forces, which are the first two signals in the
responses list
to the references list by double-clicking them.  We should now see those signal
as a reference in the top list and plotted in the top plot.
Let’s also select the drive point responses in
the bottom list (only single click, not double click) so they are plotted in the
bottom plot.</p>
<figure class="align-center" id="id26">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_References_Selected.png"><img alt="references selected in SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI_References_Selected.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
with reference signals moved to the References window by double-clicking them.</span><a class="headerlink" href="#id26" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>After this step, we should see that the <code class="docutils literal notranslate"><span class="pre">References</span></code> box in the <code class="docutils literal notranslate"><span class="pre">Information</span></code>
section shows <code class="docutils literal notranslate"><span class="pre">2</span></code> and the <code class="docutils literal notranslate"><span class="pre">Responses</span></code> box shows <code class="docutils literal notranslate"><span class="pre">63</span></code>.</p>
<p>The next thing we will check is our sampling.  We set up our signals to
provide 2 Hz frequency spacing, so we can set that in the <code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Spacing</span></code>
box in the <code class="docutils literal notranslate"><span class="pre">Sampling</span></code> section of the window.  Note that this will automatically
adjust all other properties that are determined by the frequency spacing.  For
example, the <code class="docutils literal notranslate"><span class="pre">Frame</span> <span class="pre">Time</span></code> has adjusted automatically to 0.5 seconds.  You will
also see that the displayed frames on the plots have changed lengths, being now
half the size they were before.</p>
<figure class="align-center" id="id27">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_Sampling_Set.png"><img alt="sampling set in SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI_Sampling_Set.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
with sampling set to 2 Hz frequency spacing.</span><a class="headerlink" href="#id27" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Note that since we have started from zero velocity and displacement, there may
be some start-up transients in the signal.  If we zoom in the the start of the
<code class="docutils literal notranslate"><span class="pre">Responses</span></code> plot, we can see that it takes approximately 0.01 seconds to get
to a steady-state level.  We can therefore set the <code class="docutils literal notranslate"><span class="pre">Start</span> <span class="pre">Time</span></code> in the
<code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Range</span></code> section of the window to <code class="docutils literal notranslate"><span class="pre">0.02</span></code> seconds, just to be sure we’re
at steady state.  We could also perform this operation by dragging the left side
of the blue region in the plot to the position that we desire.  After performing
this operation, we should see that all the green boxes have slide to the right,
starting at the position specified by the <code class="docutils literal notranslate"><span class="pre">Start</span> <span class="pre">Time</span></code>.  We also see that we
have lost a measurement frame that no longer fits at the end of the signal;
can be seen in the <code class="docutils literal notranslate"><span class="pre">Frames</span></code> box in the <code class="docutils literal notranslate"><span class="pre">Averaging</span> <span class="pre">and</span> <span class="pre">Triggering</span></code> section,
which has changed from <code class="docutils literal notranslate"><span class="pre">15</span></code> to <code class="docutils literal notranslate"><span class="pre">14</span></code>.</p>
<figure class="align-center" id="id28">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_Start_Time.png"><img alt="setting start time in SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI_Start_Time.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
with the start time set correctly.</span><a class="headerlink" href="#id28" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We will then adjust the overlap between measurement frames.  We will set the
<code class="docutils literal notranslate"><span class="pre">Overlap</span></code> box in the <code class="docutils literal notranslate"><span class="pre">Averaging</span> <span class="pre">and</span> <span class="pre">Triggering</span></code> section of the window to
<code class="docutils literal notranslate"><span class="pre">50.00%</span></code>.  We can see that the green boxes are now overlapping.  This overlap
can be easier to see if you hover the mouse over one of the boxes, which will
cause it to highlight.</p>
<figure class="align-center" id="id29">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_Overlap.png"><img alt="setting overlap in SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI_Overlap.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
with the overlap set to 50% and a single measurement frame highlighted.</span><a class="headerlink" href="#id29" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The last setting we will set is the <code class="docutils literal notranslate"><span class="pre">Window</span></code> in the <code class="docutils literal notranslate"><span class="pre">Windowing</span></code> section
of the window.  We will specify a <code class="docutils literal notranslate"><span class="pre">Hann</span></code> window (known as a Hanning window in
some vibration literature).</p>
<figure class="align-center" id="id30">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_Window.png"><img alt="setting window in SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI_Window.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
with the window set to Hann.</span><a class="headerlink" href="#id30" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Finally we can compute the frequency response functinos.  We ensure that the
check box next to <code class="docutils literal notranslate"><span class="pre">FRF</span></code> is selected in the <code class="docutils literal notranslate"><span class="pre">Compute</span></code> section of the window.
Additionally, we will compute the coherence by checking the <code class="docutils literal notranslate"><span class="pre">Coherence</span></code>
checkbox.  We can then press the <code class="docutils literal notranslate"><span class="pre">Compute</span></code> button.  When the computations are
finished, the buttons under the computed functions will be enabled, and we can
plot them.</p>
<figure class="align-center" id="id31">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_Computed.png"><img alt="SignalProcessingGUI with functions computed" src="_images/Showcase_Beam_Initial_SPGUI_Computed.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
with the functions computed.</span><a class="headerlink" href="#id31" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Clicking the <code class="docutils literal notranslate"><span class="pre">Plot</span> <span class="pre">FRF</span></code> or <code class="docutils literal notranslate"><span class="pre">Plot</span> <span class="pre">Coherence</span></code> buttons will cause those
plots to appear in a <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> window.</p>
<figure class="align-center" id="id32">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Initial_SPGUI_Functions.png"><img alt="computed functions SignalProcessingGUI" src="_images/Showcase_Beam_Initial_SPGUI_Functions.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Drive point frequency response function and multiple coherence computed by
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a></span><a class="headerlink" href="#id32" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Data can be saved from the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
window by clicking the <code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">FRF...</span></code> button, and can be re-loaded into SDynPy
using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.NDDataArray.html#sdynpy.core.sdynpy_data.NDDataArray.load" title="sdynpy.core.sdynpy_data.NDDataArray.load"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.data.load</span></code></a> function.
In this case, we have saved the file into the current working directory as
<code class="docutils literal notranslate"><span class="pre">frfs_signalprocessinggui.npz</span></code> so we can load it using</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">frfs_spgui</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;frfs_signalprocessinggui.npz&#39;</span><span class="p">)</span>
</pre></div>
</div>
</section>
<section id="plotting-deflection-shapes">
<h3><a class="toc-backref" href="#id93">Plotting Deflection Shapes</a><a class="headerlink" href="#plotting-deflection-shapes" title="Permalink to this heading"></a></h3>
<p>While we could pass these shapes into the modal fitters in SDynPy, the lower-effort
solution could be to simply examine the deflection shapes to pick out approximate
frequencies and deflection shapes of the structure.  We can easily plot
deflection shapes using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.plot_deflection_shape" title="sdynpy.core.sdynpy_geometry.Geometry.plot_deflection_shape"><code class="xref py py-func docutils literal notranslate"><span class="pre">plot_deflection_shape</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry" title="sdynpy.core.sdynpy_geometry.Geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code></a> class.
This method accepts a set of spectral data, such as frequency response functions.
However, because the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.DeflectionShapePlotter.html#sdynpy.core.sdynpy_geometry.DeflectionShapePlotter" title="sdynpy.core.sdynpy_geometry.DeflectionShapePlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeflectionShapePlotter</span></code></a>
will attempt to map responses onto the geometry, we will not be able to plot
multiple references simultaneously, as this will result in frequency response
functions with identical response coordinates.  Because our frequency
response function arrays are already shaped as <code class="docutils literal notranslate"><span class="pre">(num_response,num_reference)</span></code>,
we can simply index into the last dimension of the array to select single-reference
frequency response functions.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [66]: geometry.plot_deflection_shape(frfs_spgui[:,0])</span>
<span class="go">Out[66]: &lt;sdynpy.core.sdynpy_geometry.DeflectionShapePlotter at 0xXXXXXXXXXXX&gt;</span>

<span class="go">In [67]: geometry.plot_deflection_shape(frfs_spgui[:,1])</span>
<span class="go">Out[67]: &lt;sdynpy.core.sdynpy_geometry.DeflectionShapePlotter at 0xXXXXXXXXXXX&gt;</span>
</pre></div>
</div>
<figure class="align-center" id="id33">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Deflection_Shape_Plotter_1.png"><img alt="deflection shapes from reference 1" src="_images/Showcase_Beam_Deflection_Shape_Plotter_1.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.DeflectionShapePlotter.html#sdynpy.core.sdynpy_geometry.DeflectionShapePlotter" title="sdynpy.core.sdynpy_geometry.DeflectionShapePlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeflectionShapePlotter</span></code></a>
interactive deflection shape viewer from reference 1</span><a class="headerlink" href="#id33" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id34">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Deflection_Shape_Plotter_2.png"><img alt="deflection shapes from reference 2" src="_images/Showcase_Beam_Deflection_Shape_Plotter_2.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.DeflectionShapePlotter.html#sdynpy.core.sdynpy_geometry.DeflectionShapePlotter" title="sdynpy.core.sdynpy_geometry.DeflectionShapePlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeflectionShapePlotter</span></code></a>
interactive deflection shape viewer from reference 2</span><a class="headerlink" href="#id34" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>These windows are similar to those of the transient plotter in that the cursor
at the bottom of the window can be used to select the frequency at which the
deflection shape is animated.  The <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> buttons step left or right
by a single frequency line.  The <code class="docutils literal notranslate"><span class="pre">Play</span></code> and <code class="docutils literal notranslate"><span class="pre">Stop</span></code> buttons start and stop
the animation, respectively.  Complex display, shape scaling, and animation
speed can be adjusted in the <code class="docutils literal notranslate"><span class="pre">Shape</span></code> menu.</p>
<p>Note that you can directly send your frequency response functions to the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.DeflectionShapePlotter.html#sdynpy.core.sdynpy_geometry.DeflectionShapePlotter" title="sdynpy.core.sdynpy_geometry.DeflectionShapePlotter"><code class="xref py py-class docutils literal notranslate"><span class="pre">DeflectionShapePlotter</span></code></a>
through the <code class="docutils literal notranslate"><span class="pre">Visualize</span></code> menu of the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a></p>
</section>
</section>
<section id="fitting-modes-to-frequency-response-functions">
<h2><a class="toc-backref" href="#id94">Fitting Modes to Frequency Response Functions</a><a class="headerlink" href="#fitting-modes-to-frequency-response-functions" title="Permalink to this heading"></a></h2>
<p>Particularly when performing experimental modal analysis, we will generally
wish to fit modes to the frequency response functions.  Let’s look at some of
the tools available to fit modes to frequency response functions in SDynPy.</p>
<section id="polypy">
<h3><a class="toc-backref" href="#id95">PolyPy</a><a class="headerlink" href="#polypy" title="Permalink to this heading"></a></h3>
<p>PolyPy is a polynomial-based curve fitter, and analysis typically occurs in two
parts.  In the first part, users specify frequency bands of interest as well as
the different polynomial orders to solve.  PolyPy will then solve the polynomial
at those orders and produce a stability diagram, which can help identify real
modes from computation modes.  In the second part, users will pick modes from
the stability diagram to use in the final mode set.  PolyPy will reconstruct
frequency response functions from that set of modes, which can be compared against
the original frequency response functions to judge adequacy of fit.</p>
<p>PolyPy is an implementation of PolyMax
<span id="id2">[<a class="reference internal" href="bibliography.html#id2" title="Bart Peeters, Herman Van der Auweraer, Patrick Guillaume, and Jan Leuridan. The polymax frequency-domain method: a new standard for modal parameter estimation? Shock and Vibration, 11:523692, January 2004. URL: https://doi.org/10.1155/2004/523692.">4</a>]</span>.
It is the most mature curve fitter in SDynPy.  It can be run either via code or
via graphical user interface.  We will focus on the graphical user interface
version of the code here, which is accessed via the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a> class.  The class
initializer accepts the frequency response functions as an input.  Again we can
assign geometry to the fitter for shape plotting so we don’t have to load it
from disk.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">polypy</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">PolyPy_GUI</span><span class="p">(</span><span class="n">frfs_spgui</span><span class="p">)</span>
<span class="n">polypy</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
</pre></div>
</div>
<p>Alternatively, <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>
can be run from the <code class="docutils literal notranslate"><span class="pre">Analyze</span></code> menu of the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
window to stay in graphical user interfaces.  Any geometry loaded into
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI.html#sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI" title="sdynpy.modal.sdynpy_signal_processing_gui.SignalProcessingGUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SignalProcessingGUI</span></code></a>
will automatically be sent to the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>.</p>
<p>The initial <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a> window
is shown below.</p>
<figure class="align-center" id="id35">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Initial.png"><img alt="polypy initial window" src="_images/Showcase_Beam_PolyPy_Initial.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Initial window of the <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a></span><a class="headerlink" href="#id35" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can see that the window is separated into two tabs, corresponding to the two
main parts of the PolyPy workflow.  The first tab is <code class="docutils literal notranslate"><span class="pre">Stabilization</span> <span class="pre">Setup</span></code>,
which allows the user to select the parameters of the stability calculation.
The second tab is <code class="docutils literal notranslate"><span class="pre">Select</span> <span class="pre">Poles</span></code> where the final mode set is selected.</p>
<p>Starting with the <code class="docutils literal notranslate"><span class="pre">Stabilization</span> <span class="pre">Setup</span></code> tab, we see that there is a main plot
in the <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Diagram</span></code> section of the  of the window.  This shows the mode
indicator function indicated by the selection in the <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">View</span></code> section
of the window; currently, the Complex Mode Indicator Function is shown.</p>
<p>The polynomial orders that will be computed in the stability diagram are specified
in the <code class="docutils literal notranslate"><span class="pre">Poly</span> <span class="pre">Order</span></code> section of the window.  Users can specify the range of
polynomial orders to compute, as well as the step size.  The current values of
<code class="docutils literal notranslate"><span class="pre">10</span></code>, <code class="docutils literal notranslate"><span class="pre">30</span></code> and <code class="docutils literal notranslate"><span class="pre">2</span></code> will result in computation of polynomial orders 10, 12,
14, … , 26, 28, and 30.  The <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Type</span></code> portion of the window allows
specification of the type of frequency response function that is being analyzed.
In our case, our frequency response function is an Acceleration over Force
frequency response function, so we can leave the default <code class="docutils literal notranslate"><span class="pre">Acceleration</span></code>
selection.</p>
<p>Below the main plot in the <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Diagram</span></code> portion of the window, the
<code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Range</span></code> can be specified.  The
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a> implementation in
SDynPy allows analyzing multiple frequency ranges separately and then combining
the final selected modes into a single set.  We will demonstrate this capability
here.</p>
<p>We will set the frequency range of the analysis to initially target the first
three modes of the system.  We can do this by adjusting the values of the
<code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Range</span></code> boxes, or by dragging the edges of the blue region of the
plot.</p>
<figure class="align-center" id="id36">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_1.png"><img alt="selecting the first analysis region" src="_images/Showcase_Beam_PolyPy_Region_1.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Selecting the first analysis region in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a></span><a class="headerlink" href="#id36" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can then click the <code class="docutils literal notranslate"><span class="pre">Compute</span> <span class="pre">Stabilization</span></code> button to tell PolyPy to
compute the stabilization diagram for these parameters.  Progress for these
computations is shown in the console window.  After the computations
are performed, the <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>
will automatically proceed to the <code class="docutils literal notranslate"><span class="pre">Select</span> <span class="pre">Poles</span></code> tab.</p>
<figure class="align-center" id="id37">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_1_Initial_Stability.png"><img alt="initial stability diagram for the first analysis region" src="_images/Showcase_Beam_PolyPy_Region_1_Initial_Stability.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Initial stability diagram for the first analysis region in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a></span><a class="headerlink" href="#id37" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Prominent in this tab is the stabilization diagram, shown in the
<code class="docutils literal notranslate"><span class="pre">Stabilization</span> <span class="pre">Diagram</span></code> portion of the window.  The stabilization diagram
consists of a mode indicator function (similarly chosen by selecting an entry
in the <code class="docutils literal notranslate"><span class="pre">Stabilization</span> <span class="pre">View</span></code> portion of the window) overlaid with various
markers that represent poles of the system (frequency and damping ratio).  The
color and shape of the poles determine how stable the pole is.  Stability is
computed by how much or little the pole changes as different polynomial orders
are computed.  A real mode will tend to remain unchanged if different order
polynomials are solved.  Computational poles, on the other hand, will tend to
vary as different orders are solved.  In PolyPy, a red X signifies an instable
pole, a blue triangle signifies that the frequency has stabilized, a
blue square signifies that the frequency and damping have stabilized, and a
green circle signifies that the frequency, damping, and participation factor
of the mode has stabilized.  Generally, we should only select green circles in
the stabilization diagram, preferably at an order where the symbol has been
green for a few orders.</p>
<p>In the <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>, poles are
selected by clicking on the markers on the stabilization diagram.  When hovering
the mouse over a marker, <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>
will report the frequency and damping of that pole in the bottom left corner of
the plot window.  When selected, the marker will turn a solid color, and the
pole will be reported in the table in the <code class="docutils literal notranslate"><span class="pre">Poles</span></code> section of the window.</p>
<p>If for whatever reason the stabilization diagram is not useful (perhaps the
wrong polynomial orders were specified) users can click on the <code class="docutils literal notranslate"><span class="pre">Discard</span></code>
button, which will delete the current stabilization diagram.  The user can then
proceed to the initial tab and select new parameters and recompute the
stabilization diagram.</p>
<p>As modes are selected, the <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>
will attempt to resynthesize frequency response functions from the selected shapes.
Options for performing this resynthesis are at the bottom of the window.
The <code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Line</span> <span class="pre">Weighting</span></code> specifies how the frequency lines are weighted
when computing mode shapes.  If <code class="docutils literal notranslate"><span class="pre">Magnitude</span></code> is selected, larger magnitude
frequency lines are weighted more heavily in the computation.  If <code class="docutils literal notranslate"><span class="pre">Uniform</span></code>
is selected, all frequency lines are considered equally.  Users can also specify
which frequency lines are used in the computation by adjusting the
<code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Lines</span> <span class="pre">at</span> <span class="pre">Resonance</span></code> and <code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Lines</span> <span class="pre">for</span> <span class="pre">Residuals</span></code> parameters.
The former specifies how many frequency lines around each pole are used for
computing mode shapes.  This can be useful for analysis with relatively high
noise floors, where the noise in the valleys between the peaks could contaiminate
the estimation of the mode shape.  The latter specifies how many frequency lines
at the beginning and end of the frequency range get included in the mode shape
computation when residuals are computed.  If all frequency lines are desired,
users can simply check the <code class="docutils literal notranslate"><span class="pre">Use</span> <span class="pre">all</span> <span class="pre">Frequency</span> <span class="pre">Lines</span></code> checkbox.</p>
<p>Users can switch between real and complex modes by unchecking or checking the
<code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Modes</span></code> checkbox.  If the <code class="docutils literal notranslate"><span class="pre">Auto-Resynthesize</span></code> checkbox is checked,
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a> will resynthesize
frequency response functions after each mode is selected.  This can be useful
for smaller systems to see the immediate effect of adding a specific mode; however,
this can slow the analysis down for larger datasets where it can take a non-negligable
amount of time to resynthesize shapes.  If the <code class="docutils literal notranslate"><span class="pre">Auto-Resynthesize</span></code> checkbox
is not checked,frequency response functions can be manually resynthesized by
clicking the <code class="docutils literal notranslate"><span class="pre">Resynthesize</span></code> button.  Finally, the use of residuals in mode shape
computation can be selected by clicking the <code class="docutils literal notranslate"><span class="pre">Residuals</span></code> checkbox.</p>
<p>To see the resynthesized frequency response functions compared to the original
ones, users can click on the buttons in the <code class="docutils literal notranslate"><span class="pre">Resynthesis</span></code> portion of the
window.  This will plot the frequency response functions or mode indicator
functions in a separate window.  These plots will be updated automatically
each time frequency response functions are resynthesized.</p>
<p>To start our analysis, let’s click the <code class="docutils literal notranslate"><span class="pre">CMIF</span></code> button to bring up a the
resynthesized complex mode indicator Function plot.  Initially, just one set of
data will be plotted as we currently do not have any modes selected on the
stability diagram.  Ensure both singular values of the CMIF are selected in the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> window.  Let’s click the
<code class="docutils literal notranslate"><span class="pre">Use</span> <span class="pre">all</span> <span class="pre">Frequency</span> <span class="pre">Lines</span></code> checkbox as well, and deselect the <code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Modes</span></code>
checkbox.</p>
<p>Now we will start selecting markers in the stabilization diagram.  Users should
note that the resynthesized CMIF should be updated as additional modes are
selected.  Ensure that green circle markers are selected for each of the three
main peaks in the CMIF.  We will not select one of the green circles around
2340 Hz, as there is no peak in the CMIF to indicate a real mode at that frequency.</p>
<figure class="align-center" id="id38">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_1_Stability.png"><img alt="stability diagram for the first analysis region with selected poles" src="_images/Showcase_Beam_PolyPy_Region_1_Stability.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Stability diagram for the first analysis region with three modes selected
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a></span><a class="headerlink" href="#id38" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id39">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_1_Resynth.png"><img alt="cmif resynthesis for the first region" src="_images/Showcase_Beam_PolyPy_Region_1_Resynth.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Resynthesis of the CMIF using the fit modes and residuals from the first
frequency region compared to CMIF
computed from the original frequency response functions.</span><a class="headerlink" href="#id39" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Given that this is a purely synthetic dataset, very good fits to the data
should be achievable, as shown in the previous figure up to 2200 Hz.  However,
we still have the peaks between 3000 and 4000 Hz to fit, so let’s do that now.</p>
<p>Return to the <code class="docutils literal notranslate"><span class="pre">Stabiliziation</span> <span class="pre">Setup</span></code> tab (do not discard the previous
stabilization diagram by pressing the <code class="docutils literal notranslate"><span class="pre">Discard</span></code> button!).  We will now
set up an analysis targetting the missing modes.  We can adjust the blue region
from approximately 3000 to 4000 Hz to target these peaks.</p>
<figure class="align-center" id="id40">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_2.png"><img alt="selecting the second analysis region" src="_images/Showcase_Beam_PolyPy_Region_2.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Selecting the second analysis region in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a></span><a class="headerlink" href="#id40" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can then again click the <code class="docutils literal notranslate"><span class="pre">Compute</span> <span class="pre">Stabilization</span></code> button, which will
bring us again to the <code class="docutils literal notranslate"><span class="pre">Select</span> <span class="pre">Poles</span></code> tab.  Note here that we now have two
sub-tabs on this window, each representing a different frequency range that
we analyzed.  The first region is on the <code class="docutils literal notranslate"><span class="pre">264.68--2265.38</span> <span class="pre">Hz</span></code> tab, and the
second is on the <code class="docutils literal notranslate"><span class="pre">2076.95--4000.00</span> <span class="pre">Hz</span></code> tab.  Note the exact values will differ
depending on the exact frequency range selected.</p>
<p>We can then continue selecting modes in this frequency range.  We will pick the
green circles corresponding to the strong peaks in the CMIF.  As we pick markers
in this frequency range, we should see the modes be combined with the modes
from the previous region when the resynthesis is occuring.</p>
<figure class="align-center" id="id41">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_2_Stability.png"><img alt="stability diagram for the second analysis region with selected poles" src="_images/Showcase_Beam_PolyPy_Region_2_Stability.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Stability diagram for the second analysis region with two modes selected
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a></span><a class="headerlink" href="#id41" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id42">
<a class="reference internal image-reference" href="_images/Showcase_Beam_PolyPy_Region_2_Resynth.png"><img alt="cmif resynthesis for both regions" src="_images/Showcase_Beam_PolyPy_Region_2_Resynth.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Resynthesis of the CMIF using the fit modes and residuals compared to CMIF
computed from the original frequency response functions.</span><a class="headerlink" href="#id42" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Clearly we have achieved very good fits, which is expected due to the synthetic
data set.</p>
<p>With modes fit, we can plot the mode shapes by selecting the <code class="docutils literal notranslate"><span class="pre">Plot</span> <span class="pre">Shapes</span></code>
button.  Note that had we not assigned geometry to the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">PolyPy_GUI</span></code></a>
using its
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_polypy.PolyPy_GUI.html#sdynpy.modal.sdynpy_polypy.PolyPy_GUI.set_geometry" title="sdynpy.modal.sdynpy_polypy.PolyPy_GUI.set_geometry"><code class="xref py py-class docutils literal notranslate"><span class="pre">set_geometry</span></code></a>
method, we would need to first load geometry using the <code class="docutils literal notranslate"><span class="pre">Load</span> <span class="pre">Geometry</span></code> button
prior to being able to plot shapes.  An example mode shape is shown below.</p>
<figure class="align-center" id="id43">
<a class="reference internal image-reference" href="images/Showcase_Beam_Mode_Animation_From_PolyPy.gif"><img alt="mode shape animation from polypy" src="images/Showcase_Beam_Mode_Animation_From_PolyPy.gif" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Mode shape of the beam computed from PolyPy animated on the geometry.</span><a class="headerlink" href="#id43" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We will then save the shape files to disk by clicking the <code class="docutils literal notranslate"><span class="pre">Export</span> <span class="pre">Shapes...</span></code>
button.  We will save the shapes to a file <code class="docutils literal notranslate"><span class="pre">shapes_polypy.npy</span></code>.  If we also
wanted to save the resynthesized frequency response functions, we could click
the <code class="docutils literal notranslate"><span class="pre">Export</span> <span class="pre">Fit</span> <span class="pre">Data...</span></code> button, which saves a much more complete data set
to disk.</p>
</section>
<section id="synthesize-modes-and-correlate-smac">
<h3><a class="toc-backref" href="#id96">Synthesize Modes and Correlate (SMAC)</a><a class="headerlink" href="#synthesize-modes-and-correlate-smac" title="Permalink to this heading"></a></h3>
<p>The second curve fitter available in SDynPy is Synthesize Modes and Correlate
(SMAC) <span id="id3">[<a class="reference internal" href="bibliography.html#id3" title="Daniel P. Hensley and Randy L. Mayes. Extending SMAC to multiple reference FRFs. In Proceedings of the 24th International Modal Analysis Conference, 220-230. St. Louis, Missouri, January 2006.">3</a>]</span>.  SMAC is a modal-filter based curve fitter.
While it is not as polished as the PolyPy curve fitter, it can often provide
better fits than PolyPy if the data quality is not as good.  Simlar to PolyPy,
SMAC can be run both via code or via graphical user interface.  We will
demonstrate the latter here using the
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a> class.  Again, we can
assign geometry directly to the <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a>
object so we don’t need to load from disk.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">smac</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">SMAC_GUI</span><span class="p">(</span><span class="n">frfs_spgui</span><span class="p">)</span>
<span class="n">smac</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span>
</pre></div>
</div>
<p>Similarly to PolyPy, the <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a>
is separated into different tabs representing different portions ofthe workflow.</p>
<p>The first tab, <code class="docutils literal notranslate"><span class="pre">Pseudoinverse</span></code> is where the pseudoinverse of the frequency
response function matrix is performed.  At this stage, we need to specify the
frequency range we are working over, as well as the data type, and whether
or not complex modes will be fit.  To keep a similar analysis to that in PolyPy,
we will choose <code class="docutils literal notranslate"><span class="pre">Normal</span> <span class="pre">Modes</span></code> rather than <code class="docutils literal notranslate"><span class="pre">Complex</span> <span class="pre">Modes</span></code>.  We will set the
<code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Range</span></code> from <code class="docutils literal notranslate"><span class="pre">260</span></code> to <code class="docutils literal notranslate"><span class="pre">4000</span></code> Hz, and we will keep the <code class="docutils literal notranslate"><span class="pre">Data</span> <span class="pre">Type</span></code>
as <code class="docutils literal notranslate"><span class="pre">Acceleration</span></code>.</p>
<figure class="align-center" id="id44">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_Pseudoinverse.png"><img alt="pseudoinverse tab in smac" src="_images/Showcase_Beam_SMAC_Pseudoinverse.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">Pseudoinverse</span></code> tab in <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a></span><a class="headerlink" href="#id44" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>When this is set correctly, we can press the <code class="docutils literal notranslate"><span class="pre">Compute</span> <span class="pre">Pseudoinverse</span></code> button
to perform the computation and move to the next tab.</p>
<p>The next tab is the <code class="docutils literal notranslate"><span class="pre">Correlation</span> <span class="pre">Coefficient</span></code> tab.  SMAC finds modes by comparing
what a mode <em>should look like</em> to what the frequency response functions <em>do look
like</em> to identify where modes are in the frequency response function.  It uses
the correlation coefficient to make these comparisons.  Where the correlation
coefficient approaches 1.0, one can be reasonably certain a mode is present.
Where the correlation coefficient is far from 1.0, a mode is not likely present.
SMAC generally guesses a large number of frequencies and damping values, finds
where the correlation coefficient is high, and then narrows in to converge on a
mode.  The <code class="docutils literal notranslate"><span class="pre">Correlation</span> <span class="pre">Coefficient</span></code> tab sets up the initial set of guesses
that SMAC makes.  The frequency resolution of the initial guesses is set via the
<code class="docutils literal notranslate"><span class="pre">Frequency</span> <span class="pre">Spacing</span></code> value, and the <code class="docutils literal notranslate"><span class="pre">Lines</span> <span class="pre">to</span> <span class="pre">use</span> <span class="pre">in</span> <span class="pre">Correlation</span> <span class="pre">Computation</span></code>
value specifies how many frequency lines around each frequency guess get used
to compute the correlation coefficient.  Also specified is an initial guess for
damping.  In the present case, we know the damping because we specified it to be
0.5%.  In a real situation, we generally would not know this information a priori.
Therefore we will leave this page with default values.</p>
<figure class="align-center" id="id45">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_CorrCoef.png"><img alt="correlation coefficient tab in smac" src="_images/Showcase_Beam_SMAC_CorrCoef.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">Correlation</span> <span class="pre">Coefficient</span></code> tab in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a></span><a class="headerlink" href="#id45" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can then click the <code class="docutils literal notranslate"><span class="pre">Compute</span> <span class="pre">Correlation</span> <span class="pre">Matrix</span></code> button to proceed to the
<code class="docutils literal notranslate"><span class="pre">Initial</span> <span class="pre">Rootlist</span></code> tab.  This tab shows a mode indicator function in the
upper plot and the correlation coefficient at each frequency guess in the lower
plot.  It will attempt to initially automatically select peaks in the correlation
coefficient plot higher than the value specified by the <code class="docutils literal notranslate"><span class="pre">Minimum</span> <span class="pre">Coefficient</span></code>
box, and populate the <code class="docutils literal notranslate"><span class="pre">Root</span> <span class="pre">List</span></code> on the left side of the window.  We can
see for this perfect synthetic data set,
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a> has made very good
initial guesses for our modes, even with 1% damping specified when the true
damping should be 0.5%.  The <code class="docutils literal notranslate"><span class="pre">Root</span> <span class="pre">List</span></code> also reports the current correlation
coefficient, which is near 1.  If initial guesses at roots were not identified
successfully, the user can click on the Correlation Coefficient plot to place
additional initial guesses.  Also, if erroneous initial guesses were placed,
the user can select the row in the <code class="docutils literal notranslate"><span class="pre">Root</span> <span class="pre">List</span></code> table and click the <code class="docutils literal notranslate"><span class="pre">Delete</span></code>
button.</p>
<figure class="align-center" id="id46">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_InitialRootlist.png"><img alt="initial rootlist tab in smac" src="_images/Showcase_Beam_SMAC_InitialRootlist.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">Initial</span> <span class="pre">Rootlist</span></code> tab in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a></span><a class="headerlink" href="#id46" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Clicking the <code class="docutils literal notranslate"><span class="pre">Confirm</span> <span class="pre">Initial</span> <span class="pre">Rootlist</span></code> button proceeds to the <code class="docutils literal notranslate"><span class="pre">Autofit</span> <span class="pre">Roots</span></code>
tab.  This tab sets up the optimizer that will converge to the frequency and
damping that gives the highest correlation coefficient from the initial guesses
obtained on the previous tab.  Generally the default values work well for this,
though users may want to tighten or loosen the convergence tolerances depending
on their goals.</p>
<figure class="align-center" id="id47">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_AutofitRoots.png"><img alt="autofit roots tab in smac" src="_images/Showcase_Beam_SMAC_AutofitRoots.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">Autofit</span> <span class="pre">Roots</span></code> tab in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a></span><a class="headerlink" href="#id47" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Clicking the <code class="docutils literal notranslate"><span class="pre">Autofit</span> <span class="pre">Roots</span></code> button will start the optimizer.  Progress is
reported in the console window.  If a root diverges, SMAC will discard it.
Similarly, if a root converges into another root, SMAC will discard one of them
to only keep one root.  When the optimizer has finished,
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a> will proceed to the final
<code class="docutils literal notranslate"><span class="pre">Shape</span> <span class="pre">and</span> <span class="pre">Evaluation</span></code> tab.</p>
<figure class="align-center" id="id48">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_ShapesEval.png"><img alt="shapes and evaluation tab in smac" src="_images/Showcase_Beam_SMAC_ShapesEval.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text"><code class="docutils literal notranslate"><span class="pre">Shape</span> <span class="pre">and</span> <span class="pre">Evaluation</span></code> tab in
<a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a></span><a class="headerlink" href="#id48" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The <code class="docutils literal notranslate"><span class="pre">Shape</span> <span class="pre">and</span> <span class="pre">Evaluation</span></code> tab shows the final root list table, consisting of
the frequency and damping values that the optimizer converged on.  Modes can
be selected or deselected from the final root set by checking or unchecking the
checkbox in the <code class="docutils literal notranslate"><span class="pre">Selection</span></code> column of the table.  If additional modes occur in
the data that were not captured in the initial root list, they can be added
manually by clicking on the <code class="docutils literal notranslate"><span class="pre">Add</span></code> button.  Likewise, if roots are found to
be incorrect, they can be selected in the table and deleted by pressing the
<code class="docutils literal notranslate"><span class="pre">Delete</span></code> button.  Resynthesis of frequency response functions or mode indicator
functions can be performed by checking the boxes in the <code class="docutils literal notranslate"><span class="pre">Synthesis</span></code> area of
the windows.  Additional options for using residuals or collapsing complex
modes to real modes can also be found there.  Clicking the <code class="docutils literal notranslate"><span class="pre">Resynthesize</span> <span class="pre">FRFs</span></code>
button will trigger the resynthesis.</p>
<p>Clicking the <code class="docutils literal notranslate"><span class="pre">Resynthesize</span> <span class="pre">FRFs</span></code> button will also bring up a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> window plotting the
selected resynthesis quantities.</p>
<figure class="align-center" id="id49">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_Resynth.png"><img alt="resynthesized cmifs from smac" src="_images/Showcase_Beam_SMAC_Resynth.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Resynthesis of the CMIF using the fit modes and residuals compared to CMIF
computed from the original frequency response functions.</span><a class="headerlink" href="#id49" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The <a class="reference internal" href="_autosummary/sdynpy.modal.sdynpy_smac.SMAC_GUI.html#sdynpy.modal.sdynpy_smac.SMAC_GUI" title="sdynpy.modal.sdynpy_smac.SMAC_GUI"><code class="xref py py-class docutils literal notranslate"><span class="pre">SMAC_GUI</span></code></a> <code class="docutils literal notranslate"><span class="pre">Add</span></code> button
brings up the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Root</span></code> dialog box.  We will cover this briefly, as its usage
can be somewhat unintutive.  In essence, the user is acting as the optimizer
while SMAC solves for the correlation coefficient over ranges of frequency
and damping values.</p>
<p>When the <code class="docutils literal notranslate"><span class="pre">Add</span> <span class="pre">Root</span></code> dialog appears, the initial frequency range is set to the
entire frequency range, and the initial damping range is set to the parameters
used in the <code class="docutils literal notranslate"><span class="pre">Autofit</span> <span class="pre">Root</span></code> tab.  The number of samples across the frequency
and damping axes are also taken from the values on this tab, though they can
be changed.  The top image in the dialog box shows a 2D correlation coefficient
plot where lighter colors correspond to a larger correlation coefficient.
The goal is to zoom in on the image (tightening frequency and damping tolerances)
until we converge on a peak in the correlation coefficient, which should
correspond to a mode of our system.</p>
<figure class="align-center" id="id50">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_AddRoot_Initial.png"><img alt="add root dialog" src="_images/Showcase_Beam_SMAC_AddRoot_Initial.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Add Root dialog showing the initial optimization range spanning the entire
frequency range.</span><a class="headerlink" href="#id50" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Normally, we will know approximately the frequency range in which we are
targetting a mode, either from a peak in a mode indicator function or a poor
frequency response function resynthesis in a given frequency band.  While in the
present case, SMAC has converged on all modes of the system in the bandwidth,
we will <em>pretend</em> that it has missed the fifth mode.  From the CMIF, we can see
that the fifth mode should be somewhere between 3550 and 3600 Hz, so we can
set that as th initial frequency range and click the <code class="docutils literal notranslate"><span class="pre">Recompute</span> <span class="pre">Correlation</span></code>
button.</p>
<figure class="align-center" id="id51">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_AddRoot_FreqRange_Lin.png"><img alt="add root dialog after setting an initial frequency range" src="_images/Showcase_Beam_SMAC_AddRoot_FreqRange_Lin.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Add Root dialog after setting an initial frequency range and recomputing
the correlation coefficient</span><a class="headerlink" href="#id51" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>There clearly is a peak in this region, given the large swath of white
color on the image.  We can see in the text on the right side of the window that
the maximum correlation in the image is currently 0.998 with a frequency at
3575 Hz and a damping value of 0.487%.  However, it can be difficult to identify
this position on the image due to the limited contrast available using the
linear colormap.  If we instead switch the colormap from <code class="docutils literal notranslate"><span class="pre">Linear</span></code> to <code class="docutils literal notranslate"><span class="pre">Log</span></code>,
we will see a much sharper peak that we can zoom into.</p>
<figure class="align-center" id="id52">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_AddRoot_FreqRange_Log.png"><img alt="add root dialog after setting an initial frequency range, log scaled" src="_images/Showcase_Beam_SMAC_AddRoot_FreqRange_Log.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Add Root dialog after setting an initial frequency range and recomputing
the correlation coefficient, visualized with logarithmic colormap</span><a class="headerlink" href="#id52" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Clearly this <code class="docutils literal notranslate"><span class="pre">Log</span></code> view of the correlation coefficient more accurately
pin-points the location of the peak correlation coefficient.  In general,
the <code class="docutils literal notranslate"><span class="pre">Linear</span></code> colormap is more useful when performing rough finding of peaks
in the data, and the <code class="docutils literal notranslate"><span class="pre">Log</span></code> colormap is more useful when performing the final
“hone in” on the peak.</p>
<p>To converge on the peak, we can simply zoom in on the image and click the
<code class="docutils literal notranslate"><span class="pre">Recompute</span> <span class="pre">Correlation</span></code> button.  We can do this until we reach our desired
convergence tolerance.  Note, however, that eventually we will reach numerical
precision and the colormap will break down.  If this happens, simply zoom out
a bit and <code class="docutils literal notranslate"><span class="pre">Recompute</span> <span class="pre">Correlation</span></code>.</p>
<figure class="align-center" id="id53">
<a class="reference internal image-reference" href="_images/Showcase_Beam_SMAC_AddRoot_Converged.png"><img alt="add root dialog converged" src="_images/Showcase_Beam_SMAC_AddRoot_Converged.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Add Root dialog after converging on a frequency and damping.</span><a class="headerlink" href="#id53" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Clicking the <code class="docutils literal notranslate"><span class="pre">Save</span></code> button on the dialog will then close the dialog and add
the mode to the table.  We can see that this mode has a slightly higher
correlation coefficient than the original mode found by the optimizer, so we
could select that row and press the <code class="docutils literal notranslate"><span class="pre">Delete</span></code> button to ensure that the mode
isn’t included twice.  Again we can plot the mode shapes by pressing the <code class="docutils literal notranslate"><span class="pre">Plot</span> <span class="pre">Shapes</span></code>
button (be sure to click the <code class="docutils literal notranslate"><span class="pre">Resynthesize</span> <span class="pre">FRFs</span></code> button first, which will
create the shapes, otherwise a dialog will appear telling you the shapes have not
been created yet).</p>
<p>Finally we can write the shapes to disk.  We will then save the shape files to
disk by clicking the <code class="docutils literal notranslate"><span class="pre">Save</span> <span class="pre">Shapes</span></code>
button.  We will save the shapes to a file <code class="docutils literal notranslate"><span class="pre">shapes_smac.npy</span></code>.</p>
</section>
</section>
<section id="comparing-modes">
<h2><a class="toc-backref" href="#id97">Comparing Modes</a><a class="headerlink" href="#comparing-modes" title="Permalink to this heading"></a></h2>
<p>In many modal analysis workflows we wish to compare shapes to each other.  For
example, we may wish to compare shapes from a finite element model to those from
a test.  Or perhaps we may wish to compare two sets of shapes from a model that
has varying parameters.  SDynPy offers several ways to easily compare modes.</p>
<p>First, let’s load the modal data from the previous modal analyses.  We will
use the <code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.load</span></code>
function targetting the file names from the previous analyses.  If the files
are not in the current working directory, a full path will need to be provided.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes_polypy</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;shapes_polypy.npy&#39;</span><span class="p">)</span>
<span class="n">shapes_smac</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="s1">&#39;shapes_smac.npy&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>To compare modes, we often need to first figure out which modes in each dataset
correspond to one another.  Especially if closely spaced modes exist, there may
be mode order changes, so we cannot always compare the first mode in the first
data set with the first mode of the second.  Especially when comparing model
to test data, there may be rigid body modes from the model that were not measured
in the test.  Mode correspondences are often assigned via shape, often using a
metric such as the Modal Assurance Criterion (MAC) matrix.</p>
<p>SDynPy can construct a MAC matrix easily using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.mac.html#sdynpy.core.sdynpy_shape.mac" title="sdynpy.core.sdynpy_shape.mac"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.mac</span></code></a> function.  The matrix
can be plotted using the
<a class="reference internal" href="_autosummary/sdynpy.signal_processing.sdynpy_correlation.matrix_plot.html#sdynpy.signal_processing.sdynpy_correlation.matrix_plot" title="sdynpy.signal_processing.sdynpy_correlation.matrix_plot"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.matrix_plot</span></code></a>
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Compute MACs</span>
<span class="n">mac_polypy</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">mac</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span><span class="n">shapes_polypy</span><span class="p">)</span>
<span class="n">mac_smac</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">mac</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span><span class="n">shapes_smac</span><span class="p">)</span>
<span class="c1"># Create a figure</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;MAC Matrices&#39;</span><span class="p">,</span><span class="n">sharey</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span><span class="n">sharex</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Plot the PolyPy MAC</span>
<span class="n">sdpy</span><span class="o">.</span><span class="n">matrix_plot</span><span class="p">(</span><span class="n">mac_polypy</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;FEM Shapes&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;PolyPy Shapes&#39;</span><span class="p">)</span>
<span class="c1"># Plot the SMAC MAC</span>
<span class="n">sdpy</span><span class="o">.</span><span class="n">matrix_plot</span><span class="p">(</span><span class="n">mac_smac</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;SMAC Shapes&#39;</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id54">
<a class="reference internal image-reference" href="_images/Showcase_Beam_MAC.png"><img alt="mac matrices between fit shapes and fem shapes" src="_images/Showcase_Beam_MAC.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">MAC between fit shapes and finite element shapes.</span><a class="headerlink" href="#id54" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>The frequency and damping ratios are also often compared.  The
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.shape_comparison_table.html#sdynpy.core.sdynpy_shape.shape_comparison_table" title="sdynpy.core.sdynpy_shape.shape_comparison_table"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.shape_comparison_table</span></code></a>
function is useful for this.  We can pass in two sets of shapes to see the
tabulated differences in the parameters.  First we will need to extract the
shape correspondences.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">polypy_correspondences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mac_polypy</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">)</span>
<span class="n">smac_correspondences</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mac_smac</span> <span class="o">&gt;</span> <span class="mf">0.9</span><span class="p">)</span>
</pre></div>
</div>
<p>Then we can print the mode tables.  We will adjust the formatting of the percent
errors to give more decimal places, as the default will only plot one decimal
place, resulting in all frequencies having 0.0% error.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">shape_comparison_table</span><span class="p">(</span>
    <span class="n">shapes</span><span class="p">[</span><span class="n">polypy_correspondences</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
    <span class="n">shapes_polypy</span><span class="p">[</span><span class="n">polypy_correspondences</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="n">percent_error_format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:0.3f}</span><span class="s1">%&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>This results in printing the following table.</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mode</span>  <span class="n">Freq</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Hz</span><span class="p">)</span>  <span class="n">Freq</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Hz</span><span class="p">)</span>  <span class="n">Freq</span> <span class="n">Error</span>  <span class="n">Damp</span> <span class="mi">1</span>  <span class="n">Damp</span> <span class="mi">2</span>  <span class="n">Damp</span> <span class="n">Error</span>  <span class="n">MAC</span>
   <span class="mi">1</span>       <span class="mf">648.56</span>       <span class="mf">648.71</span>     <span class="o">-</span><span class="mf">0.024</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.51</span><span class="o">%</span>     <span class="o">-</span><span class="mf">1.064</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">2</span>      <span class="mf">1297.12</span>      <span class="mf">1296.95</span>      <span class="mf">0.014</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>     <span class="o">-</span><span class="mf">0.307</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">3</span>      <span class="mf">1787.81</span>      <span class="mf">1787.95</span>     <span class="o">-</span><span class="mf">0.008</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.51</span><span class="o">%</span>     <span class="o">-</span><span class="mf">2.028</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">4</span>      <span class="mf">3504.98</span>      <span class="mf">3505.09</span>     <span class="o">-</span><span class="mf">0.003</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.49</span><span class="o">%</span>      <span class="mf">1.672</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">5</span>      <span class="mf">3575.61</span>      <span class="mf">3576.11</span>     <span class="o">-</span><span class="mf">0.014</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.49</span><span class="o">%</span>      <span class="mf">2.010</span><span class="o">%</span>  <span class="mi">100</span>
</pre></div>
</div>
<p>The identical analysis is performed for the SMAC dataset.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">shape_comparison_table</span><span class="p">(</span>
    <span class="n">shapes</span><span class="p">[</span><span class="n">smac_correspondences</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span>
    <span class="n">shapes_smac</span><span class="p">[</span><span class="n">smac_correspondences</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span>
    <span class="n">percent_error_format</span><span class="o">=</span><span class="s1">&#39;</span><span class="si">{:0.3f}</span><span class="s1">%&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Which results in</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Mode</span>  <span class="n">Freq</span> <span class="mi">1</span> <span class="p">(</span><span class="n">Hz</span><span class="p">)</span>  <span class="n">Freq</span> <span class="mi">2</span> <span class="p">(</span><span class="n">Hz</span><span class="p">)</span>  <span class="n">Freq</span> <span class="n">Error</span>  <span class="n">Damp</span> <span class="mi">1</span>  <span class="n">Damp</span> <span class="mi">2</span>  <span class="n">Damp</span> <span class="n">Error</span>  <span class="n">MAC</span>
   <span class="mi">1</span>       <span class="mf">648.56</span>       <span class="mf">648.65</span>     <span class="o">-</span><span class="mf">0.014</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.55</span><span class="o">%</span>     <span class="o">-</span><span class="mf">9.198</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">2</span>      <span class="mf">1297.12</span>      <span class="mf">1297.13</span>     <span class="o">-</span><span class="mf">0.001</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.51</span><span class="o">%</span>     <span class="o">-</span><span class="mf">2.900</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">3</span>      <span class="mf">1787.81</span>      <span class="mf">1787.75</span>      <span class="mf">0.003</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.53</span><span class="o">%</span>     <span class="o">-</span><span class="mf">6.121</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">4</span>      <span class="mf">3504.98</span>      <span class="mf">3504.82</span>      <span class="mf">0.005</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.49</span><span class="o">%</span>      <span class="mf">2.564</span><span class="o">%</span>  <span class="mi">100</span>
   <span class="mi">5</span>      <span class="mf">3575.61</span>      <span class="mf">3575.63</span>     <span class="o">-</span><span class="mf">0.001</span><span class="o">%</span>   <span class="mf">0.50</span><span class="o">%</span>   <span class="mf">0.51</span><span class="o">%</span>     <span class="o">-</span><span class="mf">1.750</span><span class="o">%</span>  <span class="mi">100</span>
</pre></div>
</div>
<p>We can see that SMAC has perhaps identified frequencies more accurately, but
was less accurate on the damping estimates.  Note that these are not general
rules and likely depend on the parameters selected in each curve fitting tool.
Note that both curve fitters have identified the modes very accurately.</p>
<p>While the MAC can give a rough idea of how correlated pairs of shapes are, it
does not give an intuitive view of how the shapes are different.  For this, we
would often like to plot the shapes on top of one another.  We can also do this
easily in SDynPy with the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries" title="sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Geometry.overlay_geometries</span></code></a>
and
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.overlay_shapes" title="sdynpy.core.sdynpy_shape.ShapeArray.overlay_shapes"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.overlay_shapes</span></code></a>
functions.
Note that the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_shape.ShapeArray.html#sdynpy.core.sdynpy_shape.ShapeArray.overlay_shapes" title="sdynpy.core.sdynpy_shape.ShapeArray.overlay_shapes"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.shape.overlay_shapes</span></code></a>
function will automatically call the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries" title="sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Geometry.overlay_geometries</span></code></a>
functions, so if we are comparing shapes, we only need to call the latter function.
We simply give the function a set of geometries and a set of shapes to overlay,
and we can additionally specify colors to override so we can identify which is
which.  Because the fit shapes and finite element shapes share the same geometry,
we simply pass it twice.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Overlay shapes</span>
<span class="n">overlaid_geometry</span><span class="p">,</span><span class="n">overlaid_shapes</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">overlay_shapes</span><span class="p">(</span>
    <span class="p">(</span><span class="n">geometry</span><span class="p">,</span><span class="n">geometry</span><span class="p">),</span>
    <span class="p">(</span><span class="n">shapes</span><span class="p">[</span><span class="n">polypy_correspondences</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">shapes_polypy</span><span class="p">[</span><span class="n">polypy_correspondences</span><span class="p">[</span><span class="mi">1</span><span class="p">]]),</span>
    <span class="n">color_override</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">7</span><span class="p">])</span>
<span class="c1"># Plot the overlaid shapes</span>
<span class="n">overlaid_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">overlaid_shapes</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id55">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Mode_Comparison_Animation.gif"><img alt="mode shape comparison animation" src="_images/Showcase_Beam_Mode_Comparison_Animation.gif" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Finite element (green) and fit (blue) shapes overlaid.</span><a class="headerlink" href="#id55" title="Permalink to this image"></a></p>
</figcaption>
</figure>
</section>
<section id="adding-another-beam">
<h2><a class="toc-backref" href="#id98">Adding Another Beam</a><a class="headerlink" href="#adding-another-beam" title="Permalink to this heading"></a></h2>
<p>Let’s make our system more complicated by adding an additional beam.  We can
demonstrate some of SDynPy’s more advanced features by combining the two
structures together.  This beam will be half as long as the previous beam and
connect at a right angle to the end of the first beam.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">system_2</span><span class="p">,</span><span class="n">geometry_2</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">System</span><span class="o">.</span><span class="n">beam</span><span class="p">(</span>
    <span class="n">length</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span> <span class="c1"># Meters</span>
    <span class="n">width</span> <span class="o">=</span> <span class="mf">0.01</span><span class="p">,</span> <span class="c1"># Meters</span>
    <span class="n">height</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="c1"># Meters</span>
    <span class="n">num_nodes</span> <span class="o">=</span> <span class="mi">11</span><span class="p">,</span>
    <span class="n">material</span><span class="o">=</span><span class="s1">&#39;steel&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>We will modify the geometry of this second beam by rotating its coordinate
system.  We will also change the color of the traceline so it is more
distinguishable from the initial beam.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">geometry_2</span><span class="o">.</span><span class="n">coordinate_system</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="mi">0</span><span class="p">,:</span><span class="mi">3</span><span class="p">,:</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span>
                                                         <span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span>
                                                         <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]])</span>
<span class="n">geometry_2</span><span class="o">.</span><span class="n">traceline</span><span class="o">.</span><span class="n">color</span> <span class="o">=</span> <span class="mi">7</span>
</pre></div>
</div>
<p>If we plot the geometry, we can now see that it is oriented 90 degrees to the
original geometry.  We can use the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries" title="sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Geometry.overlay_geometries</span></code></a>
function to quickly produce a combined geometry which to plot.  We will also have
the system return a <code class="docutils literal notranslate"><span class="pre">node_id_offset</span></code>, which we can use to offset the degrees
of freedom of our systems so they remain consistent with the geometry.  This is
needed because the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries" title="sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Geometry.overlay_geometries</span></code></a>
function offsets the node numbers so there are no conflicts between the two
geometries.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Overlay geometry and plot</span>
<span class="n">combined_geometry</span><span class="p">,</span><span class="n">node_id_offset</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">Geometry</span><span class="o">.</span><span class="n">overlay_geometries</span><span class="p">(</span>
    <span class="p">(</span><span class="n">geometry</span><span class="p">,</span><span class="n">geometry_2</span><span class="p">),</span>
    <span class="n">return_node_id_offset</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="c1"># Plot the combined geometry</span>
<span class="n">combined_geometry</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id56">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Geometry_2.png"><img alt="second geometry" src="_images/Showcase_Beam_Geometry_2.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Geometry of the two-beam system.</span><a class="headerlink" href="#id56" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Now let’s think about combining the systems.  First, let’s add some damping to
the systems.  We saw previously that we had some issues with the undamped systems
not being equivalent to shapes, as well as having potentially infinite displacement.
We can add some approximate damping to the
system such that when a modal transformation is performed, it will result in
modal damping. The <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object
has an
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.assign_modal_damping" title="sdynpy.core.sdynpy_system.System.assign_modal_damping"><code class="xref py py-func docutils literal notranslate"><span class="pre">assign_modal_damping</span></code></a>
method that is useful for doing this.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">damped_system</span> <span class="o">=</span> <span class="n">system</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">damped_system</span><span class="o">.</span><span class="n">assign_modal_damping</span><span class="p">(</span><span class="mf">0.005</span><span class="p">)</span>
<span class="n">damped_system_2</span> <span class="o">=</span> <span class="n">system_2</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
<span class="n">damped_system_2</span><span class="o">.</span><span class="n">assign_modal_damping</span><span class="p">(</span><span class="mf">0.005</span><span class="p">)</span>
</pre></div>
</div>
<p>With damping added, we can concatenate the systems together using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.concatenate" title="sdynpy.core.sdynpy_system.System.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate</span></code></a> class
method of <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>.  Note that this
does not actually attach either structure to the other.  It simply puts them in
the same <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a> object.  If we
examine the system matrices, we will see there is no coupling between any
degrees of freedom on the first beam to the second beam.  Note that the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.concatenate" title="sdynpy.core.sdynpy_system.System.concatenate"><code class="xref py py-func docutils literal notranslate"><span class="pre">concatenate</span></code></a>
function accepts the <code class="docutils literal notranslate"><span class="pre">node_id_offset</span></code> from the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_geometry.Geometry.html#sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries" title="sdynpy.core.sdynpy_geometry.Geometry.overlay_geometries"><code class="xref py py-func docutils literal notranslate"><span class="pre">sdpy.Geometry.overlay_geometries</span></code></a>
function.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">combined_system</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">System</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">damped_system</span><span class="p">,</span><span class="n">damped_system_2</span><span class="p">),</span>
                                          <span class="n">node_id_offset</span><span class="p">)</span>
<span class="c1"># Plot the combined system matrices</span>
<span class="n">fig</span><span class="p">,</span><span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">num</span><span class="o">=</span><span class="s1">&#39;Combined System Matrices&#39;</span><span class="p">,</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">6</span><span class="p">))</span>
<span class="n">ax</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
<span class="c1"># Transformation</span>
<span class="n">timg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">combined_system</span><span class="o">.</span><span class="n">transformation</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Transformation&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">timg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="c1"># Mass</span>
<span class="n">mimg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">combined_system</span><span class="o">.</span><span class="n">mass</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Mass&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">mimg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># Damping</span>
<span class="n">dimg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">combined_system</span><span class="o">.</span><span class="n">damping</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Damping&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">dimg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
<span class="c1"># Stiffness</span>
<span class="n">simg</span> <span class="o">=</span> <span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">combined_system</span><span class="o">.</span><span class="n">stiffness</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_title</span><span class="p">(</span><span class="s1">&#39;Stiffness&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Physical DoF&#39;</span><span class="p">)</span>
<span class="n">plt</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">simg</span><span class="p">,</span><span class="n">ax</span><span class="o">=</span><span class="n">ax</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
<span class="n">fig</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id57">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Combined_System_Matrices.png"><img alt="second geometry" src="_images/Showcase_Beam_Combined_System_Matrices.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">System matrices for the combined two beam system.</span><a class="headerlink" href="#id57" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can also verify by computing mode shapes or frequency responses.  We can
see that each mode shape generally consists of motion of only one structure,
meaning the two systems are not connected.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">combined_shapes</span> <span class="o">=</span> <span class="n">combined_system</span><span class="o">.</span><span class="n">eigensolution</span><span class="p">()</span>
<span class="n">combined_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">combined_shapes</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id58">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Mode_Combined_Unconstrained_Animation_1.gif"><img alt="combined mode beam 1" src="_images/Showcase_Beam_Mode_Combined_Unconstrained_Animation_1.gif" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Combined mode showing motion on just the first beam</span><a class="headerlink" href="#id58" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id59">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Mode_Combined_Unconstrained_Animation_2.gif"><img alt="combined mode beam 2" src="_images/Showcase_Beam_Mode_Combined_Unconstrained_Animation_2.gif" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Combined mode showing motion on just the second beam</span><a class="headerlink" href="#id59" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can also verify with frequency response functions.  For example, we can
compute a frequency response function between the end of one beam to the end
of the other beam and verify that it is identically zero.  We can first check
to see the degrees of freedom of the beam.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">combined_geometry</span><span class="o">.</span><span class="n">plot_coordinate</span><span class="p">(</span><span class="n">label_dofs</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id60">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Combined_Coordinates.png"><img alt="combined geometry degrees of freedom" src="_images/Showcase_Beam_Combined_Coordinates.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Degrees of freedom in the combined model</span><a class="headerlink" href="#id60" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>Then we can compute frequency response functions between the two structures and
verify they are zero.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">combined_frf</span> <span class="o">=</span> <span class="n">combined_system</span><span class="o">.</span><span class="n">frequency_response</span><span class="p">(</span>
    <span class="n">frequency_lines</span><span class="p">,</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="s1">&#39;121Y+&#39;</span><span class="p">),</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="s1">&#39;211Z+&#39;</span><span class="p">))</span>
</pre></div>
</div>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [68]: combined_frf.ordinate</span>
<span class="go">Out[68]:</span>
<span class="go">array([[[0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j,</span>
<span class="go">         ...</span>
<span class="go">         0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j, 0.+0.j]]])</span>
</pre></div>
</div>
<p>Note in the coordinate plot that because we have rotated the beams, the degrees
of freedom do not necessarily match between the two systems.  At the coincident
nodes, degree of freedom <code class="docutils literal notranslate"><span class="pre">101Z+</span></code> is not equivalent to <code class="docutils literal notranslate"><span class="pre">201Z+</span></code>, but instead
it is equivalent <code class="docutils literal notranslate"><span class="pre">201Y+</span></code>.</p>
</section>
<section id="applying-constraints-to-the-system">
<h2><a class="toc-backref" href="#id99">Applying Constraints to the System</a><a class="headerlink" href="#applying-constraints-to-the-system" title="Permalink to this heading"></a></h2>
<p>In order to make the system behave as one structure instead of two separate
structures, we must apply constraints to the system.  For example, we have
just identified that degrees of freedom <code class="docutils literal notranslate"><span class="pre">101Z+</span></code> and <code class="docutils literal notranslate"><span class="pre">201Y+</span></code> correspond
to the same position in space moving the same direction, so we should constrain
them to move together.  We should apply similar constraints to the other
translations and rotations at that location.  While SDynPy has the ability to
apply constraints directly to degrees of freedom in this way using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.substructure_by_coordinate" title="sdynpy.core.sdynpy_system.System.substructure_by_coordinate"><code class="xref py py-func docutils literal notranslate"><span class="pre">substructure_by_coordinate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>
object, it can also apply constraints automatically based on coincident geometry
using the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.substructure_by_position" title="sdynpy.core.sdynpy_system.System.substructure_by_position"><code class="xref py py-func docutils literal notranslate"><span class="pre">substructure_by_position</span></code></a>
class method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>.
This latter method will automatically determine which nodes are coincident,
as well as handle the different coordinate systems between the two systems.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">constrained_system</span><span class="p">,</span><span class="n">constrained_geometry</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">system</span><span class="o">.</span><span class="n">substructure_by_position</span><span class="p">(</span>
    <span class="p">(</span><span class="n">damped_system</span><span class="p">,</span><span class="n">damped_system_2</span><span class="p">),</span>
    <span class="p">(</span><span class="n">geometry</span><span class="p">,</span><span class="n">geometry_2</span><span class="p">))</span>
</pre></div>
</div>
<p>If we compare our constrained system to the simply combined system, we will see
that they have the same number of physical degrees of freedom, but the
constrained system has six fewer internal degrees of freedom.  These are lost
due to the application of six constraints combining the rotational and
translational degrees of freedom together.  Each constraint removes one way the
system can move.</p>
<div class="highlight-console notranslate"><div class="highlight"><pre><span></span><span class="go">In [69]: combined_system</span>
<span class="go">Out[69]: System with 192 DoFs (192 internal DoFs)</span>

<span class="go">In [70]: constrained_system</span>
<span class="go">Out[70]: System with 192 DoFs (186 internal DoFs)</span>
</pre></div>
</div>
<p>Now if we compute mode shapes or frequency response functions on this constrained
system, we should see the two structures moving together.  Additionally, if you
apply a force to the first beam, the second beam will begin to move.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">constrained_shapes</span> <span class="o">=</span> <span class="n">constrained_system</span><span class="o">.</span><span class="n">eigensolution</span><span class="p">()</span>
<span class="n">constrained_geometry</span><span class="o">.</span><span class="n">plot_shape</span><span class="p">(</span><span class="n">constrained_shapes</span><span class="p">)</span>

<span class="n">constrained_frf</span> <span class="o">=</span> <span class="n">constrained_system</span><span class="o">.</span><span class="n">frequency_response</span><span class="p">(</span>
    <span class="n">frequency_lines</span><span class="p">,</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="s1">&#39;121Y+&#39;</span><span class="p">),</span>
    <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="s1">&#39;211Z+&#39;</span><span class="p">))</span>

<span class="n">constrained_frf</span><span class="o">.</span><span class="n">plot</span><span class="p">()</span>
</pre></div>
</div>
<figure class="align-center" id="id61">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Mode_Constrained_Animation.gif"><img alt="mode of the constrained system" src="_images/Showcase_Beam_Mode_Constrained_Animation.gif" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Constrained mode showing motion on both beams</span><a class="headerlink" href="#id61" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<figure class="align-center" id="id62">
<a class="reference internal image-reference" href="_images/Showcase_Beam_Constrained_FRF.png"><img alt="frf of the constrained system" src="_images/Showcase_Beam_Constrained_FRF.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Frequency response function of the constrained system</span><a class="headerlink" href="#id62" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>For more advanced substructuring examples in SDynPy, see the example on the
<a class="reference external" href="example_problems/transmission_simulator.html">Transmission Simulator Method</a>.</p>
</section>
<section id="frequency-based-substructuring">
<h2><a class="toc-backref" href="#id100">Frequency-Based Substructuring</a><a class="headerlink" href="#frequency-based-substructuring" title="Permalink to this heading"></a></h2>
<p>In addition to assembling system matrices we can also perform substructuring
in the frequency domain.  We will need frequency response functions for all
connection degrees of freedom, as well as the frequency response functions we
wish to compute in the assembled system.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the interface frfs</span>
<span class="n">interface_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span>
    <span class="p">[</span><span class="mi">101</span><span class="p">,</span><span class="mi">201</span><span class="p">],[</span><span class="s1">&#39;X+&#39;</span><span class="p">,</span><span class="s1">&#39;Y+&#39;</span><span class="p">,</span><span class="s1">&#39;Z+&#39;</span><span class="p">,</span><span class="s1">&#39;RX+&#39;</span><span class="p">,</span><span class="s1">&#39;RY+&#39;</span><span class="p">,</span><span class="s1">&#39;RZ+&#39;</span><span class="p">],</span>
    <span class="n">force_broadcast</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># Get the frfs that we want to compute in the constrained systems</span>
<span class="n">response_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;121Y+&#39;</span><span class="p">])</span>
<span class="n">reference_dofs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span><span class="n">string_array</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;211Z+&#39;</span><span class="p">])</span>

<span class="c1"># Compute unconstrained frequency response functions</span>
<span class="n">combined_frf</span> <span class="o">=</span> <span class="n">combined_system</span><span class="o">.</span><span class="n">frequency_response</span><span class="p">(</span>
    <span class="n">frequency_lines</span><span class="p">,</span>
    <span class="n">responses</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">interface_dofs</span><span class="p">,</span><span class="n">response_dofs</span><span class="p">)),</span>
    <span class="n">references</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">interface_dofs</span><span class="p">,</span><span class="n">reference_dofs</span><span class="p">)))</span>
</pre></div>
</div>
<p>To perform the substructuring, we will have to assemble the degree of freedom
pairs that we wish to constrain, similar to what we would have had to have done
had we used the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.substructure_by_coordinate" title="sdynpy.core.sdynpy_system.System.substructure_by_coordinate"><code class="xref py py-func docutils literal notranslate"><span class="pre">substructure_by_coordinate</span></code></a>
method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>
object instead of the
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System.substructure_by_position" title="sdynpy.core.sdynpy_system.System.substructure_by_position"><code class="xref py py-func docutils literal notranslate"><span class="pre">substructure_by_position</span></code></a>
class method of the <a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_system.System.html#sdynpy.core.sdynpy_system.System" title="sdynpy.core.sdynpy_system.System"><code class="xref py py-class docutils literal notranslate"><span class="pre">System</span></code></a>.  The
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray" title="sdynpy.core.sdynpy_data.TransferFunctionArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">TransferFunctionArray</span></code></a>
class also has a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.TransferFunctionArray.html#sdynpy.core.sdynpy_data.TransferFunctionArray.substructure_by_coordinate" title="sdynpy.core.sdynpy_data.TransferFunctionArray.substructure_by_coordinate"><code class="xref py py-func docutils literal notranslate"><span class="pre">substructure_by_coordinate</span></code></a>
method that accepts degree of freedom pairs that will be used to apply
constraints.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">dof_pairs</span> <span class="o">=</span> <span class="n">sdpy</span><span class="o">.</span><span class="n">coordinate_array</span><span class="p">(</span>
    <span class="n">string_array</span> <span class="o">=</span> <span class="p">[[</span><span class="s1">&#39;101Z+&#39;</span><span class="p">,</span><span class="s1">&#39;201Y+&#39;</span><span class="p">],</span>
                    <span class="p">[</span><span class="s1">&#39;101Y+&#39;</span><span class="p">,</span><span class="s1">&#39;201X+&#39;</span><span class="p">],</span>
                    <span class="p">[</span><span class="s1">&#39;101X+&#39;</span><span class="p">,</span><span class="s1">&#39;201Z+&#39;</span><span class="p">],</span>
                    <span class="p">[</span><span class="s1">&#39;101RZ+&#39;</span><span class="p">,</span><span class="s1">&#39;201RY+&#39;</span><span class="p">],</span>
                    <span class="p">[</span><span class="s1">&#39;101RY+&#39;</span><span class="p">,</span><span class="s1">&#39;201RX+&#39;</span><span class="p">],</span>
                    <span class="p">[</span><span class="s1">&#39;101RX+&#39;</span><span class="p">,</span><span class="s1">&#39;201RZ+&#39;</span><span class="p">]])</span>

<span class="c1"># Perform substructuring</span>
<span class="n">constrained_frf_ss</span> <span class="o">=</span> <span class="n">combined_frf</span><span class="o">.</span><span class="n">substructure_by_coordinate</span><span class="p">(</span><span class="n">dof_pairs</span><span class="p">)</span>
</pre></div>
</div>
<p>We can then compare frequency response functions across between the systems
to those computed from the combined system matrices to ensure they give the
same result.  SDynPy’s book-keeping capabilities are useful here.  We can index
the frequency response functions with a
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
object to pull out the desired function.  We can get this
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_coordinate.CoordinateArray.html#sdynpy.core.sdynpy_coordinate.CoordinateArray" title="sdynpy.core.sdynpy_coordinate.CoordinateArray"><code class="xref py py-class docutils literal notranslate"><span class="pre">CoordinateArray</span></code></a>
directly from the function against which we wish to compare, to ensure we are
comparing identical degrees of freedom.  The
<a class="reference internal" href="_autosummary/sdynpy.core.sdynpy_data.GUIPlot.html#sdynpy.core.sdynpy_data.GUIPlot" title="sdynpy.core.sdynpy_data.GUIPlot"><code class="xref py py-class docutils literal notranslate"><span class="pre">GUIPlot</span></code></a> will allow easy comparisons
between functions.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="c1"># Get the coordinates</span>
<span class="n">compare_coordinates</span> <span class="o">=</span> <span class="n">constrained_frf</span><span class="o">.</span><span class="n">coordinate</span>

<span class="c1"># Extract the correct functions by indexing with the coordinates</span>
<span class="n">constrained_frf_compare</span> <span class="o">=</span> <span class="n">constrained_frf_ss</span><span class="p">[</span><span class="n">compare_coordinates</span><span class="p">]</span>

<span class="c1"># Plot the comparison</span>
<span class="n">sdpy</span><span class="o">.</span><span class="n">GUIPlot</span><span class="p">(</span><span class="n">constrained_frf</span><span class="p">,</span><span class="n">constrained_frf_compare</span><span class="p">)</span>
</pre></div>
</div>
<figure class="align-center" id="id63">
<a class="reference internal image-reference" href="_images/Showcase_Beam_FBS_Results.png"><img alt="frf of the constrained system compared to that constructed by fbs" src="_images/Showcase_Beam_FBS_Results.png" style="width: 600px;" /></a>
<figcaption>
<p><span class="caption-text">Frequency response comparison between the coupled system and frequency-based
substructuring, showing identical results.</span><a class="headerlink" href="#id63" title="Permalink to this image"></a></p>
</figcaption>
</figure>
<p>We can see that the results compare identically to the previous case of
constraining the system matrices and then computing frequency response functions
from the constrained system.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="usage.html" class="btn btn-neutral float-left" title="Usage" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="core_functionality.html" class="btn btn-neutral float-right" title="Core Functionality" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
<jinja2.runtime.BlockReference object at 0x7f596f0a4f10>
<img src="_images/snl.jpg" alt="Sandia National Laboratories" style="height:40px">

  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>